--- 
title: "R Graphics Cookbook, 2nd edition"
author: "Winston Chang"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
biblio-style: apalike
link-citations: yes
description: "R Graphics Cookbook, 2nd edition"
---

```{r echo = FALSE, cache = FALSE}
# Need to load MASS before dplyr because of conflict with select()
suppressPackageStartupMessages({
    library(MASS)
    library(dplyr)
})
```
Preface {-}
=======

Text here.

<!--chapter:end:index.Rmd-->

---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
source("utils.R", local = TRUE)
```

R Basics {#CHAPTER-R-BASICS}
========

This chapter covers the basics: installing and using packages and loading data.

If you want to get started quickly, most of the recipes in this book require the ggplot2 and gcookbook packages to be installed on your computer. To do this, run:

```{r, eval=FALSE}
install.packages(c("ggplot2", "gcookbook"))
```

Then, in each R session, before running the examples in this book, you can load them with:

```{r, eval=FALSE}
library(ggplot2)
library(gcookbook)
```

> **Note**
>
> Chapter \@ref(CHAPTER-GGPLOT2) provides an introduction to the ggplot2 graphing package, for readers who are not already familiar with its use.

Packages in R are collections of functions and/or data that are bundled up for easy distribution, and installing a package will extend the functionality of R on your computer. If an R user creates a package and thinks that it might be useful for others, that user can distribute it through a package repository. The primary repository for distributing R packages is called CRAN (the Comprehensive R Archive Network), but there are others, such as Bioconductor and Omegahat.

Installing a Package
--------------------

### Problem

You want to install a package from CRAN.

### Solution

Use `install.packages()` and give it the name of the package you want to install. To install ggplot2, run:

```{r, eval=FALSE}
install.packages("ggplot2")
```

At this point you may be prompted to select a download mirror. It's usually best to use the first choice, https://cloud.r-project.org/, as it is a cloud-based mirror with endpoints all over the world.

### Discussion

When you tell R to install a package, it will automatically install any other packages that the first package depends on.

CRAN (the Comprehensive R Archive Network) is a repository of packages for R, and it is mirrored on many servers around the world. It is the default repository system used by R. There are other package repositories; Bioconductor, for example, is a repository of packages related to analyzing genomic data.

Loading a Package
-----------------

### Problem

You want to load an installed package.

### Solution

Use `library()` and give it the name of the package you want to install. To load ggplot2, run:

```{r, eval=FALSE}
library(ggplot2)
```

The package must already be installed on the computer.

### Discussion

Most of the recipes in this book require loading a package before running the code, either for the graphing capabilities (as in the ggplot2 package) or for example data sets (as in the MASS and gcookbook packages).

One of R's quirks is the package/library terminology. Although you use the `library()` function to load a package, a package is not a library, and some longtime R users will get irate if you call it that.

A *library* is a directory that contains a set of packages. You might, for example, have a system-wide library as well as a library for each user.

Loading a Delimited Text Data File
----------------------------------

### Problem

You want to load data from a delimited text file.

### Solution

The most common way to read in a file is to use comma-separated values (CSV) data:

```{r, eval=FALSE}
data <- read.csv("datafile.csv")
```

### Discussion

Since data files have many different formats, there are many options for loading them. For example, if the data file does *not* have headers in the first row:

```{r, eval=FALSE}
data <- read.csv("datafile.csv", header = FALSE)
```

The resulting data frame will have columns named `V1`, `V2`, and so on, and you will probably want to rename them manually:

```{r, eval=FALSE}
# Manually assign the header names
names(data) <- c("Column1", "Column2", "Column3")
```

You can set the delimiter with sep. If it is space-delimited, use `sep = " "`. If it is tab-delimited, use `\t`, as in:

```{r, eval=FALSE}
data <- read.csv("datafile.csv", sep = "\t")
```

By default, strings in the data are treated as factors. Suppose this is your data file, and you read it in using `read.csv()`:

```
"First","Last","Sex","Number"
"Currer","Bell","F",2
"Dr.","Seuss","M",49
"","Student",NA,21
```

The resulting data frame will store `First` and `Last` as *factors*, though it makes more sense in this case to treat them as strings (or *character vectors* in R terminology). To differentiate this, use `stringsAsFactors=FALSE`. If there are any columns that should be treated as factors, you can then convert them individually:

```{r, eval=FALSE}
data <- read.csv("datafile.csv", stringsAsFactors = FALSE)
# Convert to factor
data$Sex <- factor(data$Sex)
str(data)
#> 'data.frame': 3 obs. of 4 variables:
#> $ First : chr "Currer" "Dr." ""
#> $ Last : chr "Bell" "Seuss" "Student"
#> $ Sex : Factor w/ 2 levels "F","M": 1 2 NA
#> $ Number: int 2 49 21
```

**TODO: Fix text output formatting**

Alternatively, you could load the file with strings as factors, and then convert individual columns from factors to characters.

### See Also

`read.csv()` is a convenience wrapper function around `read.table()`. If you need more control over the input, see `?read.table`.


Loading Data from an Excel File
-------------------------------

### Problem

You want to load data from an Excel file.

### Solution

The readxl package has the function `read_excel()` for reading .xls and .xlsx files from Excel. This will read the first sheet of an Excel spreadsheet:

```{r, eval=FALSE}
# Only need to install once
install.packages("readxl")

library(readxl)
data <- read_excel("datafile.xlsx", 1)
```

### Discussion

With `read_excel()`, you can load from other sheets by specifying a number for sheetIndex or a name for sheetName:

```{r, eval=FALSE}
data <- read_excel("datafile.xls", sheet = 2)

data <- read_excel("datafile.xls", sheet = "Revenues")
```

`read_excel()` uses the first row of the spreadsheet for column names. If you don't want to use that row for column names, use `col_names = FALSE`. The columns will instead be named `X1`, `X2`, and so on.

By default, `read_excel()` will infer the type of each column, but if you want to specify the type of each column, you can use the `col_types` argument. You can also drop columns if you specify the type as `"blank"`.

```{r, eval=FALSE}
# Drop the first column, and specify the types of the next three columns
data <- read_excel("datafile.xls", col_types = c("blank", "text", "date", "numeric"))
```


### See Also

See `?read_excel` for more options controlling the reading of these files.

There are other packages for reading Excel files. The gdata package has a function `read.xls()` for reading in .xls files, and the xlsx package has a function `read.xlsx()` for reading in .xlsx files. They require external software to be installed on your computer: `read.xls()` requires Java, and `read.xlsx()` requires Perl.


Loading Data from SPSS/SAS/Stata Files
--------------------------------------

### Problem

You want to load data from a SPSS file, or from other programs like SAS or Stata.

### Solution

The haven package has the function `read_sav()` for reading SPSS files. To load data from an SPSS file:

```{r, eval=FALSE}
# Only need to install the first time
install.packages("haven")

library(foreign)
data <- read_sav("datafile.sav")
```

### Discussion


The haven package also includes functions to read from other formats:

* `read_sas()`: SAS
* `read_dta()`: Stata


An alternative to haven is the foreign package. It also supports SPSS and Stata files, but it is not as up-to-date as the functions from haven. For example, it only supports Stata files up to version 12, while haven supports up to version 14 (the current version as of this writing).

The foreign package does support some other formats, including:

* `read.octave()`: Octave and MATLAB
* `read.systat()`:SYSTAT
* `read.xport()`: SAS XPORT
* `read.dta()`: Stata
* `read.spss()`: SPSS

### See Also

Run `ls("package:foreign")` for a full list of functions in the foreign package.

<!--chapter:end:ch01.Rmd-->

---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---


```{r echo = FALSE, cache = FALSE}
# This block needs cache=FALSE to set fig.width and fig.height, and have those
# persist across cached builds.

source("utils.R", local = TRUE)
knitr::opts_chunk$set(fig.width=5, fig.height=4, out.width="50%")
```

Quickly Exploring Data {#CHAPTER-QUICK}
======================

Although I've used the ggplot2 package for most of the graphics in this book, it is not the only way to plot data. For very quick exploration of data, it's sometimes useful to use the plotting functions in base R. These are installed by default with R and do not require any additional packages to be installed. They're quick to type, straightforward to use in simple cases, and run very quickly.

If you want to do anything beyond very simple plots, though, it's generally better to switch to ggplot2. This is in part because ggplot2 provides a unified interface and set of options, instead of the grab bag of modifiers and special cases required in base graphics. Once you learn how ggplot2 works, you can use that knowledge for everything from scatter plots and histograms to violin plots and maps.

Each recipe in this section shows how to make a graph with base graphics. Each recipe also shows how to make a similar graph with the `ggplot()` function in ggplot2. The previous edition of this book also gave examples using the `qplot()` function from the ggplot2 package, but now it is recommended to just use `ggplot()` instead.

If you already know how to use R's base graphics, having these examples side by side will help you transition to using ggplot2 for when you want to make more sophisticated graphics.

Creating a Scatter Plot {#RECIPE-QUICK-SCATTER}
-----------------------

### Problem

You want to create a scatter plot.

### Solution

To make a scatter plot (Figure \@ref(fig:FIG-QUICK-SCATTER-BASE)), use `plot()` and pass it a vector of *x* values followed by a vector of *y* values:

```{r FIG-QUICK-SCATTER-BASE, small.mar=TRUE, fig.cap='Scatter plot with base graphics', out.width="70%"}
plot(mtcars$wt, mtcars$mpg)
```

The `mtcars$wt` returns the column named `wt` from the `mtcars` data frame, and `mtcars$mpg` is the `mpg` column.

With ggplot2, you can get a similar result using the `ggplot()` function (Figure Figure \@ref(fig:FIG-QUICK-SCATTER-GGPLOT)):

```{r FIG-QUICK-SCATTER-GGPLOT, fig.cap='Scatter plot with ggplot2', out.width="70%"}
library(ggplot2)
ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
```

The first part, `ggplot()`, tell is to create a plot object, and the second part, `geom_point()`, tells it to add a layer of points to the plot.

The usual way to use `ggplot()` is to pass it a data frame (`mtcars`) and then tell it which columns to use for the x and y values. If you want to pass it two vectors for x and y values, you can use `data=NULL`, and then pass it the vectors. Keep in mind that ggplot2 is designed to work with data frames as the data source, not individual vectors, and that using it this way will only allow you to use a limited part of its capabilities.

```{r, eval=FALSE}
ggplot(data = NULL, aes(x = mtcars$wt, y = mtcars$mpg)) + geom_point()
```

It is common to see `ggplot()` commands spread across multiple lines, so you may see the above code also written like this:

### See Also

See Chapter \@ref(CHAPTER-SCATTER) for more in-depth information about creating scatter plots.


Creating a Line Graph {#RECIPE-QUICK-LINE}
---------------------

### Problem

You want to create a line graph.

### Solution

To make a line graph using `plot()` (Figure \@ref(fig:FIG-QUICK-LINE-BASE), left), pass it a vector of x values and a vector of y values, and use `type="l"`:

```{r eval=FALSE}
plot(pressure$temperature, pressure$pressure, type = "l")
```

```{r FIG-QUICK-LINE-BASE, echo=FALSE, small.mar=TRUE, fig.show="hold", fig.cap="Left: line graph with base graphics; right: with points and another line"}
plot(pressure$temperature, pressure$pressure, type="l")

# This code should be the same as the following block, but there's a problem: 
# knitr won't show the output of the previous plot() if this line is exactly 
# like the one above So in this case we'll plot points and then lines. The 
# output looks the same and knitr won't suppress the output.
plot(pressure$temperature, pressure$pressure, type = "p")
lines(pressure$temperature, pressure$pressure)
lines(pressure$temperature, pressure$pressure/2, col = "red")
points(pressure$temperature, pressure$pressure/2, col = "red")
```

To add points and/or multiple lines (Figure \@ref(fig:FIG-QUICK-LINE-BASE), right), first call `plot()` for the first line, then add points with `points()` and additional lines with `lines()`:

```{r eval=FALSE}
plot(pressure$temperature, pressure$pressure, type = "l")
points(pressure$temperature, pressure$pressure)

lines(pressure$temperature, pressure$pressure/2, col = "red")
points(pressure$temperature, pressure$pressure/2, col = "red")
```

With ggplot2, you can get a similar result using `geom_line()` (Figure \@ref(fig:FIG-QUICK-LINE-GGPLOT)):

```{r eval=FALSE}
library(ggplot2)
ggplot(pressure, aes(x = temperature, y = pressure)) + geom_line()
```

```{r FIG-QUICK-LINE-GGPLOT, echo=FALSE, fig.show="hold", fig.cap="Left: line graph with `ggplot()`; right: with points added"}

ggplot(pressure, aes(x = temperature, y = pressure)) + geom_line()

# Equivalent to:
ggplot(pressure, aes(x=temperature, y=pressure)) + geom_line() + geom_point()
```

As with scatter plots, you can pass you data in vectors instead of in a data frame (but this will limit the things you can do later with the plot):

```{r eval=FALSE}
ggplot(pressure, aes(x=temperature, y=pressure)) +
    geom_line() +
    geom_point()
```

> **Note**
>
> It's common with `ggplot()` to split the command on multiple lines, ending each line with a `+` so that R knows that the command will continue on the next line.

### See Also

See Chapter \@ref(CHAPTER-LINE-GRAPH) for more in-depth information about creating line graphs.


Creating a Bar Graph {#RECIPE-QUICK-BAR}
--------------------

### Problem

You want to make a bar graph.

### Solution

To make a bar graph of values (Figure \@ref(fig:FIG-QUICK-BAR-BASE), left), use `barplot()` and pass it a vector of values for the height of each bar and (optionally) a vector of labels for each bar. If the vector has names for the elements, the names will automatically be used as labels:

```{r}
# First, take a look at the BOD data
BOD
```

```{r eval=FALSE}
barplot(BOD$demand, names.arg = BOD$Time)
```


```{r FIG-QUICK-BAR-BASE, echo=FALSE, small.mar=TRUE, fig.show="hold", fig.cap="Left: bar graph of values with base graphics; right: bar graph of counts"}
barplot(BOD$demand, names.arg=BOD$Time)

barplot(table(mtcars$cyl))
```

Sometimes "bar graph" refers to a graph where the bars represent the *count* of cases in each category. This is similar to a histogram, but with a discrete instead of continuous x-axis. To generate the count of each unique value in a vector, use the `table()` function:

````{r}
# There are 11 cases of the value 4, 7 cases of 6, and 14 cases of 8
table(mtcars$cyl)
```

Then pass the table to `barplot()` to generate the graph of counts:

```{r eval=FALSE}
# Generate a table of counts
barplot(table(mtcars$cyl))
```

With ggplot2, you can get a similar result using `geom_bar()` (Figure \@ref(fig:FIG-QUICK-BAR-GGPLOT)). To plot a bar graph of *values*, use `geom_col()`. Notice the difference in the output when the *x* variable is continuous and when it is discrete:

(ref:cap-FIG-QUICK-BAR-GGPLOT) Left: bar graph of values using `geom_col()` with a continuous x variable; right: with x variable converted to a factor (notice that there is no entry for 6)

```{r FIG-QUICK-BAR-GGPLOT, fig.show="hold", fig.cap="(ref:cap-FIG-QUICK-BAR-GGPLOT)"}
library(ggplot2)

# Bar graph of values. This uses the BOD data frame, with the
# "Time" column for x values and the "demand" column for y values.
ggplot(BOD, aes(x = Time, y = demand)) + geom_col()

# Convert the x variable to a factor, so that it is treated as discrete
ggplot(BOD, aes(x = factor(Time), y = demand)) + geom_col()
```

ggplot2 can also be used to plot the *count* of the number of data rows in each category (Figure \@ref(fig:FIG-QUICK-BAR-GGPLOT-COUNT)). Once again, notice the difference between a continuous x-axis and a discrete one. For some kinds of data, it may make more sense to convert the continuous x variable to a discrete one, with the `factor()` function.

(ref:cap-FIG-QUICK-BAR-GGPLOT-COUNT) Left: bar graph of counts using `geom_bar()` with a continuous x variable; right: with x variable converted to a factor

```{r FIG-QUICK-BAR-GGPLOT-COUNT, fig.show="hold", fig.cap="(ref:cap-FIG-QUICK-BAR-GGPLOT-COUNT)"}
# Bar graph of counts This uses the mtcars data frame, with the "cyl" column for
# x position. The y position is calculated by counting the number of rows for
# each value of cyl.
ggplot(mtcars, aes(x = cyl)) + geom_bar()

# Bar graph of counts
ggplot(mtcars, aes(x = factor(cyl))) + geom_bar()
```

> **Note**
>
> In previous versions of ggplot2, the recommended way to create a bar graph of values was to use `geom_bar(stat="identity")`. As of ggplot2 2.2.0, there is a `geom_col()` function which does the same thing.

### See Also

See Chapter \@ref(CHAPTER-BAR-GRAPH) for more in-depth information about creating bar graphs.


Creating a Histogram {#RECIPE-QUICK-HISTOGRAM}
--------------------

### Problem

You want to view the distribution of one-dimensional data with a histogram.

### Solution

To make a histogram (Figure \@ref(fig:FIG-QUICK-HIST-BASE)), use `hist()` and pass it a vector of values:

```{r FIG-QUICK-HIST-BASE, small.mar=TRUE, fig.show="hold", fig.cap="Left: histogram with base graphics; right: with more bins. Notice that because the bins are narrower, there are fewer items in each bin."}
hist(mtcars$mpg)

# Specify approximate number of bins with breaks
hist(mtcars$mpg, breaks = 10)
```

With the ggplot2, you can get a similar result using `geom_histogram()` (Figure \@ref(fig:FIG-QUICK-HIST-GGPLOT)):

```{r FIG-QUICK-HIST-GGPLOT, fig.show="hold", fig.cap="Left: ggplot2 histogram with default bin width; right: with wider bins"}
library(ggplot2)
ggplot(mtcars, aes(x = mpg)) + geom_histogram()

# With wider bins
ggplot(mtcars, aes(x = mpg)) + geom_histogram(binwidth = 4)
```

When you create a histogram without specifying the bin width, `ggplot()` prints out a message telling you that it's defaulting to 30 bins, and to pick a better bin width. This is because it's important to explore your data using different bin widths; the default of 30 may or may not show you something useful about your data.

### See Also

For more in-depth information about creating histograms, see Recipes
Recipe \@ref(RECIPE-DISTRIBUTION-BASIC-HIST) and
Recipe \@ref(RECIPE-DISTRIBUTION-MULTI-HIST).


Creating a Box Plot {#RECIPE-QUICK-BOXPLOT}
-------------------

### Problem

You want to create a box plot for comparing distributions.

### Solution

To make a box plot (Figure \@ref(fig:FIG-QUICK-BOXPLOT-BASE)), use `plot()` and pass it a factor of x values and a vector of y values.  When x is a factor (as opposed to a numeric vector), it will automatically create a box plot:

```{r eval=FALSE}
plot(ToothGrowth$supp, ToothGrowth$len)
```

```{r FIG-QUICK-BOXPLOT-BASE, echo=FALSE, small.mar=TRUE, fig.show="hold", fig.cap="Left: box plot with base graphics; right: with multiple grouping variables", fig.width=10, out.width="100%"}
layout(t(c(1,2,2)))
plot(ToothGrowth$supp, ToothGrowth$len)

boxplot(len ~ supp + dose, data = ToothGrowth)
```


If the two vectors are in the same data frame, you can also use the `boxplot()` function with formula syntax. With this syntax, you can combine two variables on the x-axis, as in Figure \@ref(fig:FIG-QUICK-BOXPLOT-BASE):

```{r eval=FALSE}
# Formula syntax
boxplot(len ~ supp, data = ToothGrowth)

# Put interaction of two variables on x-axis
boxplot(len ~ supp + dose, data = ToothGrowth)
```

With the ggplot2 package, you can get a similar result (Figure \@ref(fig:FIG-QUICK-BOXPLOT-GGPLOT)), with `geom_boxplot()`:

```{r eval=FALSE}
library(ggplot2)
ggplot(ToothGrowth, aes(x = supp, y = len)) + geom_boxplot()
```


```{r FIG-QUICK-BOXPLOT-GGPLOT, echo=FALSE, fig.show="hold", fig.cap="Left: box plot with `ggplot()`; right: with multiple grouping variables"}
ggplot(ToothGrowth, aes(supp, len)) + geom_boxplot()

ggplot(ToothGrowth, aes(x = interaction(supp, dose), y = len)) + geom_boxplot()
```

It's also possible to make box plots for multiple variables, by combining the variables with `interaction()`, as in Figure \@ref(fig:FIG-QUICK-BOXPLOT-GGPLOT):

```{r eval=FALSE}
ggplot(ToothGrowth, aes(x = interaction(supp, dose), y = len)) + geom_boxplot()
```

> **Note**
>
> You may have noticed that the box plots from base graphics are ever-so-slightly different from those from ggplot2. This is because they use slightly different methods for calculating quantiles. See `?geom_boxplot` and `?boxplot.stats` for more information on how they differ.

### See Also

For more on making basic box plots, see Recipe \@ref(RECIPE-DISTRIBUTION-BASIC-BOXPLOT).


Plotting a Function Curve {#RECIPE-QUICK-FUNCTION}
-------------------------

### Problem

You want to plot a function curve.

### Solution

To plot a function curve, as in Figure \@ref(fig:FIG-QUICK-FUNCTION-BASE), use `curve()` and pass it an expression with the variable x:

```{r eval=FALSE}
curve(x^3 - 5*x, from = -4, to = 4)
```


```{r FIG-QUICK-FUNCTION-BASE, echo=FALSE, small.mar=TRUE, fig.show="hold", fig.cap="Left: function curve with base graphics; right: with user-defined function"}
curve(x^3 - 5*x, from = -4, to = 4)


# Plot a user-defined function
myfun <- function(xvar) {
    1 / (1 + exp(-xvar + 10))
}
curve(myfun(x), from = 0, to = 20)
# Add a line:
curve(1 - myfun(x), add = TRUE, col = "red")
```


You can plot any function that takes a numeric vector as input and returns a numeric vector, including functions that you define yourself.  Using `add=TRUE` will add a curve to the previously created plot:

```{r eval=FALSE}
# Plot a user-defined function
myfun <- function(xvar) {
    1 / (1 + exp(-xvar + 10))
}
curve(myfun(x), from = 0, to = 20)
# Add a line:
curve(1 - myfun(x), add = TRUE, col = "red")
```

With ggplot2, you can get a similar result (Figure \@ref(fig:FIG-QUICK-FUNCTION-GGPLOT)), by using `stat_function(geom="line")` and passing it a function that takes a numeric vector as input and returns a numeric vector:

```{r FIG-QUICK-FUNCTION-GGPLOT, fig.cap="A function curve with ggplot2", out.width="70%"}
library(ggplot2)
# This sets the x range from 0 to 20
ggplot(data.frame(x = c(0, 20)), aes(x = x)) +
  stat_function(fun = myfun, geom = "line")
```


### See Also

See Recipe \@ref(RECIPE-MISCGRAPH-FUNCTION) for more in-depth information about plotting function curves.

<!--chapter:end:ch02.Rmd-->

---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
source("utils.R", local = TRUE)
```


Bar Graphs {#CHAPTER-BAR-GRAPH}
==========

Bar graphs are perhaps the most commonly used kind of data visualization. They're typically used to display numeric values (on the y-axis), for different categories (on the x-axis). For example, a bar graph would be good for showing the prices of four different kinds of items. A bar graph generally wouldn't be as good for showing prices over time, where time is a continuous variable -- though it can be done, as we'll see in this chapter.

There's an important distinction you should be aware of when making bar graphs: sometimes the bar heights represent *counts* of cases in the data set, and sometimes they represent *values* in the data set. Keep this distinction in mind -- it can be a source of confusion since they have very different relationships to the data, but the same term is used for both of them. In this chapter I'll discuss this more, and present recipes for both types of bar graphs.

From this chapter on, this book will focus on using ggplot2 instead of base R graphics. Using ggplot2 will both keep things simpler and make for more sophisticated graphics.


Making a Basic Bar Graph {#RECIPE-BAR-GRAPH-BASIC-BAR}
------------------------

### Problem

You have a data frame where one column represents the *x* position of each bar, and another column represents the vertical (y) height of each bar.

### Solution

Use `ggplot()` with `geom_col()` and specify what variables you want on the x- and y-axes (Figure \@ref(fig:FIG-BAR-GRAPH-BASIC-BAR)):

```{r FIG-BAR-GRAPH-BASIC-BAR, fig.cap='Bar graph of values with a discrete x-axis'}
library(gcookbook) # For the data set
ggplot(pg_mean, aes(x = group, y = weight)) + geom_col()
```

> **Note**
>
> In previous versions of ggplot2, the recommended way to create a bar graph of values was to use `geom_bar(stat="identity")`. As of ggplot2 2.2.0, there is a `geom_col()` function which does the same thing.


### Discussion

When x is a continuous (or numeric) variable, the bars behave a little differently. Instead of having one bar at each actual x value, there is one bar at each possible x value between the minimum and the maximum, as in Figure \@ref(fig:FIG-BAR-GRAPH-BASIC-BAR-CONT). You can convert the continuous variable to a discrete variable by using `factor()`.

```{r FIG-BAR-GRAPH-BASIC-BAR-CONT, fig.show="hold", fig.cap='Left: bar graph of values with a continuous x-axis; right: with x variable converted to a factor (notice that the space for 6 is gone)', fig.width=3.5, fig.height=3.5}
# There's no entry for Time == 6
BOD

# Time is numeric (continuous)
str(BOD)

ggplot(BOD, aes(x = Time, y = demand)) + geom_col()

# Convert Time to a discrete (categorical) variable with factor()
ggplot(BOD, aes(x = factor(Time), y = demand)) + geom_col()
```

Notice that there was no row in `BOD` for `Time` = 6. When the x variable is continuous, ggplot2 will use a numeric axis which will have space for all numeric values within the range -- hence the empty space for 6 in the plot. When `Time` is converted to a factor, ggplot2 uses it as a discrete variable, where the values are treated as arbitrary labels instead of numeric values, and so it won't allocate space on the x axis for all possible numeric values between the minimum and maximum.

In these examples, the data has a column for x values and another for y values. If you instead want the height of the bars to represent the *count* of cases in each group, see
Recipe \@ref(RECIPE-BAR-GRAPH-COUNTS).

By default, bar graphs use a dark grey for the bars. To use a color fill, use `fill`. Also, by default, there is no outline around the fill. To add an outline, use `colour`. For
Figure \@ref(fig:FIG-BAR-GRAPH-BASIC-BAR-SINGLE-FILL), we use a light
blue fill and a black outline:

```{r FIG-BAR-GRAPH-BASIC-BAR-SINGLE-FILL, fig.cap="A single fill and outline color for all bars"}
ggplot(pg_mean, aes(x = group, y = weight)) +
    geom_col(, fill = "lightblue", colour = "black")
```

> **Note**
>
> In ggplot2, the default is to use the British spelling, colour, instead of the American spelling, color. Internally, American spellings are remapped to the British ones, so if you use the American spelling it will still work.

### See Also

If you want the height of the bars to represent the count of cases in each group, see Recipe \@ref(RECIPE-BAR-GRAPH-COUNTS).

To reorder the levels of a factor based on the values of another variable, see Recipe \@ref(RECIPE-DATAPREP-FACTOR-REORDER-VALUE). To manually change the order of factor levels, see
Recipe \@ref(RECIPE-DATAPREP-FACTOR-REORDER).

For more information about using colors, see Chapter \@ref(CHAPTER-COLORS).


Grouping Bars Together {#RECIPE-BAR-GRAPH-GROUPED-BAR}
----------------------

### Problem

You want to group bars together by a second variable.

### Solution

Map a variable to fill, and use `geom_col(position="dodge")`.

In this example we'll use the `cabbage_exp` data set, which has two categorical variables, `Cultivar` and `Date`, and one continuous variable, `Weight`:

```{r}
library(gcookbook) # For the data set
cabbage_exp
```

We'll map `Date` to the *x* position and map `Cultivar` to the fill color (Figure \@ref(fig:FIG-BAR-GRAPH-GROUPED-BAR)):

```{r FIG-BAR-GRAPH-GROUPED-BAR, fig.cap="Graph with grouped bars"}
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(position = "dodge")
```

### Discussion

The most basic bar graphs have one categorical variable on the x-axis and one continuous variable on the y-axis. Sometimes you'll want to use another categorical variable to divide up the data, in addition to the variable on the x-axis. You can produce a grouped bar plot by mapping that variable to fill, which represents the fill color of the bars. You must also use `position="dodge"`, which tells the bars to "dodge" each other horizontally; if you don't, you'll end up with a stacked bar plot (Recipe \@ref(RECIPE-BAR-GRAPH-STACKED-BAR)).

As with variables mapped to the x-axis of a bar graph, variables that are mapped to the fill color of bars must be categorical rather than continuous variables.

To add a black outline, use `colour="black"` inside `geom_col()`. To set the colors, you can use `scale_fill_brewer()` or `scale_fill_manual()`. In Figure \@ref(fig:FIG-BAR-GRAPH-GROUPED-BAR-OUTLINE) we'll use the `Pastel1` palette from `RColorBrewer`:

```{r FIG-BAR-GRAPH-GROUPED-BAR-OUTLINE, fig.cap="Grouped bars with black outline and a different color palette"}
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(position = "dodge", colour = "black") +
    scale_fill_brewer(palette = "Pastel1")
```

Other aesthetics, such as `colour` (the color of the outlines of the bars) or `linestyle`, can also be used for grouping variables, but `fill` is probably what you'll want to use.

Note that if there are any missing combinations of the categorical variables, that bar will be missing, and the neighboring bars will expand to fill that space. If we remove the last row from our example data frame, we get Figure \@ref(fig:FIG-BAR-GRAPH-GROUPED-BAR-MISSING):

```{r FIG-BAR-GRAPH-GROUPED-BAR-MISSING, fig.cap="Graph with a missing bar-the other bar fills the space"}
ce <- cabbage_exp[1:5, ]
ce

ggplot(ce, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(position = "dodge", colour = "black") +
    scale_fill_brewer(palette = "Pastel1")
```


If your data has this issue, you can manually make an entry for the missing factor level combination with an `NA` for the *y* variable.

### See Also

For more on using colors in bar graphs, see Recipe \@ref(RECIPE-BAR-GRAPH-COLORS).

To reorder the levels of a factor based on the values of another variable, see Recipe \@ref(RECIPE-DATAPREP-FACTOR-REORDER-VALUE).


Making a Bar Graph of Counts {#RECIPE-BAR-GRAPH-COUNTS}
----------------------------

### Problem

Your data has one row representing each case, and you want plot counts of the cases.

### Solution

Use `geom_bar()` without mapping anything to `y` (Figure \@ref(fig:FIG-BAR-GRAPH-COUNT)):

```{r FIG-BAR-GRAPH-COUNT, fig.cap="Bar graph of counts"}
ggplot(diamonds, aes(x = cut)) + geom_bar()
# Equivalent to using geom_bar(stat = "bin")
```

### Discussion

The `diamonds` data set has 53,940 rows, each of which represents information about a single diamond:

```{r}
diamonds
```

With `geom_bar()`, the default behavior is to use `stat="bin"`, which counts up the number of cases for each group (each *x* position, in this example). In the graph we can see that there are about 23,000 cases with an `ideal` cut.

In this example, the variable on the x-axis is discrete. If we use a continuous variable on the x-axis, we'll get a bar at each unique *x* value in the data, as shown in Figure \@ref(fig:FIG-BAR-GRAPH-COUNT-CONTINUOUS):

```{r FIG-BAR-GRAPH-COUNT-CONTINUOUS, echo=FALSE, fig.show="hold", fig.cap='Left: bar graph of counts on a continuous axis; right: a histogram', fig.width=3.5, fig.height=3.5}
# Bar graph of counts
ggplot(diamonds, aes(x = carat)) + geom_bar()

# Histogram
ggplot(diamonds, aes(x = carat)) + geom_histogram()
```

The bar graph with a continuous x-axis is similar to a histogram, but not the same. A histogram is shown on the right side of Figure \@ref(fig:FIG-BAR-GRAPH-COUNT-CONTINUOUS). In this kind of bar graph, each bar represents a unique *x* value, whereas in a histogram, each bar represents a *range* of *x* values.


### See Also

If, instead of having `ggplot()` count up the number of rows in each group, you have a column in your data frame representing the y values, use `geom_col()`. See Recipe \@ref(RECIPE-BAR-GRAPH-BASIC-BAR).

You could also get the same graphical output by calculating the counts before sending the data to `ggplot()`. See Recipe \@ref(RECIPE-DATAPREP-SUMMARIZE) for more on summarizing data.

For more about histograms, see Recipe \@ref(RECIPE-DISTRIBUTION-BASIC-HIST).


Using Colors in a Bar Graph {#RECIPE-BAR-GRAPH-COLORS}
---------------------------

### Problem

You want to use different colors for the bars in your graph.

### Solution

Map the appropriate variable to the fill aesthetic.

We'll use the `uspopchange` data set for this example. It contains the percentage change in population for the US states from 2000 to 2010. We'll take the top 10 fastest-growing states and graph their percentage change. We'll also color the bars by region (Northeast, South, North Central, or West).

First, take the top 10 states:

```{r}
library(gcookbook) # For the data set
upc <- subset(uspopchange, rank(Change) > 40)
upc
```

Now we can make the graph, mapping Region to fill
(Figure \@ref(fig:FIG-BAR-GRAPH-FILL)):

```{r FIG-BAR-GRAPH-FILL, fig.cap="A variable mapped to fill"}
ggplot(upc, aes(x = Abb, y = Change, fill = Region)) +
    geom_col()
```


### Discussion

The default colors aren't the most appealing, so you may want to set them using `scale_fill_brewer()` or `scale_fill_manual()`. With this example, we'll use the latter, and we'll set the outline color of the bars to black, with `colour="black"` (Figure \@ref(fig:FIG-BAR-GRAPH-FILL-MANUAL)). Note that *setting* occurs outside of `aes()`, while *mapping* occurs within `aes()`:

```{r FIG-BAR-GRAPH-FILL-MANUAL, fig.cap="Graph with different colors, black outlines, and sorted by percentage change"}
ggplot(upc, aes(x = reorder(Abb, Change), y = Change, fill = Region)) +
    geom_col(colour = "black") +
    scale_fill_manual(values = c("#669933", "#FFCC66")) +
    xlab("State")
```

This example also uses the `reorder()` function to reorder the levels of the factor `Abb` based on the values of `Change`. In this particular case it makes sense to sort the bars by their height, instead of in alphabetical order.

### See Also

For more about using `reorder()`, see Recipe \@ref(RECIPE-DATAPREP-FACTOR-REORDER-VALUE).

For more information about using colors, see Chapter \@ref(CHAPTER-COLORS).


Coloring Negative and Positive Bars Differently {#RECIPE-BAR-GRAPH-COLOR-NEG}
-----------------------------------------------

### Problem

You want to use different colors for negative and positive-valued bars.

### Solution

We'll use a subset of the climate data and create a new column called pos, which indicates whether the value is positive or negative:


```{r}
library(gcookbook) # For the data set
csub <- subset(climate, Source == "Berkeley" & Year >= 1900)
csub$pos <- csub$Anomaly10y >= 0

csub
```

Once we have the data, we can make the graph and map pos to the fill color, as in Figure \@ref(fig:FIG-BAR-GRAPH-COLOR-NEG). Notice that we use position="identity" with the bars. This will prevent a warning message about stacking not being well defined for negative numbers:

```{r FIG-BAR-GRAPH-COLOR-NEG, fig.cap="Different colors for positive and negative values", fig.width=8, out.width="100%"}
ggplot(csub, aes(x = Year, y = Anomaly10y, fill = pos)) +
  geom_col(position = "identity")
```

### Discussion

There are a few problems with the first attempt. First, the colors are probably the reverse of what we want: usually, blue means cold and red means hot. Second, the legend is redundant and distracting.

We can change the colors with `scale_fill_manual()` and remove the legend with `guide=FALSE`, as shown in Figure \@ref(fig:FIG-BAR-GRAPH-COLOR-NEG2). We'll also add a thin black outline around each of the bars by setting `colour` and specifying `size`, which is the thickness of the outline (in millimeters):

```{r FIG-BAR-GRAPH-COLOR-NEG2, fig.cap="Graph with customized colors and no legend", fig.width=8, out.width="100%"}
ggplot(csub, aes(x = Year, y = Anomaly10y, fill = pos)) +
    geom_col(position = "identity", colour = "black", size = 0.25) +
    scale_fill_manual(values = c("#CCEEFF", "#FFDDDD"), guide = FALSE)
```

### See Also

To change the colors used, see Recipes Recipe \@ref(RECIPE-COLORS-PALETTE-DISCRETE) and Recipe \@ref(RECIPE-COLORS-PALETTE-DISCRETE-MANUAL).

To hide the legend, see Recipe \@ref(RECIPE-LEGEND-REMOVE).


Adjusting Bar Width and Spacing {#RECIPE-BAR-GRAPH-ADJUST-WIDTH}
-------------------------------

### Problem

You want to adjust the width of bars and the spacing between them.

### Solution

To make the bars narrower or wider, set `width` in `geom_bar()`. The default value is 0.9; larger values make the bars wider, and smaller values make the bars narrower (Figure \@ref(fig:FIG-BAR-WIDTH)).

For example, for standard-width bars:

```{r eval=FALSE}
library(gcookbook) # For the data set

ggplot(pg_mean, aes(x = group, y = weight)) +
    geom_col()
```

For narrower bars:

```{r eval=FALSE}
ggplot(pg_mean, aes(x = group, y = weight)) +
    geom_col(width = 0.5)
```

And for wider bars (these have the maximum width of 1):

```{r eval=FALSE}
ggplot(pg_mean, aes(x = group, y = weight)) +
    geom_col(width = 1)
```

```{r FIG-BAR-WIDTH, echo=FALSE, fig.show="hold", fig.cap="Different bar widths"}
ggplot(pg_mean, aes(x = group, y = weight)) +
    geom_col()
ggplot(pg_mean, aes(x = group, y = weight)) +
    geom_col(width = 0.5)
ggplot(pg_mean, aes(x = group, y = weight)) +
    geom_col(width = 1)
```

For grouped bars, the default is to have no space between bars within each group. To add space between bars within a group, make width smaller and set the value for `position_dodge` to be larger than `width` (Figure \@ref(fig:FIG-BAR-WIDTH-DODGE)).

For a grouped bar graph with narrow bars:

```{r eval=FALSE}
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(width = 0.5, position = "dodge")
```

And with some space between the bars:

```{r eval=FALSE}
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(width = 0.5, position = position_dodge(0.7))
```


```{r FIG-BAR-WIDTH-DODGE, echo=FALSE, fig.show="hold", fig.cap="Left: bar graph with narrow grouped bars; right: with space between the bars"}
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(width = 0.5, position = "dodge")
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(width = 0.5, position = position_dodge(0.7))
```

The first graph used `position="dodge"`, and the second graph used `position=position_dodge()`. This is because `position="dodge"` is simply shorthand for `position=position_dodge()` with the default value of 0.9, but when we want to set a specific value, we need to use the more verbose form.

### Discussion

The default `width` for bars is 0.9, and the default value used for `position_dodge()` is the same. To be more precise, the value of `width` in `position_dodge()` is `NULL`, which tells ggplot2 to use the same value as the width from `geom_bar()`.

All of these will have the same result:

```{r eval=FALSE}
geom_bar(position = "dodge")
geom_bar(width = 0.9, position = position_dodge())
geom_bar(position = position_dodge(0.9))
geom_bar(width = 0.9, position = position_dodge(width=0.9))
```

The items on the x-axis have x values of 1, 2, 3, and so on, though you typically don't refer to them by these numerical values. When you use `geom_bar(width=0.9)`, it makes each group take up a total width of 0.9 on the x-axis. When you use `position_dodge(width=0.9)`, it spaces the bars so that the *middle* of each bar is right where it would be if the bar width were 0.9 and the bars were touching. This is illustrated in Figure \@ref(fig:FIG-BAR-WIDTH-DODGE-EXPLANATION). The two graphs both have the same dodge width of 0.9, but while the top has a bar width of 0.9, the bottom has a bar width of 0.2. Despite the different bar widths, the middles of the bars stay aligned.

```{r FIG-BAR-WIDTH-DODGE-EXPLANATION, echo=FALSE, fig.show="hold", fig.cap="Same dodge width of 0.9, but different bar widths of 0.9 (top) and 0.2 (bottom)", fig.height=3.5}
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(position = "dodge")

ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(width = 0.2, position = position_dodge(width=0.9))
```

If you make the entire graph wider or narrower, the bar dimensions will scale proportionally. To see how this works, you can just resize the window in which the graphs appear. For information about controlling this when writing to a file, see Chapter \@ref(CHAPTER-OUTPUT).


Making a Stacked Bar Graph {#RECIPE-BAR-GRAPH-STACKED-BAR}
--------------------------

### Problem

You want to make a stacked bar graph.

### Solution

Use `geom_bar()` and map a variable `fill`. This will put `Date` on the x-axis and use `Cultivar` for the fill color, as shown in Figure \@ref(fig:FIG-BAR-GRAPH-STACKED-BAR):

```{r FIG-BAR-GRAPH-STACKED-BAR, fig.cap="Stacked bar graph"}
library(gcookbook) # For the data set
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col()
```

### Discussion

To understand how the graph is made, it's useful to see how the data is structured. There are three levels of `Date` and two levels of `Cultivar`, and for each combination there is a value for `Weight`:


```{r}
cabbage_exp
```

By default, the stacking order of the bars is the same as the order of items in the legend. For some data sets it might make sense to reverse the order of the legend. To do this, you can use the `guides` function and specify which aesthetic for which the legend should be reversed. In this case, it's `fill`:

```{r FIG-BAR-GRAPH-STACKED-BAR-REVLEVELS, fig.cap="Stacked bar graph with reversed legend order"}
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col() +
    guides(fill = guide_legend(reverse = TRUE))
```

If you'd like to reverse the stacking order of the bars, as in Figure \@ref(fig:FIG-BAR-GRAPH-STACKED-BAR-REVSTACK), use `position_stack(reverse=TRUE)`. You'll also need to reverse the order of the legend for it to match the order of the bars:

```{r FIG-BAR-GRAPH-STACKED-BAR-REVSTACK, fig.cap="Stacked bar graph with reversed stacking order"}
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(position = position_stack(reverse = TRUE)) +
    guides(fill = guide_legend(reverse = TRUE))
```

It's also possible to modify the column of the data frame so that the factor levels are in a different order (see Recipe \@ref(RECIPE-DATAPREP-FACTOR-REORDER)). Do this with care, since the modified data could change the results of other analyses.

For a more polished graph, we'll use `scale_fill_brewer()` to get a different color palette, and use `colour="black"` to get a black outline (Figure \@ref(fig:FIG-BAR-GRAPH-STACKED-BAR-COLORS)):

```{r FIG-BAR-GRAPH-STACKED-BAR-COLORS, fig.cap="Stacked bar graph with reversed legend, new palette, and black outline"}
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(colour = "black") +
    scale_fill_brewer(palette = "Pastel1")
```

### See Also

For more on using colors in bar graphs, see Recipe \@ref(RECIPE-BAR-GRAPH-COLORS).

To reorder the levels of a factor based on the values of another variable, see Recipe \@ref(RECIPE-DATAPREP-FACTOR-REORDER-VALUE). To manually change the order of factor levels, see Recipe \@ref(RECIPE-DATAPREP-FACTOR-REORDER).


Making a Proportional Stacked Bar Graph {#RECIPE-BAR-GRAPH-PROPORTIONAL-STACKED-BAR}
---------------------------------------

### Problem

You want to make a stacked bar graph that shows proportions (also called a 100% stacked bar graph).

### Solution

Use `geom_col(position="fill")` (Figure \@ref(fig:FIG-BAR-GRAPH-PROP-STACKED-BAR)):

```{r FIG-BAR-GRAPH-PROP-STACKED-BAR, fig.cap="Proportional stacked bar graph"}
library(gcookbook) # For the data set

ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(position = "fill")
```


### Discussion

With `position="fill"`, the y values will be scaled to go from 0 to 1. To print the labels as percentages, use `scale_y_continuous(labels = scales::percent)`.

```{r}
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(position = "fill") +
    scale_y_continuous(labels = scales::percent)
```

> **Note**
>
> Using `scales::percent` is a way of using the `percent` function from the scales package. You could instead do `library(scales)` and then just use `scale_y_continuous(labels=percent)`. This would also make all of the functions from scales available in the current R session.

To make the output look a little nicer, you can change the color palette and add an outline. This is shown in (Figure \@ref(fig:FIG-BAR-GRAPH-PROP-STACKED-BAR-FINAL)):

```{r FIG-BAR-GRAPH-PROP-STACKED-BAR-FINAL, fig.cap="Proportional stacked bar graph with reversed legend, new palette, and black outline"}
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(colour = "black", position = "fill") +
    scale_y_continuous(labels = scales::percent) +
    scale_fill_brewer(palette = "Pastel1")
```


Instead of having ggplot2 compute the proportions automatically, you may want to compute the proportional values yourself. This can be useful if you want to use those values in other computations.

To do this, first scale the data to 100% within each stack. This can be done by using `group_by()` together with `mutate()` from the dplyr package.

```{r}
library(gcookbook)
library(dplyr)

cabbage_exp

# Do a group-wise transform(), splitting on "Date"
ce <- cabbage_exp %>%
    group_by(Date) %>%
    mutate(percent_weight = Weight / sum(Weight) * 100)

ce
```

To calculate the percentages within each `Weight` group, we used dplyr's `group_by()` and `mutate()` functions. In the example here, the `group_by()` function tells dplyr that future operations should operate on the data frame as though it were split up into groups, on the `Date` column. The `mutate()` function tells it to calculate a new column, dividing each row's `Weight` value by the sum of the `Weight` column *within each group*.

> **Note**
>
> You may have noticed that `cabbage_exp` and `ce` print out differently. This is because `cabbage_exp` is a regular data frame, while `ce` is a *tibble*, which is a data frame with some extra properties. The dplyr package creates tibbles. For more information, see Chapter \@ref(CHAPTER-DATAPREP).

After computing the new column, making the graph is the same as with a regular stacked bar graph.

```{r eval=FALSE}
ggplot(ce, aes(x = Date, y = percent_weight, fill = Cultivar)) +
    geom_col()
```

### See Also

For more on transforming data by groups, see Recipe \@ref(RECIPE-DATAPREP-CALCULATE-GROUP).


Adding Labels to a Bar Graph {#RECIPE-BAR-GRAPH-LABELS}
----------------------------

### Problem

You want to add labels to the bars in a bar graph.

### Solution

Add `geom_text()` to your graph. It requires a mapping for x, y, and the text itself. By setting `vjust` (the vertical justification), it is possible to move the text above or below the tops of the bars, as shown in Figure \@ref(fig:FIG-BAR-GRAPH-LABEL):

```{r FIG-BAR-GRAPH-LABEL, fig.show="hold", fig.cap="Left: labels under the tops of bars; right: labels above bars", fig.width=3.5, fig.height=3.5}
library(gcookbook) # For the data set

# Below the top
ggplot(cabbage_exp, aes(x = interaction(Date, Cultivar), y = Weight)) +
    geom_col() +
    geom_text(aes(label = Weight), vjust = 1.5, colour = "white")

# Above the top
ggplot(cabbage_exp, aes(x = interaction(Date, Cultivar), y = Weight)) +
    geom_col() +
    geom_text(aes(label = Weight), vjust = -0.2)
```

Notice that when the labels are placed atop the bars, they may be clipped. To remedy this, see Recipe \@ref(RECIPE-AXES-RANGE).


Another common scenario is to add labels for a bar graph of *counts* instead of values. To do this, use `geom_bar()`, which adds bars whose height is proportional to the number of rows, and then use `geom_text()` with counts:

```{r FIG-BAR-GRAPH-COUNT-LABEL, fig.cap="Bar graph of counts with labels under the tops of bars", fig.width=3.5, fig.height=3.5}
ggplot(mtcars, aes(x = factor(cyl))) +
    geom_bar() +
    geom_text(stat = "count", aes(label = ..count..), vjust = 1.5, colour = "white")
```

We needed to tell `geom_text()` to use the `"count"` statistic to compute the number of rows for each x value, and then, to use those computed counts as the labels, we told it to use the aesthetic mapping `aes(label = ..count..)`.


### Discussion

In Figure \@ref(fig:FIG-BAR-GRAPH-LABEL), the *y* coordinates of the labels are centered at the top of each bar; by setting the vertical justification (`vjust`), they appear below or above the bar tops. One drawback of this is that when the label is above the top of the bar, it can go off the top of the plotting area. To fix this, you can manually set the *y* limits, or you can set the *y* positions of the text *above* the bars and not change the vertical justification. One drawback to changing the text's *y* position is that if you want to place the text fully above or below the bar top, the value to add will depend on the *y* range of the data; in contrast, changing `vjust` to a different value will always move the text the same distance relative to the height of the bar:

```{r, eval=FALSE}
# Adjust y limits to be a little higher
ggplot(cabbage_exp, aes(x = interaction(Date, Cultivar), y = Weight)) +
    geom_col() +
    geom_text(aes(label = Weight), vjust = -0.2) +
    ylim(0, max(cabbage_exp$Weight) * 1.05)

# Map y positions slightly above bar top - y range of plot will auto-adjust
ggplot(cabbage_exp, aes(x = interaction(Date, Cultivar), y = Weight)) +
    geom_col() +
    geom_text(aes(y = Weight+0.1, label = Weight))
```

For grouped bar graphs, you also need to specify position=position_dodge() and give it a value for the dodging width. The default dodge width is 0.9. Because the bars are narrower, you might need to use size to specify a smaller font to make the labels fit. The default value of size is 5, so we'll make it smaller by using 3 (Figure \@ref(fig:FIG-BAR-LABEL-GROUPED)):

```{r FIG-BAR-LABEL-GROUPED, fig.cap="Labels on grouped bars"}
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(position = "dodge") +
    geom_text(aes(label = Weight), vjust = 1.5, colour = "white",
              position = position_dodge(.9), size = 3)
```

Putting labels on stacked bar graphs requires finding the cumulative sum for each stack. To do this, first make sure the data is sorted properly--if it isn't, the cumulative sum might be calculated in the wrong order. We'll use the `arrange()` function from the dplyr package. Note that we have to use the `rev()` function to reverse the order of `Cultivar`:

```{r}
library(dplyr)
# Sort by the Date and Cultivar columns
ce <- arrange(cabbage_exp, Date, rev(Cultivar))
```

Once we make sure the data is sorted properly, we'll use `group_by()` to chunk it into groups by `Date`, then calculate a cumulative sum of `Weight` within each chunk:

```{r FIG-BAR-LABEL-STACKED, fig.cap="Labels on stacked bars"}
# Get the cumulative sum
ce <- ce %>%
    group_by(Date) %>%
    mutate(label_y = cumsum(Weight))
ce

ggplot(ce, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col() +
    geom_text(aes(y = label_y, label = Weight), vjust = 1.5, colour = "white")
```

The result is shown in Figure \@ref(fig:FIG-BAR-LABEL-STACKED).

When using labels, changes to the stacking order are best done by modifying the order of levels in the factor (see Recipe \@ref(RECIPE-DATAPREP-FACTOR-REORDER)) before taking the cumulative sum. The other method of changing stacking order, by specifying breaks in a scale, won't work properly, because the order of the cumulative sum won't be the same as the stacking order.

To put the labels in the middle of each bar (Figure \@ref(fig:FIG-BAR-LABEL-STACKED-MIDDLE)), there must be an adjustment to the cumulative sum, and the *y* offset in `geom_bar()` can be removed:

```{r FIG-BAR-LABEL-STACKED-MIDDLE, fig.cap="Labels in the middle of stacked bars"}
ce <- arrange(cabbage_exp, Date, rev(Cultivar))

# Calculate y position, placing it in the middle
ce <- ce %>%
    group_by(Date) %>%
    mutate(label_y = cumsum(Weight) - 0.5 * Weight)

ggplot(ce, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col() +
    geom_text(aes(y = label_y, label = Weight), colour = "white")
```

For a more polished graph (Figure \@ref(fig:FIG-BAR-LABEL-STACKED-FINAL)), we'll change the colors, add labels in the middle with a smaller font using `size`, add a "kg" suffix using `paste`, and make sure there are always two digits after the decimal point by using `format()`:

```{r FIG-BAR-LABEL-STACKED-FINAL, fig.cap="Customized stacked bar graph with labels"}
ggplot(ce, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_col(colour = "black") +
    geom_text(aes(y = label_y, label = paste(format(Weight, nsmall = 2), "kg")),
              size = 4) +
    scale_fill_brewer(palette = "Pastel1")
```

### See Also

To control the appearance of the text, see Recipe \@ref(RECIPE-APPEARANCE-TEXT-APPEARANCE).

For more on transforming data by groups, see Recipe \@ref(RECIPE-DATAPREP-CALCULATE-GROUP).


Making a Cleveland Dot Plot {#RECIPE-BAR-GRAPH-DOT-PLOT}
---------------------------

### Problem

You want to make a Cleveland dot plot.

### Solution

Cleveland dot plots are an alternative to bar graphs that reduce visual clutter and can be easier to read.

The simplest way to create a dot plot (as shown in Figure \@ref(fig:FIG-BAR-GRAPH-DOTPLOT)) is to use `geom_point()`:

```{r FIG-BAR-GRAPH-DOTPLOT, fig.cap="Basic dot plot", fig.width = 4, fig.height=5, out.width="50%"}
library(gcookbook) # For the data set
tophit <- tophitters2001[1:25, ] # Take the top 25 from the tophitters data set

ggplot(tophit, aes(x = avg, y = name)) + geom_point()
```

### Discussion

The `tophitters2001` data set contains many columns, but we'll focus on just three of them for this example:

```{r}
tophit[, c("name", "lg", "avg")]
```

In Figure \@ref(fig:FIG-BAR-GRAPH-DOTPLOT) the names are sorted alphabetically, which isn't very useful in this graph. Dot plots are often sorted by the value of the continuous variable on the horizontal axis.

Although the rows of `tophit` happen to be sorted by `avg`, that doesn't mean that the items will be ordered that way in the graph. By default, the items on the given axis will be ordered however is appropriate for the data type. `name` is a character vector, so it's ordered alphabetically. If it were a factor, it would use the order defined in the factor levels. In this case, we want `name` to be sorted by a different variable, `avg`.

To do this, we can use `reorder(name, avg)`, which takes the name column, turns it into a factor, and sorts the factor levels by `avg`. To further improve the appearance, we'll make the vertical grid lines go away by using the theming system, and turn the horizontal grid lines into dashed lines (Figure \@ref(fig:FIG-BAR-GRAPH-DOTPLOT-ORDERED)):

```{r FIG-BAR-GRAPH-DOTPLOT-ORDERED, fig.cap="Dot plot, ordered by batting average", fig.width=4, fig.height=5, out.width="50%"}
ggplot(tophit, aes(x = avg, y = reorder(name, avg))) +
    geom_point(size = 3) +                        # Use a larger dot
    theme_bw() +
    theme(panel.grid.major.x = element_blank(),
          panel.grid.minor.x = element_blank(),
          panel.grid.major.y = element_line(colour = "grey60", linetype = "dashed"))
```

It's also possible to swap the axes so that the names go along the x-axis and the values go along the y-axis, as shown in Figure \@ref(fig:FIG-BAR-GRAPH-DOTPLOT-ORDERED-SWAP). We'll also rotate the text labels by 60 degrees:

```{r FIG-BAR-GRAPH-DOTPLOT-ORDERED-SWAP, fig.cap="Dot plot with names on x-axis and values on y-axis", fig.width=6, fig.height=4, out.width="80%"}
ggplot(tophit, aes(x = reorder(name, avg), y = avg)) +
    geom_point(size = 3) +                        # Use a larger dot
    theme_bw() +
    theme(axis.text.x = element_text(angle = 60, hjust = 1),
          panel.grid.major.y = element_blank(),
          panel.grid.minor.y = element_blank(),
          panel.grid.major.x = element_line(colour = "grey60", linetype = "dashed"))
```


It's also sometimes desirable to group the items by another variable. In this case we'll use the factor `lg`, which has the levels `NL` and `AL`, representing the National League and the American League. This time we want to sort first by `lg` and then by `avg`. Unfortunately, the `reorder()` function will only order factor levels by one other variable; to order the factor levels by two variables, we must do it manually:

```{r}
# Get the names, sorted first by lg, then by avg
nameorder <- tophit$name[order(tophit$lg, tophit$avg)]

# Turn name into a factor, with levels in the order of nameorder
tophit$name <- factor(tophit$name, levels = nameorder)
```

To make the graph (Figure \@ref(fig:FIG-BAR-GRAPH-DOTPLOT-ORDERED2)), we'll also add a mapping of `lg` to the color of the points. Instead of using grid lines that run all the way across, this time we'll make the lines go only up to the points, by using `geom_segment()`. Note that `geom_segment()` needs values for `x`, `y`, `xend`, and `yend`:

```{r FIG-BAR-GRAPH-DOTPLOT-ORDERED2, fig.cap="Grouped by league, with lines that stop at the point", fig.width=4, fig.height=6, out.width="50%"}
ggplot(tophit, aes(x = avg, y = name)) +
    geom_segment(aes(yend = name), xend = 0, colour = "grey50") +
    geom_point(size = 3, aes(colour = lg)) +
    scale_colour_brewer(palette = "Set1", limits = c("NL", "AL")) +
    theme_bw() +
    theme(panel.grid.major.y = element_blank(),   # No horizontal grid lines
          legend.position = c(1, 0.55),           # Put legend inside plot area
          legend.justification = c(1, 0.5))
```

Another way to separate the two groups is to use facets, as shown in Figure \@ref(fig:FIG-BAR-GRAPH-DOTPLOT-ORDERED2-FACET). The order in which the facets are displayed is different from the sorting order in Figure \@ref(fig:FIG-BAR-GRAPH-DOTPLOT-ORDERED2); to change the display order, you must change the order of factor levels in the `lg` variable:

```{r FIG-BAR-GRAPH-DOTPLOT-ORDERED2-FACET, fig.cap="Faceted by league", fig.width=4, fig.height=6, out.width="50%"}
ggplot(tophit, aes(x = avg, y = name)) +
    geom_segment(aes(yend = name), xend = 0, colour = "grey50") +
    geom_point(size = 3, aes(colour = lg)) +
    scale_colour_brewer(palette = "Set1", limits = c("NL", "AL"), guide = FALSE) +
    theme_bw() +
    theme(panel.grid.major.y = element_blank()) +
    facet_grid(lg ~ ., scales = "free_y", space = "free_y")
```

### See Also

For more on changing the order of factor levels, see Recipe \@ref(RECIPE-DATAPREP-FACTOR-REORDER). Also see Recipe \@ref(RECIPE-DATAPREP-FACTOR-REORDER-VALUE) for details on changing the order of factor levels based on some other values.

For more on moving the legend, see Recipe \@ref(RECIPE-LEGEND-POSITION). To hide grid lines, see Recipe \@ref(RECIPE-APPEARANCE-HIDE-GRIDLINES).

<!--chapter:end:ch03.Rmd-->

---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
# This block needs cache=FALSE to set fig.width and fig.height, and have those
# persist across cached builds.

source("utils.R", local = TRUE)
knitr::opts_chunk$set(fig.width=5, fig.height=3.5, out.width="50%")
```



Line Graphs {#CHAPTER-LINE-GRAPH}
===========

Line graphs are typically used for visualizing how one continuous variable, on the y-axis, changes in relation to another continuous variable, on the x-axis. Often the *x* variable represents time, but it may also represent some other continuous quantity, for example, the amount of a drug administered to experimental subjects.

As with bar graphs, there are exceptions. Line graphs can also be used with a discrete variable on the x-axis. This is appropriate when the variable is ordered (e.g., "small", "medium", "large"), but not when the variable is unordered (e.g., "cow", "goose", "pig"). Most of the examples in this chapter use a continuous *x* variable, but we'll see one example where the variable is converted to a factor and thus treated as a discrete variable.

Making a Basic Line Graph {#RECIPE-LINE-GRAPH-BASIC-LINE}
-------------------------

### Problem

You want to make a basic line graph.

### Solution

Use `ggplot()` with `geom_line()`, and specify which variables you mapped to x and y (Figure \@ref(fig:FIG-LINE-GRAPH-BASIC-LINE)):

```{r FIG-LINE-GRAPH-BASIC-LINE, fig.cap="Basic line graph"}
ggplot(BOD, aes(x = Time, y = demand)) + geom_line()
```

### Discussion

In this sample data set, the *x* variable, Time, is in one column and the *y* variable, demand, is in another:

```{r}
BOD
```

Line graphs can be made with discrete (categorical) or continuous (numeric) variables on the x-axis. In the example here, the variable demand is numeric, but it could be treated as a categorical variable by converting it to a factor with `factor()` (Figure \@ref(fig:FIG-LINE-GRAPH-BASIC-LINE-FACTOR)). When the *x* variable is a factor, you must also use `aes(group=1)` to ensure that ggplot knows that the data points belong together and should be connected with a line (see Recipe \@ref(RECIPE-LINE-GRAPH-MULTIPLE-LINE) for an explanation of why group is needed with factors):

```{r FIG-LINE-GRAPH-BASIC-LINE-FACTOR, fig.cap="Basic line graph with a factor on the x-axis (notice that no space is allocated on the x-axis for 6)"}
BOD1 <- BOD  # Make a copy of the data
BOD1$Time <- factor(BOD1$Time)
ggplot(BOD1, aes(x = Time, y = demand, group = 1)) + geom_line()
```

In the `BOD` data set there is no entry for `Time=6`, so there is no level 6 when `Time` is converted to a factor. Factors hold categorical values, and in that context, 6 is just another value. It happens to not be in the data set, so there's no space for it on the x-axis.

With ggplot2, the default *y* range of a line graph is just enough to include the *y* values in the data. For some kinds of data, it's better to have the *y* range start from zero. You can use `ylim()` to set the range, or you can use `expand_limits()` to expand the range to include a value. This will set the range from zero to the maximum value of the demand column in `BOD` (Figure \@ref(fig:FIG-LINE-GRAPH-BASIC-LINE-YLIM)):

```{r eval=F}
# These have the same result
ggplot(BOD, aes(x = Time, y = demand)) + geom_line() + ylim(0, max(BOD$demand))
ggplot(BOD, aes(x = Time, y = demand)) + geom_line() + expand_limits(y = 0)
```

```{r FIG-LINE-GRAPH-BASIC-LINE-YLIM, echo=FALSE, fig.cap="Line graph with manually set y range"}
# This code block is so that it generates just one of the plots from above
ggplot(BOD, aes(x = Time, y = demand)) + geom_line() + expand_limits(y = 0)
```

### See Also

See Recipe \@ref(RECIPE-AXES-RANGE) for more on controlling the range of the axes.


Adding Points to a Line Graph {#RECIPE-LINE-GRAPH-POINTS}
-----------------------------

### Problem

You want to add points to a line graph.

### Solution

Add `geom_point()` (Figure \@ref(fig:FIG-LINE-GRAPH-POINT)):

```{r FIG-LINE-GRAPH-POINT, fig.cap="Line graph with points"}
ggplot(BOD, aes(x = Time, y = demand)) + geom_line() + geom_point()
```

### Discussion

Sometimes it is useful to indicate each data point on a line graph. This is helpful when the density of observations is low, or when the observations do not happen at regular intervals. For example, in the `BOD` data set there is no entry for `Time=6`, but this is not apparent from just a bare line graph (compare Figure \@ref(fig:FIG-LINE-GRAPH-BASIC-LINE-YLIM) with Figure \@ref(fig:FIG-LINE-GRAPH-POINT)).

In the `worldpop` data set, the intervals between each data point are not consistent. In the far past, the estimates were not as frequent as they are in the more recent past. Displaying points on the graph illustrates when each estimate was made (Figure \@ref(fig:FIG-LINE-GRAPH-POINTS-INTERVAL)):

```{r FIG-LINE-GRAPH-POINTS-INTERVAL, fig.show="hold", fig.cap='Top: points indicate where each data point is; bottom: the same data with a log y-axis', fig.height=2}
library(gcookbook) # For the data set

ggplot(worldpop, aes(x=Year, y=Population)) + geom_line() + geom_point()

# Same with a log y-axis
ggplot(worldpop, aes(x=Year, y=Population)) + geom_line() + geom_point() +
    scale_y_log10()
```

With the log y-axis, you can see that the rate of proportional change has increased in the last thousand years. The estimates for the years before 0 have a roughly constant rate of change of 10 times per 5,000 years. In the most recent 1,000 years, the population has increased at a much faster rate. We can also see that the population estimates are much more frequent in recent times--and probably more accurate!

### See Also

To change the appearance of the points, see Recipe \@ref(RECIPE-LINE-GRAPH-POINT-APPEARANCE).


Making a Line Graph with Multiple Lines {#RECIPE-LINE-GRAPH-MULTIPLE-LINE}
---------------------------------------

### Problem

You want to make a line graph with more than one line.

### Solution

In addition to the variables mapped to the x- and y-axes, map another (discrete) variable to colour or linetype, as shown in Figure \@ref(fig:FIG-LINE-GRAPH-MULTI-LINE-COLOR-TYPE):

```{r FIG-LINE-GRAPH-MULTI-LINE-COLOR-TYPE, fig.show="hold", fig.cap="Left: a variable mapped to colour; right: a variable mapped to linetype"}
library(gcookbook) # For the data set

# Map supp to colour
ggplot(tg, aes( x = dose, y = length, colour = supp)) + geom_line()

# Map supp to linetype
ggplot(tg, aes(x = dose, y = length, linetype = supp)) + geom_line()
```

### Discussion

The `tg` data has three columns, including the factor `supp`, which we mapped to `colour` and `linetype`:

```{r}
tg
```

> **Note**
>
> If the *x* variable is a factor, you must also tell ggplot to group by that same variable, as described below.

Line graphs can be used with a continuous or categorical variable on the x-axis. Sometimes the variable mapped to the x-axis is *conceived* of as being categorical, even when it's stored as a number. In the example here, there are three values of dose: 0.5, 1.0, and 2.0. You may want to treat these as categories rather than values on a continuous scale. To do this, convert `dose` to a factor (Figure \@ref(fig:FIG-LINE-GRAPH-MULTI-LINE-FACTOR)):

```{r FIG-LINE-GRAPH-MULTI-LINE-FACTOR, fig.cap="Line graph with continuous x variable converted to a factor"}
ggplot(tg, aes(x = factor(dose), y = length, colour = supp, group = supp)) + geom_line()
```


Notice the use of `group=supp`. Without this statement, ggplot won't know how to group the data together to draw the lines, and it will give an error:

```{r eval=FALSE}
ggplot(tg, aes(x = factor(dose), y = length, colour = supp)) + geom_line()
#> geom_path: Each group consists of only one observation. Do you need to
#> adjust the group aesthetic?
```

Another common problem when the incorrect grouping is used is that you will see a jagged sawtooth pattern, as in Figure \@ref(fig:FIG-LINE-GRAPH-MULTI-LINE-SAWTOOTH):

```{r FIG-LINE-GRAPH-MULTI-LINE-SAWTOOTH, fig.cap="A sawtooth pattern indicates improper grouping"}
ggplot(tg, aes(x = dose, y = length)) + geom_line()
```

This happens because there are multiple data points at each *y* location, and ggplot thinks they're all in one group. The data points for each group are connected with a single line, leading to the sawtooth pattern. If any *discrete* variables are mapped to aesthetics like colour or linetype, they are automatically used as grouping variables. But if you want to use other variables for grouping (that aren't mapped to an aesthetic), they should be used with group.

> **Note**
>
> When in doubt, if your line graph looks wrong, try explicitly specifying the grouping variable with group. It's common for problems to occur with line graphs because ggplot is unsure of how the variables should be grouped.

If your plot has points along with the lines, you can also map variables to properties of the points, such as shape and fill (Figure \@ref(fig:FIG-LINE-GRAPH-MULTI-LINE-SHAPE-FILL)):

```{r FIG-LINE-GRAPH-MULTI-LINE-SHAPE-FILL, fig.show="hold", fig.cap="Left: line graph with different shapes; right: with different colors"}
ggplot(tg, aes(x = dose, y = length, shape = supp)) + geom_line() +
    geom_point(size = 4)           # Make the points a little larger

ggplot(tg, aes(x = dose, y = length, fill = supp)) + geom_line() +
    geom_point(size = 4, shape = 21) # Also use a point with a color fill
```

Sometimes points will overlap. In these cases, you may want to *dodge* them, which means their positions will be adjusted left and right (Figure \@ref(fig:FIG-LINE-GRAPH-MULTI-LINE-DODGE)). When doing so, you must also dodge the lines, or else only the points will move and they will be misaligned. You must also specify how far they should move when dodged:

```{r FIG-LINE-GRAPH-MULTI-LINE-DODGE, fig.cap="Dodging to avoid overlapping points"}
ggplot(tg, aes(x = dose, y = length, shape = supp)) +
    geom_line(position = position_dodge(0.2)) +           # Dodge lines by 0.2
    geom_point(position = position_dodge(0.2), size = 4)  # Dodge points by 0.2
```


Changing the Appearance of Lines {#RECIPE-LINE-GRAPH-LINE-APPEARANCE}
--------------------------------

### Problem

You want to change the appearance of the lines in a line graph.

### Solution

The type of line (solid, dashed, dotted, etc.) is set with `linetype`, the thickness (in mm) with `size`, and the color of the line with `colour` (or `color`).

These properties can be set (as shown in Figure \@ref(fig:FIG-BAR-GRAPH-BASIC-LINE-CUSTOMIZED)) by passing them values in the call to `geom_line()`:

```{r FIG-BAR-GRAPH-BASIC-LINE-CUSTOMIZED, fig.cap="Line graph with custom linetype, size, and colour"}
ggplot(BOD, aes(x = Time, y = demand)) +
    geom_line(linetype = "dashed", size = 1, colour = "blue")
```

If there is more than one line, setting the aesthetic properties will affect all of the lines. On the other hand, *mapping* variables to the properties, as we saw in Recipe \@ref(RECIPE-LINE-GRAPH-MULTIPLE-LINE), will result in each line looking different. The default colors aren't the most appealing, so you may want to use a different palette, as shown in Figure \@ref(fig:FIG-LINE-GRAPH-MULTI-LINE-PALETTE), by using `scale_colour_brewer()` or `scale_colour_manual()`:

```{r FIG-LINE-GRAPH-MULTI-LINE-PALETTE, fig.cap="Using a palette from RColorBrewer"}
library(gcookbook) # For the data set

ggplot(tg, aes(x = dose, y = length, colour = supp)) +
    geom_line() +
    scale_colour_brewer(palette = "Set1")
```

### Discussion

To set a single constant color for all the lines, specify colour outside of `aes()`. The same works for size, linetype, and point shape (Figure \@ref(fig:FIG-LINE-GRAPH-MULTI-LINE-CONSTANT-AES)). You may also have to specify the grouping variable:

```{r FIG-LINE-GRAPH-MULTI-LINE-CONSTANT-AES, fig.show="hold", fig.cap="Left: line graph with constant size and color; right: with supp mapped to colour, and with points added"}
# If both lines have the same properties, you need to specify a variable to
# use for grouping
ggplot(tg, aes(x = dose, y = length, group = supp)) +
    geom_line(colour = "darkgreen", size = 1.5)

# Since supp is mapped to colour, it will automatically be used for grouping
ggplot(tg, aes(x = dose, y = length, colour = supp)) +
    geom_line(linetype = "dashed") +
    geom_point(shape = 22, size = 3, fill = "white")
```

### See Also

For more information about using colors, see Chapter \@ref(CHAPTER-COLORS).


Changing the Appearance of Points {#RECIPE-LINE-GRAPH-POINT-APPEARANCE}
---------------------------------

### Problem

You want to change the appearance of the points in a line graph.

### Solution

In `geom_point()`, set the `size`, `shape`, `colour`, and/or `fill` outside of `aes()` (the result is shown in Figure \@ref(fig:FIG-LINE-GRAPH-POINT-PROPERTIES)):

```{r FIG-LINE-GRAPH-POINT-PROPERTIES, fig.cap="Points with custom size, shape, color, and fill"}
ggplot(BOD, aes(x = Time, y = demand)) +
    geom_line() +
    geom_point(size = 4, shape = 22, colour = "darkred", fill = "pink")
```

### Discussion

The default shape for points is a solid circle, the default size is 2, and the default colour is black. The fill color is relevant only for some point shapes (numbered 2125), which have separate outline and fill colors (see Recipe \@ref(RECIPE-SCATTER-SHAPES) for a chart of shapes). The fill color is typically `NA`, or empty; you can fill it with white to get hollow-looking circles, as shown in Figure \@ref(fig:FIG-LINE-GRAPH-POINT-WHITEFILL):

```{r FIG-LINE-GRAPH-POINT-WHITEFILL, fig.cap="Points with a white fill"}
ggplot(BOD, aes(x = Time, y = demand)) +
    geom_line() +
    geom_point(size = 4, shape = 21, fill = "white")
```

If the points and lines have different colors, you should specify the points after the lines, so that they are drawn on top. Otherwise, the lines will be drawn on top of the points.

For multiple lines, we saw in Recipe \@ref(RECIPE-LINE-GRAPH-MULTIPLE-LINE) how to draw differently colored points for each group by mapping variables to aesthetic properties of points, inside of `aes()`. The default colors are not very appealing, so you may want to use a different palette, using `scale_colour_brewer()` or `scale_colour_manual()`. To set a single constant shape or size for all the points, as in Figure \@ref(fig:FIG-LINE-GRAPH-MULTI-LINE-POINT-PALETTE), specify shape or size outside of `aes()`:

```{r FIG-LINE-GRAPH-MULTI-LINE-POINT-PALETTE, fig.cap="Line graph with manually specified fills of black and white, and a slight dodge"}
library(gcookbook) # For the data set

# Save the position_dodge specification because we'll use it multiple times
pd <- position_dodge(0.2)

ggplot(tg, aes(x = dose, y = length, fill = supp)) +
    geom_line(position = pd) +
    geom_point(shape = 21, size = 3, position = pd) +
    scale_fill_manual(values = c("black","white"))
```


### See Also

See Recipe \@ref(RECIPE-SCATTER-SHAPES) for more on using different shapes, and Chapter \@ref(CHAPTER-COLORS) for more about colors.


Making a Graph with a Shaded Area {#RECIPE-LINE-GRAPH-AREA}
---------------------------------

### Problem

You want to make a graph with a shaded area.

### Solution

Use `geom_area()` to get a shaded area, as in Figure \@ref(fig:FIG-LINE-GRAPH-AREA):

```{r FIG-LINE-GRAPH-AREA, fig.cap="Graph with a shaded area", fig.width=8, fig.height=1.5, out.width="100%"}
# Convert the sunspot.year data set into a data frame for this example
sunspotyear <- data.frame(
    Year     = as.numeric(time(sunspot.year)),
    Sunspots = as.numeric(sunspot.year)
)

ggplot(sunspotyear, aes(x = Year, y = Sunspots)) + geom_area()
```

### Discussion

By default, the area will be filled with a very dark grey and will have no outline. The color can be changed by setting `fill`. In the following example, we'll set it to `"blue"`, and we'll also make it 80% transparent by setting `alpha` to 0.2. This makes it possible to see the grid lines through the area, as shown in Figure \@ref(fig:FIG-LINE-GRAPH-AREA-OUTLINE). We'll also add an outline, by setting colour:

```{r FIG-LINE-GRAPH-AREA-OUTLINE, fig.cap="Graph with a semitransparent shaded area and an outline", fig.width=8, fig.height=1.5, out.width="100%"}
ggplot(sunspotyear, aes(x = Year, y = Sunspots)) +
    geom_area(colour = "black", fill = "blue", alpha = .2)
```

Having an outline around the entire area might not be desirable, because it puts a vertical line at the beginning and end of the shaded area, as well as one along the bottom. To avoid this issue, we can draw the area without an outline (by not specifying colour), and then layer a `geom_line()` on top, as shown in Figure \@ref(fig:FIG-LINE-GRAPH-AREA-TOPLINE):

(ref:cap-FIG-LINE-GRAPH-AREA-TOPLINE) Line graph with a line just on top, using `geom_line()`

```{r FIG-LINE-GRAPH-AREA-TOPLINE, fig.cap="(ref:cap-FIG-LINE-GRAPH-AREA-TOPLINE)", fig.width=8, fig.height=1.5, out.width="100%"}
ggplot(sunspotyear, aes(x = Year, y = Sunspots)) +
    geom_area(fill = "blue", alpha = .2) +
    geom_line()
```

### See Also

See Chapter \@ref(CHAPTER-COLORS) for more on choosing colors.


Making a Stacked Area Graph {#RECIPE-LINE-GRAPH-STACKED-AREA}
---------------------------

### Problem

You want to make a stacked area graph.

### Solution

Use `geom_area()` andmap a factor to fill (Figure \@ref(fig:FIG-LINE-GRAPH-STACKED-AREA)):

```{r FIG-LINE-GRAPH-STACKED-AREA, fig.cap="Stacked area graph", fig.width=6, out.width="75%"}
library(gcookbook) # For the data set

ggplot(uspopage, aes(x = Year, y = Thousands, fill = AgeGroup)) + geom_area()
```

### Discussion

The sort of data that is plotted with a stacked area chart is often provided in a wide format, but ggplot requires data to be in long format. To convert it, see Recipe \@ref(RECIPE-DATAPREP-WIDE-TO-LONG).

In the example here, we used the `uspopage` data set:

```{r}
uspopage
```

This version of the chart (Figure \@ref(fig:FIG-LINE-GRAPH-STACKED-AREA-CUSTOMIZED)) changes the palette to a range of blues and adds thin (`size=.2`) lines between each area. It also makes the filled areas semitransparent (`alpha=.4`), so that it is possible to see the grid lines through them:

```{r FIG-LINE-GRAPH-STACKED-AREA-CUSTOMIZED, fig.cap="Reversed legend order, lines, and a different palette", fig.width=6, out.width="75%"}
ggplot(uspopage, aes(x = Year, y = Thousands, fill = AgeGroup)) +
    geom_area(colour = "black", size = .2, alpha = .4) +
    scale_fill_brewer(palette = "Blues")
```

Since each filled area is drawn with a polygon, the outline includes the left and right sides. This might be distracting or misleading. To get rid of it (Figure \@ref(fig:FIG-LINE-GRAPH-STACKED-AREA-NOSIDES)), first draw the stacked areas *without* an outline (by leaving `colour` as the default `NA` value), and then add a `geom_line()` on top:

```{r FIG-LINE-GRAPH-STACKED-AREA-NOSIDES, fig.cap="No lines on the left and right of the graph", fig.width=6, out.width="75%"}
ggplot(uspopage, aes(x = Year, y = Thousands, fill = AgeGroup, order = dplyr::desc(AgeGroup))) +
    geom_area(colour = NA, alpha = .4) +
    scale_fill_brewer(palette = "Blues") +
    geom_line(position = "stack", size = .2)
```

### See Also

See Recipe \@ref(RECIPE-DATAPREP-WIDE-TO-LONG) for more on converting data from wide to long format.

See Chapter \@ref(CHAPTER-COLORS) for more on choosing colors.


Making a Proportional Stacked Area Graph {#RECIPE-LINE-GRAPH-PROPORTIONAL-STACKED-AREA}
----------------------------------------

### Problem

You want to make a stacked area graph with the overall height scaled to a constant value.

### Solution

Use `geom_area(position="fill")`, as in Figure \@ref(fig:FIG-LINE-GRAPH-PROPORTIONAL-STACKED-AREA), left:

```{r FIG-LINE-GRAPH-PROPORTIONAL-STACKED-AREA-1, eval=FALSE, fig.show="hold"}
ggplot(uspopage, aes(x = Year, y = Thousands, fill = AgeGroup)) +
    geom_area(position = "fill", colour = "black", size = .2, alpha = .4) +
    scale_fill_brewer(palette = "Blues")
```

### Discussion

With `position="fill"`, the y values will be scaled to go from 0 to 1. To print the labels as percentages, use `scale_y_continuous(labels = scales::percent)`, as in Figure \@ref(fig:FIG-LINE-GRAPH-PROPORTIONAL-STACKED-AREA), right:

```{r FIG-LINE-GRAPH-PROPORTIONAL-STACKED-AREA-2, eval=FALSE, fig.show="hold"}
ggplot(uspopage, aes(x = Year, y = Thousands, fill = AgeGroup)) +
    geom_area(position = "fill", colour = "black", size = .2, alpha = .4) +
    scale_fill_brewer(palette = "Blues") +
    scale_y_continuous(labels = scales::percent)
```

```{r FIG-LINE-GRAPH-PROPORTIONAL-STACKED-AREA, ref.label=c("FIG-LINE-GRAPH-PROPORTIONAL-STACKED-AREA-1", "FIG-LINE-GRAPH-PROPORTIONAL-STACKED-AREA-2"), echo=FALSE, fig.cap="A proportional stacked area graph", fig.width=6}
```


### See Also

Creating stacked bar graph is done in a similar way. See Recipe \@ref(RECIPE-BAR-GRAPH-PROPORTIONAL-STACKED-BAR) for information about computing the percentages separately.

For more on summarizing data by groups, see Recipe \@ref(RECIPE-DATAPREP-SUMMARIZE).


Adding a Confidence Region {#RECIPE-LINE-GRAPH-REGION}
--------------------------

### Problem

You want to add a confidence region to a graph.

### Solution

Use `geom_ribbon()` and map values to `ymin` and `ymax`.

In the `climate` data set, `Anomaly10y` is a 10-year running average of the deviation (in Celsius) from the average 19501980 temperature, and `Unc10y` is the 95% confidence interval. We'll set `ymax` and `ymin` to `Anomaly10y` plus or minus `Unc10y` (Figure \@ref(fig:FIG-LINE-GRAPH-REGION)):

```{r FIG-LINE-GRAPH-REGION, fig.cap="A line graph with a shaded confidence region", fig.width=8, out.width="100%"}
library(gcookbook) # For the data set
library(dplyr)
# Grab a subset of the climate data
clim <- climate %>%
    filter(Source == "Berkeley") %>%
    select(Year, Anomaly10y, Unc10y)
clim

# Shaded region
ggplot(clim, aes(x = Year, y = Anomaly10y)) +
    geom_ribbon(aes(ymin = Anomaly10y-Unc10y, ymax = Anomaly10y+Unc10y),
                alpha=0.2) +
    geom_line()
```

The shaded region is actually a very dark grey, but it is mostly transparent. The transparency is set with `alpha=0.2`, which makes it 80% transparent.

### Discussion

Notice that the `geom_ribbon()` comes before `geom_line()`, so that the line is drawn on top of the shaded region. If the reverse order were used, the shaded region could obscure the line. In this particular case that wouldn't be a problem since the shaded region is mostly transparent, but it would be a problem if the shaded region were opaque.

Instead of a shaded region, you can also use dotted lines to represent the upper and lower bounds (Figure \@ref(fig:FIG-LINE-GRAPH-REGION-LINES)):

```{r FIG-LINE-GRAPH-REGION-LINES, fig.cap="A line graph with dotted lines representing a confidence region", fig.width=8, out.width="100%"}
# With a dotted line for upper and lower bounds
ggplot(clim, aes(x = Year, y = Anomaly10y)) +
    geom_line(aes(y = Anomaly10y-Unc10y), colour = "grey50", linetype = "dotted") +
    geom_line(aes(y = Anomaly10y+Unc10y), colour = "grey50", linetype = "dotted") +
    geom_line()
```

Shaded regions can represent things other than confidence regions, such as the difference between two values, for example.

In the area graphs in Recipe \@ref(RECIPE-LINE-GRAPH-STACKED-AREA), the *y* range of the shaded area goes from 0 to y. Here, it goes from `ymin` to `ymax`.

<!--chapter:end:ch04.Rmd-->

---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
source("utils.R", local = TRUE)
```

Scatter Plots {#CHAPTER-SCATTER}
=============

Scatter plots are used to display the relationship between two continuous
variables. In a scatter plot, each observation in a data set is represented by a
point. Often, a scatter plot will also have a line showing the predicted values
based on some statistical model. Adding this line is easy to do with R and the
ggplot2 package, and can help to make sense of data when the trends aren't
immediately obvious just by looking at the points.

With large data sets, plotting every single observation in the data set can
result in overplotting, when points overlap and obscure one another. To deal
with the problem of overplotting, you'll probably want to summarize the data
before displaying it. We'll also see how to do that in this chapter.


Making a Basic Scatter Plot {#RECIPE-SCATTER-BASIC-SCATTER}
---------------------------

### Problem

You want to make a scatter plot using two continuous variables.

### Solution

Use `geom_point()`, and map one variable to `x` and one variable to `y`.

We will use the `heightweight` data set. There are a number of columns in this
data set, but we'll only use two in this example (Figure
\@ref(fig:FIG-SCATTER-BASIC)):

```{r FIG-SCATTER-BASIC, fig.cap="A basic scatter plot"}
library(gcookbook) # Load the gcookbook package to access the heightweight data set 

# Show the head of the two columns we'll use in the plot
heightweight %>% 
  select(ageYear, heightIn)

heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn)) + 
  geom_point()
```

### Discussion

Instead of points, you can use different shapes for your scatter plot by using
the `shape` aesthetic. A common alternative to the default solid circles 
(shape #19) is hollow ones (#21), as seen in Figure
\@ref(fig:FIG-SCATTER-BASIC-SHAPE-SIZE) (left):

```{r, eval=FALSE}
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn)) + 
  geom_point(shape = 21)
```

The size of the points can be controlled with the `size` aesthetic. The default
value of size is 2 (`size = 2`). The following code will set `size = 1.5` to
create smaller points (Figure \@ref(fig:FIG-SCATTER-BASIC-SHAPE-SIZE), right):

```{r, eval=FALSE}
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn)) + 
  geom_point(size = 1.5)
```

```{r FIG-SCATTER-BASIC-SHAPE-SIZE, echo=FALSE, fig.show="hold", fig.cap="Scatter plot with hollow circles (left; shape 21); With smaller points (right)", fig.width=3.5, fig.height=3.5}
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn)) + 
  geom_point(shape = 21)

heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn)) + 
  geom_point(size = 1.5)
```


Grouping Points Together using Shapes or Colors {#RECIPE-SCATTER-GROUPED-SCATTER}
-------------------------------------------------------

### Problem

You want to visually group points by some variable (the grouping variable), using different shapes or colors.

### Solution

Map the grouping variable to the aesthetic of `shape` or `colour`. We'll use
three columns from the `heightweight` data set for this example:

```{r}
library(gcookbook) # Load the gcookbook package to access the heightweight data set 

# Show the head of the three columns we'll use
heightweight %>% 
  select(sex, ageYear, heightIn)
```

We can use the aesthetics of `colour` or `shape` to visually differentiate the
data points belonging to different categories of `sex`. We do this by mapping
`sex` to one of the aesthetics `colour` or `shape` (Figure\@ref(fig:FIG-SCATTER-SHAPE-COLOR)):

```{r FIG-SCATTER-SHAPE-COLOR, echo=FALSE, fig.show="hold", fig.cap="Grouping points by a variable mapped to colour (left), or to shape (right)", fig.width=3.5, fig.height=3.5}
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, colour = sex)) + 
  geom_point() 

heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, shape = sex)) + 
  geom_point()
```

### Discussion

The grouping variable you choose must be categorical -- in other words, a factor
or character vector. If the grouping variable is a numeric vector, you should
convert it to a factor first.

It is possible to map a variable to both `shape` and `colour`, or, if you have
multiple grouping variables, to map each grouping variable to a different
aesthetic. Here, we'll map the variable `sex` to both `shape` and `colour`
aesthetics (Figure \@ref(fig:FIG-SCATTER-SHAPE-COLOR-BOTH), left):

```{r, eval=FALSE}
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, shape = sex, colour = sex)) +
  geom_point()
```

You may want to use different shapes and colors than are given by the default
settings. You can select other shapes for the grouping variables using
`scale_shape_manual()`, and select other colors using `scale_colour_brewer()` or
`scale_colour_manual()`. (Figure \@ref(fig:FIG-SCATTER-SHAPE-COLOR-BOTH),
right):

```{r, eval=FALSE}
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, shape = sex, colour = sex)) +
  geom_point() +
  scale_shape_manual(values = c(1,2)) +
  scale_colour_brewer(palette = "Set1")
```

```{r FIG-SCATTER-SHAPE-COLOR-BOTH, echo=FALSE, fig.show="hold", fig.cap="Mapping to both shape and colour (left); With manually set shapes and colors (right)", fig.width=3.5, fig.height=3.5}
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, shape = sex, colour = sex)) +
  geom_point()

heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, shape = sex, colour = sex)) +
  geom_point() +
  scale_shape_manual(values = c(1,2)) +
  scale_colour_brewer(palette = "Set1")
```

### See Also

To use different shapes, see Recipe \@ref(RECIPE-SCATTER-SHAPES).

For more on using different colors, see Chapter \@ref(CHAPTER-COLORS).


Using Different Point Shapes {#RECIPE-SCATTER-SHAPES}
----------------------------

### Problem

You want to change the default scatterplot shapes for the data points.

### Solution

You can set the shape of all the data points at once (Figure
\@ref(fig:FIG-SCATTER-SHAPES), left) by setting a shape in `geom_point()`:

```{r, eval=FALSE}
library(gcookbook) # Load the gcookbook package to access the heightweight data set 

heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn)) + 
  geom_point(shape = 3)
```

If you have mapped a variable to `shape`, you can use `scale_shape_manual()` to
manually change the shapes mapped to the levels of that variable:

```{r, eval=FALSE}
# Use slightly larger points and use custom values for the shape scale
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, shape = sex)) +
  geom_point(size = 3) +
  scale_shape_manual(values = c(1, 4))
```

```{r FIG-SCATTER-SHAPES, echo=FALSE, fig.show="hold", fig.cap="Scatter plot with the shape aesthetic set to a custom value (left); With a variable mapped to shape, using a custom shape palette (right)", fig.width=3.5, fig.height=3.5}
library(gcookbook) # Load the gcookbook package to access the heightweight data set 

heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn)) + 
  geom_point(shape = 3)

heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, shape = sex)) +
  geom_point(size = 3) +
  scale_shape_manual(values = c(1, 4))
```

### Discussion

Figure \@ref(fig:FIG-SCATTER-SHAPES-CHART) shows the shapes that are already
built into R. Some of the point shapes (114) only have an outline; some
(1520) have solid fill; and some (2125) have an outline and fill that can be
controlled separately. You can also use characters for points.

For shapes 120, the color of the entire point -- even the points that have
solid fill -- is controlled by the `colour` aesthetic. For shapes 2125, the
outline is controlled by `colour` and the fill is controlled by `fill`.

```{r FIG-SCATTER-SHAPES-CHART, echo=FALSE, fig.cap="Shapes in R graphics"}
pchShow <- function(extras = c("*",".", "o","O","0","+","-","|","%","#"),
  cex = 3, ## good for both .Device=="postscript" and "x11"
  col = "red3", bg = "gold", coltext = "brown", cextext = 1.2,
  main = paste("plot symbols :  points (...  pch = *, cex =",
    cex,")"))
{
  nex <- length(extras)
  np  <- 26 + nex
  ipch <- 0:(np-1)
  k <- floor(sqrt(np))
  dd <- c(-1,1)/2
  rx <- dd + range(ix <- ipch %/% k)
  ry <- dd + range(iy <- 3 + (k-1)- ipch %% k)
  pch <- as.list(ipch) # list with integers & strings
  if(nex > 0) pch[26+ 1:nex] <- as.list(extras)
  plot(rx, ry, type="n", axes = FALSE, xlab = "", ylab = "",
    main = main)
  abline(v = ix, h = iy, col = "lightgray", lty = "dotted")
  for(i in 1:np) {
    pc <- pch[[i]]
    ## 'col' symbols with a 'bg'-colored interior (where available) :
    points(ix[i], iy[i], pch = pc, col = col, bg = bg, cex = cex)
    if(cextext > 0)
      text(ix[i] - 0.3, iy[i], pc, col = coltext, cex = cextext)
  }
}

par(mar = c(0,0,0,0))
pchShow(main = NULL)
```

It's possible to have one variable represented by the shape of a point, and and
another variable represented by the fill (empty or filled) of the point. To do
this, you need to first choose point shapes that have both colour and fill, and
set these in `scale_shape_manual`. You then need to choose a fill palette that
includes `NA` and another color (the `NA` will result in a hollow shape) and se
these in `scale_fill_manual`.

For example, we'll take the `heightweight` data set and add another column that
indicates whether the child weighed 100 pounds or more (Figure
\@ref(fig:FIG-SCATTER-SHAPES-FILL)):

```{r FIG-SCATTER-SHAPES-FILL, fig.cap="A variable mapped to shape and another mapped to fill"}
# Using the heightweight data set, create a new column that indicates if the
# child weighs < 100 or >= 100 pounds. We'll save this modified dataset as 'hw'.
hw <-
  heightweight %>% 
  mutate(weightgroup = ifelse(weightLb < 100, "< 100", ">= 100"))

# Specify shapes with fill and color, and specify fill colors that includes an empty (NA) color
hw %>% 
  ggplot(aes(x = ageYear, y = heightIn, shape = sex, fill = weightgroup)) +
  geom_point(size = 2.5) +
  scale_shape_manual(values = c(21, 24)) +
  scale_fill_manual(
    values = c(NA, "black"), 
    guide = guide_legend(override.aes = list(shape = 21))
    )
```

### See Also

For more on using different colors, see Chapter \@ref(CHAPTER-COLORS).

For more information about recoding a continuous variable to a categorical one,
see Recipe \@ref(RECIPE-DATAPREP-RECODE-CONTINUOUS).


Mapping a Continuous Variable to Color or Size {#RECIPE-SCATTER-CONTINUOUS-SCATTER}
----------------------------------------------

### Problem

You want to represent a third continuous variable using color or size.

### Solution

Map the continuous variable to `size` or `colour`. We will use the
`heightweight` data set for this example. There are many columns in this data
set, but we'll only use four of them in this example:

```{r}
library(gcookbook) # Load the gcookbook package to access the heightweight data set 

# Show the head of the four columns we'll use
heightweight %>% 
  select(sex, ageYear, heightIn, weightLb)
```

The basic scatter plot in Recipe \@ref(RECIPE-SCATTER-BASIC-SCATTER) shows the
relationship between the continuous variables `ageYear` and `heightIn`. We can
represent a third continuous variable, `weightLb`, by mapping this variable to
another aesthetic property, such as `colour` or `size` (Figure
\@ref(fig:FIG-SCATTER-CONTINUOUS-COLOR-SIZE):

```{r FIG-SCATTER-CONTINUOUS-COLOR-SIZE, fig.show="hold", fig.cap="A continuous variable mapped to colour (left); Mapped to size (right)", fig.width=3.5, fig.height=3.5}
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, colour = weightLb)) +
  geom_point()

heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, size = weightLb)) +
  geom_point()
```

### Discussion

A basic scatter plot shows the relationship between two continuous variables:
one mapped to the x-axis, and one to the y-axis. When there are more than two
continuous variables, these additional variables must be mapped to other
aesthetics, like `size` and `color`.

Humans can easily perceive small differences in spatial position, so we can
interpret the variables mapped to *x* and *y* coordinates with high precision.
Humans aren't as good at perceiving small differences in `size` and `color`
though, so we will interpret variables mapped to these aesthetic attributes with
much lower precision. Therefore, when you map a variable to `size` or `color`,
make sure it is a variable where high precision is not very important for
correctly intepreting the data.

There is another consideration when mapping a variable to `size`, which is that
the results can be perceptually misleading. While the largest dots in Figure
\@ref(fig:FIG-SCATTER-CONTINUOUS-COLOR-SIZE) are about 36 times the size of the
smallest ones, they are only supposed to represent about 3.5 times the weight of
the smallest dots.

This relative misrepresentation of size happens because the default values in
`ggplot2` for the diameter of points ranges from 1 to 6mm, regardless of the
actual data values. For example, if the data values range from 0 to 10, the
smallest value of 0 will be represented on the plot with a point that is 1mm
wide, while the largest value of 10 will be represented on the plot with a point
that is 6mm wide. Similarly, if the data values range from 100 to 110, the
smallest value of 100 will still be represented by a point that is 1mm wide, and
the largest value of 110 will be represented by a point that is 6mm wide. Thus
regardless of the actual data values, the largest point will have a diameter
that is 6 times the diameter of the smallest point, and will be 36 times the
area.

If it is important for the size of the points to accurately reflect the
proportional differences of your data values, you should first decide if you
want the diameter of the points to represent the data values, or if you want to
area of the points to represent the data values. Figure
\@ref(fig:FIG-SCATTER-SIZE-AREA) shows the difference between these
representations.

```{r FIG-SCATTER-SIZE-AREA, fig.show="hold", fig.cap="Value mapped to diameter of points (left); Value mapped to area of points (right)", fig.width=3.5, fig.height=3.5}

range(heightweight$weightLb)
size_range <- range(heightweight$weightLb) / max(heightweight$weightLb) *  6
size_range

heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, size = weightLb)) +
  geom_point() +
  scale_size_continuous(range = size_range)

heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, size = weightLb)) +
  geom_point() +
  scale_size_area()
```

See Recipe \@ref(RECIPE-SCATTER-BALLOON) for details on making the area of
points proportional to the data values.

When it comes to color, there are actually two aesthetic attributes that can be
used: `color` and `fill`. You will use `color` for most point shapes. However,
shapes 2125 have an outline with a solid region in the middle where the color
is controlled by fill. These outlined shapes can be useful when using a color
scale with light colors as in Figure \@ref(fig:FIG-SCATTER-CONTINUOUS-FILL),
because the outline sets the shapes off from the background. In this example, we
also set the fill gradient to go from black to white and make the points larger
so that the fill is easier to see:

```{r FIG-SCATTER-CONTINUOUS-FILL, echo=FALSE, fig.show="hold", fig.cap="Outlined points with a continuous variable mapped to fill (left); With a discrete legend instead of continuous colorbar (right)", fig.width=3.5, fig.height=3.5}
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, fill = weightLb)) +
  geom_point(shape = 21, size = 2.5) +
  scale_fill_gradient(low = "black", high = "white")

# Using guide_legend() will result in a discrete legend instead of a colorbar legend
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, fill = weightLb)) +
  geom_point(shape = 21, size = 2.5) +
  scale_fill_gradient(
    low = "black", high = "white",
    breaks = seq(70, 170, by = 20),
    guide = guide_legend()
    )
```

Mapping a continuous variable to an aesthetic doesn't prevent us from mapping a
categorical variable to other aesthetics. In Figure
\@ref(fig:FIG-SCATTER-CONTINUOUS-SIZE-CATEGORICAL-COLOR), we'll map `weightLb`
to `size`, and also map `sex` to `color`. Because there is a fair amount of
overplotting (where the points overlap), we'll make the points 50% transparent
by setting `alpha = .5`. We'll also use `scale_size_area()` to make the area of
the points proportional to the data values (see Recipe
\@ref(RECIPE-SCATTER-BALLOON)), and manually change the color palette:

```{r FIG-SCATTER-CONTINUOUS-SIZE-CATEGORICAL-COLOR, echo=FALSE, fig.cap="Continuous variable mapped to size and categorical variable mapped to colour"}
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, size = weightLb, colour = sex)) +
  geom_point(alpha = .5) +
  scale_size_area() +     # Make area proportional to numeric value
  scale_colour_brewer(palette = "Set1")
```

When a variable is mapped to `size`, it's a good idea to *not* map a variable to
`shape`. This is because it is difficult to compare the sizes of different
shapes; for example, a size 4 triangle could appear larger than a size 3.5
circle. Also, some of the shapes really are different sizes: shapes 16 and 19
are both circles, but at any given numeric size, shape 19 circles are visually
larger than shape 16 circles.

### See Also

To use different colors from the default, see Recipe
\@ref(RECIPE-COLORS-PALETTE-CONTINUOUS).

See Recipe \@ref(RECIPE-SCATTER-BALLOON) for creating a balloon plot.


Dealing with Overplotting {#RECIPE-SCATTER-OVERPLOT}
-------------------------

### Problem

You have many points that overlap and obscure each other when plotted.

### Solution

With large data sets, the points in a scatter plot may overlap and obscure each
other and prevent the viewer from accurately assessing the distribution of the
data. This is called *overplotting*. If the amount of overplotting is low, you
may be able to alleviate the problem by using smaller points, or by using a
different shape (like shape 1, a hollow circle) through which other points can
be seen. Figure \@ref(fig:FIG-SCATTER-BASIC-SHAPE-SIZE) in Recipe
\@ref(RECIPE-SCATTER-BASIC-SCATTER) demonstrates both of these solutions.

If there's a high degree of overplotting, there are a number of possible
solutions:

*   Make the points semi-transparent
*   Bin the data into rectangles (better for quantitative analysis)
*   Bin the data into hexagons
*   Use box plots

### Discussion

The scatter plot in Figure \@ref(fig:FIG-SCATTER-OVERPLOT) contains about 54,000
points. They are heavily overplotted, making it impossible to get a sense of the
relative density of points in different areas of the graph:

```{r FIG-SCATTER-OVERPLOT, dev="png", dpi=300, fig.cap="Overplotting, with about 54,000 points", fig.height=3}
# We'll use the diamonds data set and create a base plot called `sp1`
sp <- 
  diamonds %>% 
  ggplot(aes(x = carat, y = price))

sp + 
  geom_point()
```

We can make the points semitransparent using the `alpha` aesthetic, as in Figure
\@ref(fig:FIG-SCATTER-OVERPLOT-ALPHA). Here, we'll make them 90% transparent and
then 99% transparent, by setting `alpha = .1` and `alpha = .01`:

```{r FIG-SCATTER-OVERPLOT-ALPHA, dev="png", dpi=300, fig.show="hold", fig.cap="Semitransparent points with alpha=.1 (left); With alpha=.01 (right)", fig.height=3}
sp + 
  geom_point(alpha = .1)

sp + 
  geom_point(alpha = .01)
```

Now we can see that there appear to be vertical bands at nice round values of
carats, indicating that diamonds tend to be cut to those sizes. Still, the data
is so dense that even when the points are 99% transparent, much of the graph
appears black and the data distribution is still somewhat obscured.

> **Note**
>
> For most graphs, vector formats (such as PDF, EPS, and SVG) result in smaller
output files than bitmap formats (such as TIFF and PNG). But in cases where
there are tens of thousands of points, vector output files can be very large and
slow to render -- the scatter plot here with 99% transparent points is 1.5 MB!
In these cases, high-resolution bitmaps will be smaller and faster to display on
computer screens. See Chapter \@ref(CHAPTER-OUTPUT) for more information.

Another solution is to *bin* the points into rectangles and map the density of
the points to the fill color of the rectangles, as shown in Figure
\@ref(fig:FIG-SCATTER-OVERPLOT-BIN2D). With the binned visualization, the
vertical bands are barely visible. The density of points in the lower-left
corner is much greater, which tells us that the vast majority of diamonds are
small and inexpensive.

By default, `stat_bin_2d()` divides the space into 30 groups in the *x* and *y*
directions, for a total of 900 bins. In the second version, we increase the
number of bins with `bins = 50`.

The default colors are somewhat difficult to distinguish because they don't vary
much in luminosity. In the second version we set the colors by using
`scale_fill_gradient()` and by specifying the low and high colors. By default,
the legend doesn't show an entry for the lowest values. This is because the
range of the color scale starts not from zero, but from the smallest nonzero
quantity in a bin -- probably 1, in this case. To make the legend show a zero
(as in Figure \@ref(fig:FIG-SCATTER-OVERPLOT-BIN2D), right), we can manually set
the range from 0 to the maximum, 6000, using limits (Figure
\@ref(fig:FIG-SCATTER-OVERPLOT-BIN2D), left):

(ref:cap-FIG-SCATTER-OVERPLOT-BIN2D) Binning data with `stat_bin2d()` (left);
With more bins, manually specified colors, and legend breaks (right)

```{r FIG-SCATTER-OVERPLOT-BIN2D, fig.show="hold", fig.cap="(ref:cap-FIG-SCATTER-OVERPLOT-BIN2D)", fig.width=3.5, fig.height=3.5}
sp + 
  stat_bin2d()

sp + 
  stat_bin2d(bins = 50) +
  scale_fill_gradient(low = "lightblue", high = "red", limits = c(0, 6000))
```

Another alternative is to bin the data into hexagons instead of rectangles, with
`stat_binhex()` (Figure \@ref(fig:FIG-SCATTER-OVERPLOT-BINHEX)). It works just
like `stat_bin2d()`. To use `stat_binhex()`, you must first install the hexbin
package, with the command `install.packages("hexbin")`:

(ref:cap-FIG-SCATTER-OVERPLOT-BINHEX) Binning data with `stat_binhex()` (left);
Cells outside of the range shown in grey (right)


```{r FIG-SCATTER-OVERPLOT-BINHEX, fig.show="hold", fig.cap="(ref:cap-FIG-SCATTER-OVERPLOT-BINHEX)", fig.width=3.5, fig.height=3.5}
library(hexbin) # Load the hexbin library to access stat_binhex()

sp + 
  stat_binhex() +
  scale_fill_gradient(low = "lightblue", high = "red", limits = c(0, 8000))

sp + 
  stat_binhex() +
  scale_fill_gradient(
    low = "lightblue", high = "red", limits = c(0, 6000),
    breaks = c(0, 250, 500, 1000, 2000, 4000, 6000)
    )
```

For both of these methods, if you manually specify the range and there is a bin
that falls outside that range because it has too many or too few points, that
bin will show up as grey rather than the color at the high or low end of the
range, as seen in the graph on the right in Figure
\@ref(fig:FIG-SCATTER-OVERPLOT-BINHEX).

Overplotting can also occur when the data is *discrete* on one or both axes, as
shown in Figure \@ref(fig:FIG-SCATTER-OVERPLOT-JITTER). In these cases, you can
randomly *jitter* the points with `position_jitter()`. By default the amount of
jitter is 40% of the resolution of the data in each direction, but these amounts
can be controlled with `width` and `height`:

```{r FIG-SCATTER-OVERPLOT-JITTER, fig.show="hold", fig.cap="Data with a discrete x variable (left); Jittered (middle); Jittered horizontally only (right)", fig.width=3.5, fig.height=3.5}

# We'll use the ChickWeight data set and create a base plot called `sp1`
sp1 <- 
  ChickWeight %>% 
  ggplot(aes(x = Time, y = weight))

sp1 + 
  geom_point()

sp1 + 
  geom_point(position = "jitter")  # Could also use geom_jitter(), which is equivalent

sp1 + 
  geom_point(position = position_jitter(width = .5, height = 0))
```

When the data has one discrete axis and one continuous axis, it might make sense
to use box plots, as shown in Figure \@ref(fig:FIG-SCATTER-OVERPLOT-BOXPLOT).
This will convey a different story than a standard scatter plot because a box
plot will obscure the *number* of data points at each location on the discrete
axis. This may be problematic in some cases, but desirable in others.

When we look at the `ChickWeight` data we know that we conceptually want to
treat `Time` as a discrete variable. However since `Time` is taken as a
numerical variable by default, ggplot doesn't know to group the data to form
each boxplot box. If you don't tell ggplot how to group the data, you get a
result like the graph on the right in Figure
\@ref(fig:FIG-SCATTER-OVERPLOT-BOXPLOT). To tell it how to group the data, use
`aes(group = ...)`. In this case, we'll group by each distinct value of `Time`:

```{r FIG-SCATTER-OVERPLOT-BOXPLOT, fig.show="hold", fig.cap="Grouping into box plots (left); What happens if you don't specify groups (right)", fig.width=3.5, fig.height=3.5}
sp1 + 
  geom_boxplot(aes(group = Time))

sp1 + 
  geom_boxplot() # Without groups
```


### See Also

Instead of binning the data, it may be useful to display a 2D density estimate.
To do this, see Recipe \@ref(RECIPE-DISTRIBUTION-DENSITY2D).


Adding Fitted Regression Model Lines {#RECIPE-SCATTER-FITLINES}
------------------------------------

### Problem

You want to add lines from a fitted regression model to a scatter plot.

### Solution

To add a linear regression line to a scatter plot, add `stat_smooth()` and tell
it to use `method = lm`. This instructs ggplot to fit the data with the `lm()`
(linear model) function. First we'll save the base plot object in `sp`, then
we'll add different components to it:

```{r, eval=FALSE}
library(gcookbook) # Load the gcookbook package to access the heightweight data set 

# We'll use the heightweight data set and create a base plot called `sp`
sp <- 
  heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn))

sp + 
  geom_point() + 
  stat_smooth(method = lm)
```

By default, `stat_smooth()` also adds a 95% confidence region for the regression
fit. The confidence interval can be changed by modifying the value for `level`,
or it can be disabled with `se = FALSE` (Figure \@ref(fig:FIG-SCATTER-FIT-LM)):

```{r, eval=FALSE}
# 99% confidence region
sp + 
  geom_point() + 
  stat_smooth(method = lm, level = 0.99)

# No confidence region
sp + 
  geom_point() + 
  stat_smooth(method = lm, se = FALSE)
```

The default color of the fit line is blue. This can be change by setting
`colour`. As with any other line, the attributes `linetype` and `size` can also
be set. To emphasize the line, you can make the dots less prominent by changing
the `colour` of the points (Figure \@ref(fig:FIG-SCATTER-FIT-LM), bottom right):

```{r, eval=FALSE}
sp + 
  geom_point(colour = "grey60") +
  stat_smooth(method = lm, se = FALSE, colour = "black")
```

```{r FIG-SCATTER-FIT-LM, echo=FALSE, fig.show="hold", fig.cap="An lm fit with the default 95% confidence region (top left); A 99% confidence region (top right); No confidence region (bottom left); In black with grey points (bottom right)", fig.width=3.5, fig.height=3.5}

library(gcookbook) # Load the gcookbook package to access the heightweight data set 

# We'll use the heightweight data set and create a base plot called `sp`
sp <- 
  heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn))

sp + 
  geom_point() + 
  stat_smooth(method = lm)

sp + 
  geom_point() + 
  stat_smooth(method = lm, level = 0.99)

sp + 
  geom_point() + 
  stat_smooth(method = lm, se = FALSE)

sp + 
  geom_point(colour = "grey60") +
  stat_smooth(method = lm, se = FALSE, colour = "black")
```

### Discussion

The linear regression line is not the only way of fitting a model to the data --
in fact, it's not even the default. If you add `stat_smooth()` without
specifying the method, it will use a LOESS (locally weighted polynomial) curve
by default, as shown in Figure \@ref(fig:FIG-SCATTER-FIT-LOESS):

```{r, eval=FALSE}
sp + 
  geom_point(colour = "grey60") + 
  stat_smooth()

# Equivalent to:
sp + 
  geom_point(colour = "grey60") + 
  stat_smooth(method = loess)
```

```{r FIG-SCATTER-FIT-LOESS, echo=FALSE, fig.cap="A LOESS fit"}
sp + 
  geom_point(colour = "grey60") + 
  stat_smooth(method = loess)
```

It may be useful to specify additional parameters for the modeling function,
which in this case is `loess()`. If, for example, you wanted to use
`loess(degree=1)`, you would call 
`stat_smooth(method=loess, method.args=list(degree=1))`. The same could be done
for other modeling functions like `lm()` or `glm()`.

Another common type of model fit is a logistic regression. Logistic regression
isn't appropriate for `heightweight`, but it's perfect for the `biopsy` data set
in the `MASS` package. In the `biopsy` data, there are nine different measured
attributes of breast cancer biopsies, as well as the class of the tumor, which
is either benign or malignant. To prepare the data for logistic regression, we
must convert the factor `class`, with the levels `benign` and `malignant`, to a
vector with numeric values of 0 and 1. We'll make a copy of the `biopsy` data
frame, then store the numeric coded `class` in a column called `classn`:

```{r}
library(MASS) # Load the MASS package to access the biopsy data set 

# Using the biopsy data set, create a new column that stores the factor `class`
# as a numeric variable named `classn`. If `class` == "benign", set `classn` to
# 0. If `class` == "malignant", set `classn` to 1. Save this new dataset as `b`.

b <- 
  biopsy %>% 
  mutate(
    classn = ifelse(class == "benign", 0, ifelse(class == "malignant", 1, NA))
    )

b
```

Although there are many attributes we could examine, for this example we'll just
look at the relationship of `V1` (clump thickness) and the `class` of the tumor.
Because there is a large degree of overplotting, we'll jitter the points and
make them semitransparent (`alpha=0.4`), hollow (`shape=21`), and slightly
smaller (`size=1.5`). Then we'll add a fitted logistic regression line (Figure
\@ref(fig:FIG-SCATTER-FIT-LOGISTIC)) by telling `stat_smooth()` to use the
`glm()` function with `family=binomial`:

```{r FIG-SCATTER-FIT-LOGISTIC, fig.cap="A logistic model"}
b %>% 
  ggplot(aes(x = V1, y = classn)) +
  geom_point(
    position = position_jitter(width = 0.3, height = 0.06), 
    alpha = 0.4,
    shape = 21, 
    size = 1.5
    ) +
    stat_smooth(method = glm, method.args = list(family = binomial))
```

If your scatter plot has points grouped by a factor, and that factor is mapped
to an aesthetic such as `colour` or `shape`, one fit line will be drawn for each
factor level. First we'll make the base plot object `sps`, then we'll add the
LOESS lines to it. We'll also make the points less prominent by making them
semitransparent, using `alpha=.4` (Figure \@ref(fig:FIG-SCATTER-FIT-GROUP)):

```{r, eval=FALSE}
sps <- 
  heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, colour = sex)) +
  geom_point() +
  scale_colour_brewer(palette = "Set1")

sps + 
  geom_smooth()
```

Notice that the blue line, for males, doesn't run all the way to the right side
of the graph. There are two reasons for this. The first is that by default,
`stat_smooth()` limits the prediction to within the range of the predictor data
on the x-axis. The second is that even if it extrapolates, the `loess()`
function only offers prediction within the *x* range of the data.

If you want the lines to extrapolate from the data, as shown in the right-hand
image of Figure \@ref(fig:FIG-SCATTER-FIT-GROUP), you must use a model method
that allows extrapolation, like `lm()`, and pass `stat_smooth()` the option
`fullrange=TRUE`:

```{r, eval=FALSE}
sps + 
  geom_smooth(method = lm, se = FALSE, fullrange = TRUE)
```

```{r FIG-SCATTER-FIT-GROUP, fig.show="hold", fig.cap="LOESS fit lines for each group (left); Extrapolated linear fit lines (right)", fig.width=3.5, fig.height=3.5}

sps <- 
  heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, colour = sex)) +
  geom_point() +
  scale_colour_brewer(palette = "Set1")

sps + 
  geom_smooth()

sps + 
  geom_smooth(method = lm, se = FALSE, fullrange = TRUE)
```

In this example with the `heightweight` data set, the default settings for
`stat_smooth()` (with `loess` and no extrapolation) may make more sense than the
extrapolated linear predictions, because humans don't grow linearly and we don't
grow forever.

> TODO: Explain `geom_smooth` vs. `stat_smooth`.


Adding Fitted Lines from an Existing Model {#RECIPE-SCATTER-FITLINES-MODEL}
------------------------------------------

### Problem

You have already created a fitted regression model object for a data set, and
you want to plot the lines for that model.

### Solution

Usually the easiest way to overlay a fitted model is to simply ask
`stat_smooth()` to do it for you, as described in Recipe
\@ref(RECIPE-SCATTER-FITLINES). Sometimes, however, you may want to create the
model yourself and then add it to your graph. This allows you to be sure that
the model you're using for other calculations is the same one that you see.

In this example, we'll build a quadratic model using `lm()` with `ageYear` as a
predictor of `heightIn`. Then we'll use the `predict()` function and find the
predicted values of `heightIn` across the range of values for the predictor,
`ageYear`:

```{r}
library(gcookbook) # Load the gcookbook package to access the heightweight data set 

model <- lm(heightIn ~ ageYear + I(ageYear^2), heightweight)
model

# Create a data frame with ageYear column, interpolating across range
xmin <- min(heightweight$ageYear)
xmax <- max(heightweight$ageYear)
predicted <- data.frame(ageYear = seq(xmin, xmax, length.out = 100))

# Calculate predicted values of heightIn
predicted$heightIn <- predict(model, predicted)
predicted
```

We can now plot the data points along with the values predicted from the model
(as you'll see in Figure \@ref(fig:FIG-SCATTER-FIT-MODEL)):

```{r eval=FALSE}
sp <- 
  heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn)) +
  geom_point(colour = "grey40")

sp + 
  geom_line(data = predicted, size = 1)
```

### Discussion

Any model object (e.g. `lm`) can be used, so long as it has a corresponding
`predict()` method. For example, `lm` has `predict.lm()`, loess has
`predict.loess()`, and so on. Adding lines from a model can be simplified by
using the function `predictvals()`, defined below. If you simply pass a model to
`predictvals()`, the function will do the work of finding the variable names and
the range of the predictor, and will return a data frame with predictor and
predicted values. That data frame can then be passed to `geom_line()` to draw
the fitted line, as we did earlier:

```{r}
# Given a model, predict values of yvar from xvar
# This function supports one predictor and one predicted variable
# xrange: If NULL, determine the x range from the model object. If a vector with
#   two numbers, use those as the min and max of the prediction range.
# samples: Number of samples across the x range.
# ...: Further arguments to be passed to predict()
predictvals <- function(model, xvar, yvar, xrange = NULL, samples = 100, ...) {

  # If xrange isn't passed in, determine xrange from the models.
  # Different ways of extracting the x range, depending on model type
  if (is.null(xrange)) {
    if (any(class(model) %in% c("lm", "glm")))
      xrange <- range(model$model[[xvar]])
    else if (any(class(model) %in% "loess"))
      xrange <- range(model$x)
  }

  newdata <- data.frame(x = seq(xrange[1], xrange[2], length.out = samples))
  names(newdata) <- xvar
  newdata[[yvar]] <- predict(model, newdata = newdata, ...)
  newdata
}
```

With the heightweight data set, we'll make a linear model with `lm()` and a
LOESS model with `loess()` (Figure \@ref(fig:FIG-SCATTER-FIT-MODEL)):

```{r}
modlinear <- lm(heightIn ~ ageYear, heightweight)
modloess  <- loess(heightIn ~ ageYear, heightweight)
```

Then we can call `predictvals()` on each model, and pass the resulting data
frames to `geom_line()`:

```{r, eval=FALSE}
lm_predicted    <- predictvals(modlinear, "ageYear", "heightIn")
loess_predicted <- predictvals(modloess, "ageYear", "heightIn")

sp + 
  geom_line(data = lm_predicted, colour = "red", size = .8) +
  geom_line(data = loess_predicted, colour = "blue", size = .8)
```

```{r FIG-SCATTER-FIT-MODEL, fig.show="hold", fig.cap="A quadratic prediction line from an lm object (left); Prediction lines from linear (in red) and LOESS (in blue) models (right)", fig.width=3.5, fig.height=3.5}

# From first block above
sp <- 
  heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn)) +
  geom_point(colour = "grey40")

sp + 
  geom_line(data = predicted, size = 1)

# From second block above
lm_predicted    <- predictvals(modlinear, "ageYear", "heightIn")
loess_predicted <- predictvals(modloess, "ageYear", "heightIn")

sp + 
  geom_line(data = lm_predicted, colour = "red", size = .8) +
  geom_line(data = loess_predicted, colour = "blue", size = .8)
```

For `glm` models use a nonlinear link function, you need to specify
`type="response"` to the `predictvals()` function. This is because the default
behavior of `glm` is to return predicted values in the scale of the linear
predictors, instead of in the scale of the response (*y*) variable.

To illustrate this, we'll use the `biopsy` data set from the `MASS` package. As
we did in Recipe \@ref(RECIPE-SCATTER-FITLINES), we'll use `V1` to predict
`class`. Since logistic regressions require numeric values from 0 to 1, we need
to convert the factor `class` to 0s and 1s:

```{r}
library(MASS) # Load the MASS package to access the biopsy data set 

# Using the biopsy data set, create a new column that stores the factor `class`
# as a numeric variable named `classn`. If `class` == "benign", set `classn` to
# 0. If `class` == "malignant", set `classn` to 1. Save this new dataset as `b`.

b <- 
  biopsy %>% 
  mutate(
    classn = ifelse(class == "benign", 0, ifelse(class == "malignant", 1, NA))
    )

b
```

Next, we'll perform the logistic regression:

```{r}
fitlogistic <- glm(classn ~ V1, b, family = binomial)
```

Finally, we'll make the graph with jittered points and the `fitlogistic` line.
We'll make the line in a shade of blue by specifying a color in RGB values, and
slightly thicker, with `size=1` (Figure
\@ref(fig:FIG-SCATTER-FIT-MODEL-LOGISTIC)):

```{r FIG-SCATTER-FIT-MODEL-LOGISTIC, fig.cap="A fitted logistic model"}
# Get predicted values
glm_predicted <- predictvals(fitlogistic, "V1", "classn", type = "response")

b %>% 
  ggplot(aes(x = V1, y = classn)) +
  geom_point(
    position = position_jitter(width = .3, height = .08), 
    alpha = 0.4,
    shape = 21, 
    size = 1.5
    ) +
  geom_line(data = glm_predicted, colour = "#1177FF", size = 1)
```


Adding Fitted Lines from Multiple Existing Models {#RECIPE-SCATTER-FITLINES-MODEL-MULTI}
-------------------------------------------------

### Problem

You have already created a fitted regression model object for a data set, and
you want to plot the lines for that model.

### Solution

Use the `predictvals()` function from the previous recipe along with `dlply()`
and `ldply()` from the `plyr` package.

With the `heightweight` data set, we'll make a linear model for each of the
levels of `sex`, and put those model objects in a list. The model building is
done with a function, `make_model()`, defined below. If you pass `make_model()`
a data frame, the function will return an lm object. The model can be customized
for your data.

```{r}
make_model <- function(data) {
    lm(heightIn ~ ageYear, data)
}
```

With this function, we can use the `dlply()` function to build a model for each
subset of data. This will split the data frame into subsets by the grouping
variable `sex`, and apply `make_model()` to each subset. In this case, the
`heightweight` data will be split into two data frames, one for males and one
for females, and `make_model()` will be run on each subset. With `dlply()`, the
models are put into a list and the list is returned:

```{r}
library(gcookbook) # Load the gcookbook package to access the heightweight data set 
library(dplyr)

# Create a lm for each value of sex; this returns a data frame
models <- 
  heightweight %>%
  group_by(sex) %>%
  do(model = lm(heightIn ~ ageYear, .)) %>%
  ungroup()

# Print the data frame
models

# Print out the model column of the data frame
models$model
```

Now that we have the list of model objects, we can run the `predictvals()`
defined in \@ref(RECIPE-SCATTER-FITLINES-MODEL) to get predicted values from
each model, using the `ldply()` function:

```{r}
predvals <- 
  models %>%
  group_by(sex) %>%
  do(predictvals(.$model[[1]], xvar = "ageYear", yvar = "heightIn"))
```

Finally, we can plot the data with the predicted values (Figure
\@ref(fig:FIG-SCATTER-FIT-MODEL-MULTI)):

```{r eval=FALSE}
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, colour = sex)) +
  geom_point() +
  geom_line(data = predvals)
```

```{r FIG-SCATTER-FIT-MODEL-MULTI, fig.show="hold", fig.cap="Predictions from two separate lm objects, one for each subset of data (left); With facets (right)", fig.width=4, fig.height=3.5}
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, colour = sex)) +
  geom_point() +
  geom_line(data = predvals)

# Using facets instead of colors for the groups
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn)) +
  geom_point() +
  geom_line(data = predvals) +
  facet_grid(. ~ sex)
```

### Discussion

The `dlply()` and `ldply()` calls are used for splitting the data into parts,
running functions on those parts, and then reassembling the output.

With the preceding code, the *x* range of the predicted values for each group
spans the *x* range of each group, and no further; for the males, the prediction
line stops at the oldest male, while for females, the prediction line continues
further right, to the oldest female. To form prediction lines that have the same
*x* range across all groups, we can simply pass in `xrange`, like this:

```{r}
predvals <- 
  models %>%
  group_by(sex) %>%
  do(predictvals(
    .$model[[1]], 
    xvar = "ageYear", 
    yvar = "heightIn", 
    xrange = range(heightweight$ageYear))
    )
```

Then we can plot it, the same as we did before:

```{r FIG-SCATTER-FIT-MODEL-MULTI-RANGE, fig.cap="Predictions for each group extend to the full x range of all groups together"}
heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn, colour = sex)) +
  geom_point() +
  geom_line(data = predvals)
```

As you can see in Figure \@ref(fig:FIG-SCATTER-FIT-MODEL-MULTI-RANGE), the line
for males now extends as far to the right as the line for females. Keep in mind
that extrapolating past the data isn't always appropriate, though; whether or
not it's justified will depend on the nature of your data and the assumptions
you bring to the table.


Adding Annotations with Model Coefficients {#RECIPE-SCATTER-FITLINES-TEXT}
------------------------------------------

### Problem

You want to add numerical information about a model to a plot.

### Solution

To add simple text to a plot, simply add an annotation. In this example, we'll
create a linear model and use the `predictvals()` function defined in Recipe
\@ref(RECIPE-SCATTER-FITLINES-MODEL) to create a prediction line from the model.
Then we'll add an annotation:

```{r}
library(gcookbook) # Load the gcookbook package to access the heightweight data set 

model <- lm(heightIn ~ ageYear, heightweight)
summary(model)
```

This shows that the *r^2* value is 0.4249. We'll create a graph and manually add
the text using `annotate()` (Figure \@ref(fig:FIG-SCATTER-FIT-MODEL-TEXT)):

```{r eval=FALSE}
# First generate prediction data
pred <- predictvals(model, "ageYear", "heightIn")

sp <- 
  heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn)) + 
  geom_point() +
  geom_line(data = pred)

sp + 
  annotate("text", x = 16.5, y = 52, label = "r^2=0.42")
```

Instead of using a plain text string, it's also possible to enter formulas using
R's math expression syntax, by using `parse=TRUE`:

```{r eval=FALSE}
sp + 
  annotate("text", x = 16.5, y = 52, label = "r^2 == 0.42", parse = TRUE)
```


```{r FIG-SCATTER-FIT-MODEL-TEXT, echo=FALSE, fig.show="hold", fig.cap="Plain text (left); Math expression (right)", fig.width=3.5, fig.height=3.5}
pred <- predictvals(model, "ageYear", "heightIn")

sp <- 
  heightweight %>% 
  ggplot(aes(x = ageYear, y = heightIn)) + 
  geom_point() +
  geom_line(data = pred)

sp + 
  annotate("text", x = 16.5, y = 52, label = "r^2=0.42")

sp + 
  annotate("text", x = 16.5, y = 52, label = "r^2 == 0.42", parse = TRUE)
```

### Discussion

Text geoms in ggplot do not take expression objects directly; instead, they take
character strings that can be turned into expressions with R's `parse()`
function.

If you use a mathematical expression, the syntax must be correct for the
expression to be a valid R expression object. You can test the validity by
wrapping the object in the `expression()` function and seeing if it throws an
error (make sure *not* to use quotes around the expression). In the example
here, `==` is a valid construct in an expression to express equality, but `=` is
not:

```{r, eval=FALSE}
expression(r^2 == 0.42) # Valid
expression(r^2 = 0.42)  # Not valid
#> Error: unexpected '=' in "expression(r\^2 ="
```

It's possible to automatically extract values from the model object and build an
expression using those values. In this example, we'll create a string which when
parsed, yields a valid expression:

```{r}
# Use sprintf() to construct our string.
# The %.3g and %.2g are replaced with numbers with 3 significant digits and 2
# significant digits, respectively. The numbers are supplied after the string.

eqn <- 
  sprintf(
    "italic(y) == %.3g + %.3g * italic(x) * ',' ~~ italic(r)^2 ~ '=' ~ %.2g",
    coef(model)[1],
    coef(model)[2],
    summary(model)$r.squared
  )

eqn

# Test validity by using parse()
parse(text = eqn)
```

Now that we have the expression string, we can add it to the plot. In this
example we'll put the text in the bottom-right corner, by setting `x=Inf` and
`y=-Inf` and using horizontal and vertical adjustments so that the text all fits
inside the plotting area (Figure \@ref(fig:FIG-SCATTER-FIT-MODEL-TEXT-AUTO)):

```{r FIG-SCATTER-FIT-MODEL-TEXT-AUTO, fig.cap="Scatter plot with automatically generated expression"}
sp + 
  annotate(
    "text", 
    x = Inf, y = -Inf, 
    label = eqn, parse = TRUE, 
    hjust = 1.1, vjust = -.5
    )
```

### See Also

The math expression syntax in R can be a bit tricky. See Recipe
\@ref(RECIPE-ANNOTATE-TEXT-MATH) for more information.


Adding Marginal Rugs to a Scatter Plot {#RECIPE-SCATTER-RUG}
--------------------------------------

### Problem

You want to add marginal rugs to a scatter plot.

### Solution

Use `geom_rug()`. For this example (Figure \@ref(fig:FIG-SCATTER-RUG)), we'll
use the `faithful` data set. This data set has two columns with data about the
Old Faithful geyser: `eruptions`, which is the length of each eruption, and
`waiting`, which is the length of time until the next eruption:

```{r FIG-SCATTER-RUG, fig.cap="Marginal rug added to a scatter plot"}
faithful %>% 
  ggplot(aes(x = eruptions, y = waiting)) +
  geom_point() +
  geom_rug()
```

### Discussion

A marginal rug plot is essentially a one-dimensional scatter plot that can be
used to visualize the distribution of data on each axis.

In this particular data set, the marginal rug is not as informative as it could
be. The resolution of the `waiting` variable is in whole minutes, and because of
this, the rug lines have a lot of overplotting. To reduce overplotting, we
can jitter the line positions and make them slightly thinner by specifying size
(Figure \@ref(fig:FIG-SCATTER-RUG-JITTER)). This helps the viewer see the
distribution more clearly:

```{r FIG-SCATTER-RUG-JITTER, fig.cap="Marginal rug with thinner, jittered lines"}
faithful %>% 
  ggplot(aes(x = eruptions, y = waiting)) +
  geom_point() +
  geom_rug(position = "jitter", size = 0.2)
```

### See Also

For more about overplotting, see Recipe \@ref(RECIPE-SCATTER-OVERPLOT).


Labeling Points in a Scatter Plot {#RECIPE-SCATTER-LABELS}
---------------------------------

### Problem

You want to add labels to points in a scatter plot.

### Solution

For annotating just one or a few points, you can use `annotate()` or
`geom_text()`. For this example, we'll use the countries data set and visualize
the relationship between health expenditures and infant mortality rate per 1,000
live births. To keep things manageable, we'll filter the data to only look at
data from 2009 for a subset of countries that spent more than $2,000 USD per
capita:

```{r}
library(gcookbook) # Load the gcookbook package to access the countries data set 

# Filter the data to only look at 2009 data for countries that spent > 2000 USD per capita
countries %>% 
  filter(Year == 2009 & healthexp > 2000)
```

We'll save the basic scatter plot object in `sp` and add then add our
annotations to it. To manually add annotations, use `annotate()`, and specify
the coordinates and label (Figure \@ref(fig:FIG-SCATTER-LABEL), left). It may
require some trial-and-error tweaking to get the labels positioned just right:

```{r, eval=FALSE}
sp <-
  countries %>% 
  filter(Year == 2009, healthexp > 2000) %>% 
  ggplot(aes(x = healthexp, y = infmortality)) +
  geom_point()
         
sp + 
  annotate("text", x = 4350, y = 5.4, label = "Canada") +
  annotate("text", x = 7400, y = 6.8, label = "USA")
```

To automatically add the labels from your data (Figure
\@ref(fig:FIG-SCATTER-LABEL), right), use `geom_text()` and map a column that is
a factor or character vector to the label aesthetic. In this case, we'll use
`Name`, and we'll make the font slightly smaller to reduce crowding. The default
value for `size` is 5, which doesn't correspond directly to a point size:

```{r, eval=FALSE}
sp + 
  geom_text(aes(label = Name), size = 4)
```

```{r FIG-SCATTER-LABEL, echo=FALSE, fig.show="hold", fig.cap="A scatter plot with manually labeled points (left); With automatically labeled points and a smaller font (right)", fig.width=4.5, fig.height=4.5}

# First block
sp <-
  countries %>% 
  filter(Year == 2009, healthexp > 2000) %>% 
  ggplot(aes(x = healthexp, y = infmortality)) +
  geom_point()
         
sp + 
  annotate("text", x = 4350, y = 5.4, label = "Canada") +
  annotate("text", x = 7400, y = 6.8, label = "USA")

# Second block
sp + 
  geom_text(aes(label = Name), size = 3)
```

As you can see in the center of (Figure \@ref(fig:FIG-SCATTER-LABEL), right),
you may find yourself with a plot where labels are overlapping. To automatically
adjust point labels so that they don't overlap, we can use `geom_text_repel`
(Figure \@ref(fig:FIG-GGREPEL-LABEL), left) or `geom_label_repel` (which adds a
box around the label, Figure \@ref(fig:FIG-GGREPEL-LABEL), right) from the
ggrepel package by Kamil Slowikowski, which functions similarly to `geom_text`.
The documentation for these functions (e.g. ?`geom_text_repel`) specifies a long
list of other label features you can modify.

```{r FIG-GGREPEL-LABEL, fig.show="hold", fig.cap="A scatter plot labeled with geom_text_repel (left); Labeled with geom_label_repel (right)", fig.width=4.5, fig.height=4.5}

# Make sure to have installed the ggrepel package using install.packages()

sp + 
  ggrepel::geom_text_repel(aes(label = Name), size = 3)

sp + 
  ggrepel::geom_label_repel(aes(label = Name), size = 3)
```


### Discussion

The automatic method for placing annotations using `geom_text()` centers each
annotation on the *x* and *y* coordinates. You'll probably want to shift the
text vertically, horizontally, or both.

Setting `vjust=0` will make the baseline of the text on the same level as the
point (Figure \@ref(fig:FIG-SCATTER-LABEL-VJUST), left), and setting vjust=1
will make the top of the text level with the point. This usually isn't enough,
though -- you can increase or decrease `vjust` to shift the labels higher or
lower, or you can add or subtract a bit to or from the y mapping to get the same
effect (Figure \@ref(fig:FIG-SCATTER-LABEL-VJUST), right):

```{r FIG-SCATTER-LABEL-VJUST, fig.show="hold", fig.cap="A scatter plot with vjust=0 (left); With a little extra added to y (right)", fig.width=4.5, fig.height=4.5}
sp + 
  geom_text(aes(label = Name), size = 3, vjust = 0)

# Add a little extra to y
sp + 
  geom_text(aes(y = infmortality + .1, label = Name), size = 3)
```

It often makes sense to right- or left-justify the labels relative to the
points. To left-justify, set `hjust=0` (Figure
\@ref(fig:FIG-SCATTER-LABEL-HJUST), left), and to right-justify, set `hjust=1`.
As was the case with `vjust`, the labels will still slightly overlap with the
points. This time, though, it's not a good idea to try to fix it by increasing
or decreasing `hjust`. Doing so will shift the labels a distance proportional to
the length of the label, making longer labels move further than shorter ones.
It's better to just set hjust to 0 or 1, and then add or subtract a bit to or
from `x` (Figure \@ref(fig:FIG-SCATTER-LABEL-HJUST), right):

```{r FIG-SCATTER-LABEL-HJUST, fig.show="hold", fig.cap="A scatter plot with hjust=0 (left); With a little extra added to x (right)", fig.width=4.5, fig.height=4.5}
sp + 
  geom_text(aes(label = Name), size = 3, hjust = 0)

sp + 
  geom_text(aes(x = healthexp + 100, label = Name), size = 3, hjust = 0)
```

> **Note**
>
> If you are using a logarithmic axis, instead of adding to x or y, you'll need
to *multiply* the x or y value by a number to shift the labels a consistent
amount.

If you want to label just some of the points but want the placement to be
handled automatically, you can add a new column to your data frame containing
just the labels you want. Here's one way to do that: first we'll make a copy of
the data we're using, then we'll copy the `Name` column into `plotname`, converting
from a factor to a character vector, for reasons we'll see below.

```{r}
cdat <-   
  countries %>% 
  filter(Year == 2009, healthexp > 2000) %>% 
  mutate(plotname = as.character(Name))
```

Now that `plotname` is a character vector, we can use an `ifelse()` function and
the `%in%` operator to identify if each row of `plotname` matches the list of
names we want to show on our plot, which we have specified manually below. The
`%in%` operator returns a logical vector that allows us to specify within the
`ifelse()` function that we want to replace all values of `plotname` that do not
match one of our specified names with a blank string.

```{r}
countrylist <- 
  c("Canada", "Ireland", "United Kingdom", "United States", "New Zealand", 
    "Iceland", "Japan", "Luxembourg", "Netherlands", "Switzerland")

cdat <-
  cdat %>% 
  mutate(plotname = ifelse(plotname %in% countrylist, plotname, ""))

# Take a look at the resulting `plotname` variable, as compared to the original `Name` variable
cdat %>% select(Name, plotname)
```

TODO: Print first 2 and last 3 rows of data. via chunk option?

Now we can make the plot (Figure \@ref(fig:FIG-SCATTER-LABEL-SELECT)). This
time, we'll also expand the *x* range so that the text will fit:

```{r FIG-SCATTER-LABEL-SELECT, fig.cap="Scatter plot with selected labels and expanded x range"}
cdat %>% 
  ggplot(aes(x = healthexp, y = infmortality)) +
  geom_point() +
  geom_text(aes(x = healthexp + 100, label = plotname), size = 4, hjust = 0) +
  xlim(2000, 10000)
```

If any individual position adjustments are needed, you have a couple of options.
One option is to copy the columns used for the *x* and *y* coordinates and
modify the numbers for the individual items to move the text around. Make sure
to use the original numbers for the coordinates of the points, of course!
Another option is to save the output to a vector format such as PDF or SVG (see
Recipes Recipe \@ref(RECIPE-OUTPUT-VECTOR) and Recipe
\@ref(RECIPE-OUTPUT-VECTOR-SVG)), then edit it in a program like Illustrator or
Inkscape.

### See Also

For more on controlling the appearance of the text, see Recipe
\@ref(RECIPE-APPEARANCE-TEXT-APPEARANCE).

If you want to manually edit a PDF or SVG file, see Recipe
\@ref(RECIPE-OUTPUT-EDIT-VECTOR).


Creating a Balloon Plot {#RECIPE-SCATTER-BALLOON}
-----------------------

### Problem

You want to make a balloon plot, where the area of the dots is proportional to
their numerical value.

### Solution

TODO: Check if the content from size/color recipe should be moved here.

Use `geom_point()` with `scale_size_area()`. For this example, we'll filter the
data set `countries` to only include data from the year 2009, for certain
countries we have specified in `countrylist`:

```{r}
library(gcookbook) # Load the gcookbook package to access the countries data set 

countrylist <- 
  c("Canada", "Ireland", "United Kingdom", "United States", "New Zealand", 
    "Iceland", "Japan", "Luxembourg", "Netherlands", "Switzerland")

cdat <-
  countries %>% 
  filter(Year == 2009, Name %in% countrylist)

cdat
```

If we just map `GDP` to `size`, the value of `GDP` gets mapped to the *radius*
of the dots (Figure \@ref(fig:FIG-SCATTER-BALLOON), left), which is not what we
want; a doubling of value results in a quadrupling of area, and this will
distort the interpretation of the data. We instead want to map the value of
`GDP` to the *area* of the dots, which we can do this using `scale_size_area()`
(Figure \@ref(fig:FIG-SCATTER-BALLOON), right):

```{r FIG-SCATTER-BALLOON, fig.show="hold", fig.cap="Balloon plot with value mapped to radius (left); With value mapped to area (right)", fig.width=4.5, fig.height=3.5}
p <- 
  cdat %>% 
  ggplot(aes(x = healthexp, y = infmortality, size = GDP)) +
  geom_point(shape = 21, colour = "black", fill = "cornsilk")

# GDP mapped to radius (default with scale_size_continuous)
p

# GDP mapped to area instead, and larger circles
p + 
  scale_size_area(max_size = 15)
```

### Discussion

The example here is a scatter plot, but that is not the only way to use balloon
plots. It may also be useful to use balloon plots to represent values on a grid,
where the x- and y-axes are categorical, as in Figure
\@ref(fig:FIG-SCATTER-BALLOON-CAT):


```{r FIG-SCATTER-BALLOON-CAT, fig.show="hold", fig.cap="Balloon plot with categorical axes and text labels. Qith guide points to help position text (left); Without guide points (right)", fig.width=4.5, fig.height=4.5}

# Create a data frame that adds up counts for males and females
hec <- 
  HairEyeColor %>% 
# Convert to long format
  as.tibble() %>% 
  group_by(Hair, Eye) %>% 
  summarize(count = sum(n)) 

# Creating the base balloon plot
hecplot <- 
  hec %>% 
  ggplot(aes(x = Eye, y = Hair)) +
  geom_point(aes(size = count), shape = 21, colour = "black", fill = "cornsilk") +
  scale_size_area(max_size = 20, guide = FALSE) +
  geom_text(aes(
    y = as.numeric(as.factor(Hair)) - sqrt(count)/34, label = count), 
    vjust = 1.3,
    colour = "grey60", 
    size = 4
  )

hecplot

# Adding red guide points
hecplot +
  geom_point(aes(y = as.numeric(Hair) - sqrt(count)/34), colour = "red", size = 1) 
```

In this example we've used a few tricks to add the text labels under the
circles. First, we used `vjust=1.3` to justify the top of text slightly below
the *y* coordinate. Next, we wanted to set the *y* coordinate so that it is at
the bottom of each circle. This requires a little wrangling and arithmetic: we
need to first convert the levels of `Hair` and `Eye` into numeric values, which
involves converting these variables from being a character vector to being a
factor variable, and then converting them again into a numeric variable. We then
take the *numeric* value of `Hair` and subtract a small value from it, where the
value depends in some way on count. This actually requires taking the square
root of count, since the radius has a linear relationship with the square root
of `count`. The number that this value is divided by (34 in this case) is found
by trial and error; it depends on the particular data values, radius, text size,
and output image size.

To help find the correct *y* offset, we can add guide points in red and adjusted
the value until they lined up with the bottom of each circle. Once we have the
correct value, we can place the text and remove the points.

The text under the circles is in a shade of grey. This is so that it doesn't
jump out at the viewer and overwhelm the perceptual impact of the circles, but
is still available if the viewer wants to know the exact values.

### See Also

To add labels to the circles, see Recipes Recipe \@ref(RECIPE-SCATTER-LABELS)
and Recipe \@ref(RECIPE-ANNOTATE-TEXT).

See Recipe \@ref(RECIPE-SCATTER-CONTINUOUS-SCATTER) for ways of mapping
variables to other aesthetics in a scatter plot.


Making a Scatter Plot Matrix {#RECIPE-SCATTER-SPLOM}
----------------------------

### Problem

You want to make a scatter plot matrix.

### Solution

A scatter plot matrix is an excellent way of visualizing the pairwise
relationships among several variables. To make one, use the `pairs()` function
from R's base graphics.

For this example, we'll use a subset of the `countries` data. We'll pull out the
data for the year 2009, and keep only the columns that are relevant:

```{r}
library(gcookbook) # Load the gcookbook package to access the countries data set 

c2009 <- 
  countries %>% 
  filter(Year == 2009) %>% 
  select(Name, GDP, laborrate, healthexp, infmortality)

c2009
```

To make the scatter plot matrix (Figure \@ref(fig:FIG-SCATTER-SPLOM)), we'll use
all of the variables except for `Name`, since making a scatter plot matrix using
the names of the countries wouldn't make sense and  would produce
strange-looking results:

```{r FIG-SCATTER-SPLOM, fig.cap="A scatter plot matrix", fig.width=7, fig.height=7}
c2009 %>% 
  select(-Name) %>% 
  pairs()
```

### Discussion

We didn't use ggplot here because it doesn't make scatter plot matrices (at
least, not well). 

> TODO: look more into ggally?
> Instead, you may want to use the `ggpairs()` function from the `GGally` package. 
> Not sure why this doesn't work: 
> c2009 %>% 
>  as.tibble() %>% 
>  select(-Name) %>% 
>  GGally::ggpairs()

You can also use customized functions for the panels. To show the correlation
coefficient of each pair of variables instead of a scatter plot, we'll define
the function `panel.cor`. This will also show higher correlations in a larger
font. Don't worry about the details for now -- just paste this code into your R
session or script:

```{r}
panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...) {
    usr <- par("usr")
    on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r <- abs(cor(x, y, use = "complete.obs"))
    txt <- format(c(r, 0.123456789), digits = digits)[1]
    txt <- paste(prefix, txt, sep = "")
    if (missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
    text(0.5, 0.5, txt, cex =  cex.cor * (1 + r) / 2)
}
```

To show histograms of each variable along the diagonal, we'll define
`panel.hist`:

```{r}
panel.hist <- function(x, ...) {
    usr <- par("usr")
    on.exit(par(usr))
    par(usr = c(usr[1:2], 0, 1.5) )
    h <- hist(x, plot = FALSE)
    breaks <- h$breaks
    nB <- length(breaks)
    y <- h$counts
    y <- y/max(y)
    rect(breaks[-nB], 0, breaks[-1], y, col = "white", ...)
}
```

Both of these panel functions are taken from the `pairs()` help page, so if it's
more convenient, you can simply open that help page, then copy and paste. The
last line of this version of the `panel.cor` function is slightly modified,
however, so that the changes in font size aren't as extreme as with the
original.

Now that we've defined these functions we can use them for our scatter plot
matrix, by telling `pairs()` to use `panel.cor` for the upper panels and
`panel.hist` for the diagonal panels.

We'll also throw in one more thing: `panel.smooth` for the lower panels, which
makes a scatter plot and adds a LOWESS smoothed line, as shown in Figure
\@ref(fig:FIG-SCATTER-SPLOM-PANELS). (LOWESS is slightly different from LOESS,
which we saw in Recipe \@ref(RECIPE-SCATTER-FITLINES), but the differences
aren't important for this sort of rough exploratory visualization):

```{r FIG-SCATTER-SPLOM-PANELS, fig.cap="Scatter plot with correlations in the upper triangle, smoothing lines in the lower triangle, and histograms on the diagonal", fig.width=7, fig.height=7}
c2009 %>% 
  select(-Name) %>%  
  pairs(
    upper.panel = panel.cor,
    diag.panel  = panel.hist,
    lower.panel = panel.smooth
    )
```

It may be more desirable to use linear regression lines instead of LOWESS lines.
The `panel.lm()` function will do the trick (unlike the previous panel functions,
this one isn't in the pairs help page):

```{r}
panel.lm <- function (x, y, col = par("col"), bg = NA, pch = par("pch"),
                            cex = 1, col.smooth = "black", ...) {
    points(x, y, pch = pch, col = col, bg = bg, cex = cex)
    abline(stats::lm(y ~ x),  col = col.smooth, ...)
}
```

This time the default line color is black instead of red, though you can change
it here (and with `panel.smooth`) by setting `col.smooth` when you call
`pairs()`.

We'll also use small points in the visualization, so that we can distinguish
them a bit better (Figure \@ref(fig:FIG-SCATTER-SPLOM-PANELS2)). This is done by
setting `pch="."`:

```{r FIG-SCATTER-SPLOM-PANELS2, fig.cap="Scatter plot matrix with smaller points and linear fit lines", fig.width=7, fig.height=7}
c2009 %>% 
  select(-Name) %>%  
  pairs(
    upper.panel = panel.cor,
    diag.panel  = panel.hist,
    lower.panel = panel.smooth,
    pch = "."
    )
```

The size of the points can also be controlled using the `cex` parameter. The
default value for `cex` is 1; make it smaller for smaller points and larger for
larger points. Values below .5 might not render properly with PDF output.

### See Also

To create a correlation matrix, see Recipe \@ref(RECIPE-MISCGRAPH-CORRMATRIX).

The `ggpairs()` function from the `GGally` package can also make scatter plot
matrices.

<!--chapter:end:ch05.Rmd-->

---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
source("utils.R", local = TRUE)
```

Summarized Data Distributions {#CHAPTER-DISTRIBUTION}
=============================

This chapter explores how to visualize summarized distributions of data.

Making a Basic Histogram {#RECIPE-DISTRIBUTION-BASIC-HIST}
------------------------

### Problem

You want to make a histogram.

### Solution

Use `geom_histogram()` and map a continuous variable to x (Figure
\@ref(fig:FIG-DISTRIBUTION-HIST-BASIC)):

```{r FIG-DISTRIBUTION-HIST-BASIC, fig.cap="A basic histogram"}
faithful %>% 
  ggplot(aes(x = waiting)) + 
  geom_histogram()
```

### Discussion

All `geom_histogram()` requires is one column from a data frame or a single
vector of data. For this example we'll use the `faithful` data set, which
contains two columns with data about the Old Faithful geyser: `eruptions`, which
is the length of each eruption, and `waiting`, which is the length of time to
the next eruption. We'll only use the `waiting` variable in this example:

```{r}
faithful
```

If you just want to get a quick look at some data that isn't in a data frame,
you can get the same result by passing in NULL for the data frame and giving
`ggplot()` a vector of values. This would have the same result as the previous
code:

```{r eval=FALSE}
# Store the values in a simple vector
w <- faithful$waiting

ggplot(NULL, aes(x = w)) + 
  geom_histogram()
```

By default, the data is grouped into 30 bins. This number of bins is an
arbitrary default value, and may be too fine or too coarse for your data. You
can change the size of the bins by specifying the `binwidth`, or you can divide
the range of the data into a specific number of bins. 

In addition, the default colors -- a dark fill without an outline -- can make it
difficult to see which bar corresponds to which value, so we'll also change the
colors, as shown in Figure \@ref(fig:FIG-DISTRIBUTION-HIST-WIDTH).

```{r FIG-DISTRIBUTION-HIST-WIDTH, fig.show="hold", fig.cap="Histogram with binwidth = 5 and with different colors (left); With 15 bins (right)", fig.width=3.5, fig.height=3.5}

# Set the width of each bin to 5 (each bin will span 5 x-axis units)
faithful %>% 
  ggplot(aes(x = waiting)) +
  geom_histogram(binwidth = 5, fill = "white", colour = "black")

# Divide the x range into 15 bins
binsize <- diff(range(faithful$waiting))/15

faithful %>% 
  ggplot(aes(x = waiting)) +
  geom_histogram(binwidth = binsize, fill = "white", colour = "black")
```

Sometimes the appearance of the histogram will be very dependent on the width of
the bins and where the boundary points between the bins are. In Figure
\@ref(fig:FIG-DISTRIBUTION-HIST-BOUNDARY), we'll use a bin width of 8. In the
version on the left, we'll use the origin parameter to put boundaries at 31, 39,
47, etc., while in the version on the right, we'll shift it over by 4, putting
boundaries at 35, 43, 51, etc.:

```{r FIG-DISTRIBUTION-HIST-BOUNDARY, fig.show="hold", fig.cap="Different appearance of histograms with the origin at 31 and 35", fig.width=3.5, fig.height=3.5}

h <- 
  faithful %>% 
  ggplot(aes(x = waiting))  # Save a base ggplot object

h + 
  geom_histogram(binwidth = 8, fill = "white", colour = "black", boundary = 31)

h + 
  geom_histogram(binwidth = 8, fill = "white", colour = "black", boundary = 35)
```

The results look quite different, even though they have the same bin size. The
`faithful` data set is not particularly small, with 272 observations; with
smaller data sets, this can be even more of an issue. When visualizing your
data, it's a good idea to experiment with different bin sizes and boundary
points.

If your data has discrete values, it may matter that the histogram bins are
asymmetrical. They are *closed* on the lower bound and *open* on the upper
bound. If you have bin boundaries at 1, 2, 3, etc., then the bins will be [1,
2), [2, 3), and so on. In other words, the first bin contains 1 but not 2, and
the second bin contains 2 but not 3.

### See Also

Frequency polygons provide a better way of visualizing multiple distributions
without the bars interfering with each other. See Recipe
\@ref(RECIPE-DISTRIBUTION-FREQPOLY).


Making Multiple Histograms from Grouped Data {#RECIPE-DISTRIBUTION-MULTI-HIST}
--------------------------------------------

### Problem

You have grouped data and want to simultaneously make histograms for each data
group.

### Solution

Use `geom_histogram()` and use facets for each group, as shown in Figure
\@ref(fig:FIG-DISTRIBUTION-MULTI-HISTOGRAM-FACET):

```{r FIG-DISTRIBUTION-MULTI-HISTOGRAM-FACET, fig.cap="Two histograms with facets (left); With different facet labels (right)"}
library(MASS) # Load the MASS package to access the birthwt data set 

# Use smoke as the faceting variable
birthwt %>% 
  ggplot(aes(x = bwt)) + 
  geom_histogram(fill = "white", colour = "black") +
  facet_grid(smoke ~ .)
```

### Discussion

To make multiple histograms from grouped data, the data must all be in one data
frame, with one column containing a categorical variable used for grouping.

For this example, we used the `birthwt` data set. It contains data about birth
weights and a number of risk factors for low birth weight:

```{r}
birthwt
```

One problem with the faceted graph is that the facet labels are just 0 and 1,
and there's no label indicating that those values are for whether or not smoking
is a risk factor that is present. To change the labels, we need to change the
names of the factor levels. First we'll take a look at the factor levels, then
we'll assign new factor level names in the same order, and save this new data
set as `birthwt1`:

```{r}
library(forcats) # Load the forcats package to help you work with factor variables

birthwt1 <- 
  birthwt %>% 
  mutate(smoke = as.factor(smoke)) %>% # Convert smoke to a factor
  mutate(smoke = fct_recode(smoke, 'No Smoke' = "0", 'Smoke' = "1"))

```

Now when we plot our modified data frame, our desired labels appear (Figure
\@ref(fig:FIG-DISTRIBUTION-MULTI-HISTOGRAM-FACET-LABELS)).

```{r FIG-DISTRIBUTION-MULTI-HISTOGRAM-FACET-LABELS, fig.cap = "Histograms with new facet labels"}
birthwt1 %>% 
  ggplot(aes(x = bwt)) + 
  geom_histogram(fill = "white", colour = "black") +
  facet_grid(smoke ~ .)
```

With facets, the axes have the same *y* scaling in each facet. If your groups
have different sizes, it might be hard to compare the *shapes* of the
distributions of each one. For example, see what happens when we facet the birth
weights by `race` (Figure
\@ref(fig:FIG-DISTRIBUTION-MULTI-HISTOGRAM-FACET-SCALESFREE), left):

```{r FIG-DISTRIBUTION-MULTI-HISTOGRAM-FACET-SCALESFREE-1, eval=FALSE}
birthwt %>% 
  ggplot(aes(x = bwt)) + 
  geom_histogram(fill = "white", colour = "black") +
  facet_grid(race ~ .)
```

To allow the *y* scales to be resized independently (Figure
\@ref(fig:FIG-DISTRIBUTION-MULTI-HISTOGRAM-FACET-SCALESFREE), right), use
`scales = "free"`. Note that this will only allow the *y* scales to be free --
the *x* scales will still be fixed because the histograms are aligned with
respect to that axis:

```{r FIG-DISTRIBUTION-MULTI-HISTOGRAM-FACET-SCALESFREE-2, eval=FALSE}
birthwt %>% 
  ggplot(aes(x = bwt)) + 
  geom_histogram(fill = "white", colour = "black") +
  facet_grid(race ~ ., scales = "free")
```

```{r FIG-DISTRIBUTION-MULTI-HISTOGRAM-FACET-SCALESFREE, ref.label=c("FIG-DISTRIBUTION-MULTI-HISTOGRAM-FACET-SCALESFREE-1", "FIG-DISTRIBUTION-MULTI-HISTOGRAM-FACET-SCALESFREE-2"), echo=FALSE, fig.show="hold", fig.cap='Left: histograms with the default fixed scales; right: with scales="free"', fig.width=3.5, fig.height=3.5}
```

Another approach is to map the grouping variable to `fill`, as shown in Figure
\@ref(fig:FIG-DISTRIBUTION-MULTI-HISTOGRAM-FILL). The grouping variable must be
a factor or a character vector. In the `birthwt` data set, the desired grouping
variable, `smoke`, is stored as a number, so well use the `birthwt1` data set we
created above, in which smoke is a factor:

```{r FIG-DISTRIBUTION-MULTI-HISTOGRAM-FILL, fig.cap="Multiple histograms with different fill colors"}
# Map smoke to fill, make the bars NOT stacked, and make them semitransparent

birthwt1 %>% 
  ggplot(aes(x = bwt, fill = smoke)) +
  geom_histogram(position = "identity", alpha = 0.4)
```

Specifying `position = "identity"` is important. Without it, ggplot will stack
the histogram bars on top of each other vertically, making it much more
difficult to see the distribution of each group.


Making a Density Curve {#RECIPE-DISTRIBUTION-BASIC-DENSITY}
----------------------

### Problem

You want to make a kernel density estimate curve.

### Solution

Use `geom_density()` and map a continuous variable to x (Figure
\@ref(fig:FIG-DISTRIBUTION-DENSITY-BASIC)):

```{r FIG-DISTRIBUTION-DENSITY-BASIC-1, eval=FALSE}
faithful %>% 
  ggplot(aes(x = waiting)) + 
  geom_density()
```

If you don't like the lines along the side and bottom, you can use
`geom_line(stat = "density")` (see Figure
\@ref(fig:FIG-DISTRIBUTION-DENSITY-BASIC), right):

```{r FIG-DISTRIBUTION-DENSITY-BASIC-2, eval=FALSE}
# expand_limits() increases the y range to include the value 0
faithful %>% 
  ggplot(aes(x = waiting)) + 
  geom_line(stat = "density") +
  expand_limits(y = 0)
```

(ref:cap-FIG-DISTRIBUTION-DENSITY-BASIC) Left: a kernel density estimate curve
with `geom_density()`; right: with `geom_line()`

```{r FIG-DISTRIBUTION-DENSITY-BASIC, ref.label=c("FIG-DISTRIBUTION-DENSITY-BASIC-1", "FIG-DISTRIBUTION-DENSITY-BASIC-2"), echo=FALSE, fig.show="hold", fig.cap="(ref:cap-FIG-DISTRIBUTION-DENSITY-BASIC)", fig.width=3.5, fig.height=3.5}
```

### Discussion

Like `geom_histogram()`, `geom_density()` requires just one column from a data
frame. For this example, well use the `faithful` data set, which contains two
columns of data about the Old Faithful geyser: `eruptions`, which is the length
of each eruption, and `waiting`, which is the length of time until the next
eruption. Well only use the `waiting` column in this example:

```{r}
faithful
```

The second method of using `geom_line(stat = "density")` tells `geom_line()` to
use the "density" statistical transformation. This is essentially the same as
the first method, using `geom_density()`, except the former draws it with a
closed polygon.

As with `geom_histogram()`, if you just want to get a quick look at data that
isn't in a data frame, you can get the same result by passing in `NULL` for the
data and giving ggplot a vector of values. This would have the same result
as the first solution:

```{r eval=FALSE}
# Store the values in a simple vector
w <- faithful$waiting

ggplot(NULL, aes(x = w)) + 
  geom_density()
```

A kernel density curve is an estimate of the population distribution, based on
the sample data. The amount of smoothing depends on the *kernel bandwidth*: the
larger the bandwidth, the more smoothing there is. The bandwidth can be set with
the `adjust` parameter, which has a default value of 1. Figure
\@ref(fig:FIG-DISTRIBUTION-DENSITY-ADJUST) shows what happens with a smaller and
larger value of `adjust`:

```{r FIG-DISTRIBUTION-DENSITY-ADJUST, fig.cap="Density curves with adjust set to .25 (red), default value of 1 (black), and 2 (blue)", fig.width=3.5, fig.height=3.5}
faithful %>% 
  ggplot(aes(x = waiting)) +
    geom_line(stat = "density") +
    geom_line(stat = "density", adjust = .25, colour = "red") +
    geom_line(stat = "density", adjust = 2, colour = "blue")
```

In this example, the *x* range is automatically set so that it contains the
data, but this results in the edge of the curve getting clipped. To show more of
the curve, set the *x* limits (Figure
\@ref(fig:FIG-DISTRIBUTION-DENSITY-WIDTH)). We'll also add an 80% transparent
fill, with `alpha = .2`:

(ref:cap-FIG-DISTRIBUTION-DENSITY-WIDTH) Left: density curve with wider x limits
and a semitransparent fill; right: in two parts, with `geom_density()` and
`geom_line()`

```{r FIG-DISTRIBUTION-DENSITY-WIDTH, fig.show="hold", fig.cap="(ref:cap-FIG-DISTRIBUTION-DENSITY-WIDTH)", fig.width=3.5, fig.height=3.5}
faithful %>% 
  ggplot(aes(x = waiting)) +
  geom_density(fill = "blue", alpha = .2) +
  xlim(35, 105)

# This draws a blue polygon with geom_density(), then adds a line on top
faithful %>% 
  ggplot(aes(x = waiting)) +
  geom_density(fill = "blue", alpha = .2, colour = NA) +
  xlim(35, 105) +
  geom_line(stat = "density")

```

If this edge-clipping happens with your data, it might mean that your curve is
too smooth. If the curve is much wider than your data, it might not be the
best model of your data, or it could be because you have a small data set.

To compare the theoretical and observed distributions of your data, you can
overlay the density curve with the histogram. Since the *y* values for the
density curve are small (the area under the curve always sums to 1), it would be
barely visible if you overlaid it on a histogram without any transformation. To
solve this problem, you can scale down the histogram to match the density curve
with the mapping `y = ..density..`. Here we'll add `geom_histogram()` first, and
then layer `geom_density()` on top (Figure
\@ref(fig:FIG-DISTRIBUTION-DENSITY-HIST)):

```{r FIG-DISTRIBUTION-DENSITY-HIST, fig.cap="Density curve overlaid on a histogram"}
faithful %>% 
  ggplot(aes(x = waiting, y = ..density..)) +
  geom_histogram(fill = "cornsilk", colour = "grey60", size = .2) +
  geom_density() +
  xlim(35, 105)
```

### See Also

See Recipe \@ref(RECIPE-DISTRIBUTION-VIOLIN) for information on violin plots,
which are another way of representing density curves and may be more appropriate
for comparing multiple distributions.


Making Multiple Density Curves from Grouped Data {#RECIPE-DISTRIBUTION-MULTI-DENSITY}
------------------------------------------------

### Problem

You want to make density curves of multiple groups of data.

### Solution

Use `geom_density()`, and map the grouping variable to an aesthetic like
`colour` or `fill`, as shown in Figure
\@ref(fig:FIG-DISTRIBUTION-MULTI-DENSITY). The grouping variable must be a
factor or a character vector. In the `birthwt` data set, the desired grouping
variable, `smoke`, is stored as a number, so we have to convert it to a factor
first, which we will store in a modified data set called `birthwt1`.

```{r FIG-DISTRIBUTION-MULTI-DENSITY, fig.show="hold", fig.cap="Left: different line colors for each group; right: different semitransparent fill colors for each group", fig.width=3.5, fig.height=3.5}

library(MASS) # Load the MASS package to access the birthwt data set

birthwt1 <- 
  birthwt %>% 
  mutate(smoke = as.factor(smoke)) # Convert smoke to a factor

# Map smoke to colour
birthwt1 %>% 
  ggplot(aes(x = bwt, colour = smoke)) + 
  geom_density()

# Map smoke to fill and make the fill semitransparent by setting alpha
birthwt1 %>% 
  ggplot(aes(x = bwt, fill = smoke)) + 
  geom_density(alpha = .3)
```

### Discussion

To make these plots, the data must all be in one data frame, with one column
containing a categorical variable used for grouping.

For this example, we used the `birthwt` data set. It contains data about birth
weights and a number of risk factors for low birth weight:

```{r}
birthwt
```

We looked at the relationship between `smoke` (smoking) and `bwt` (birth weight
in grams). The value of `smoke` is either 0 or 1, but since it's stored as a
numeric vector, ggplot doesn't know that it should be treated as a categorical
variable. To make it so ggplot knows to treat `smoke` as categorical, we can
either convert that column of the data frame to a factor, or tell ggplot to
treat it as a factor by using `factor(smoke)` inside of the `aes()` statement.
For these examples, we converted `smoke` to a factor.

Another method for visualizing the distributions is to use facets, as shown in
Figure \@ref(fig:FIG-DISTRIBUTION-MULTI-DENSITY-FACET). We can align the facets
vertically or horizontally. Here we'll align them vertically so that it's easy
to compare the two distributions:

```{r FIG-DISTRIBUTION-MULTI-DENSITY-FACET-1, eval=FALSE}
birthwt1 %>% 
  ggplot(aes(x = bwt)) + 
  geom_density() + 
  facet_grid(smoke ~ .)
```

One problem with the faceted graph is that the facet labels are just 0 and 1,
and there's no label indicating that those values are for smoke. To change the
labels, we need to change the names of the factor levels. First we'll take a
look at the factor levels, then we'll assign new factor level names:

```{r FIG-DISTRIBUTION-MULTI-DENSITY-FACET-2, eval=FALSE}
levels(birthwt1$smoke)

library(forcats) # Load the forcats package to help you work with factor variables

birthwt1 <- 
  birthwt %>% 
  mutate(smoke = as.factor(smoke)) %>% # Convert smoke to a factor
  mutate(smoke = fct_recode(smoke, 'No Smoke' = "0", 'Smoke' = "1"))
```

Now when we plot our modified data frame, our desired labels appear (Figure
\@ref(fig:FIG-DISTRIBUTION-MULTI-DENSITY-FACET), right):

```{r FIG-DISTRIBUTION-MULTI-DENSITY-FACET-3, eval=FALSE}
birthwt1 %>% 
  ggplot(aes(x = bwt)) + 
  geom_density() + 
  facet_grid(smoke ~ .)
```

```{r FIG-DISTRIBUTION-MULTI-DENSITY-FACET, ref.label=c("FIG-DISTRIBUTION-MULTI-DENSITY-FACET-1", "FIG-DISTRIBUTION-MULTI-DENSITY-FACET-2", "FIG-DISTRIBUTION-MULTI-DENSITY-FACET-3"), echo=FALSE, fig.show="hold", fig.cap="Left: density curves with facets; right: with different facet labels", fig.width=3.5, fig.height=3.5}
```

If you want to see the histograms along with the density curves, the best option
is to use facets, since other methods of visualizing both histograms in a single
graph can be difficult to interpret. To do this, map `y = ..density..`, so that
the histogram is scaled down to the height of the density curves. In this
example, we'll also make the histogram bars a little less prominent by changing
the colors (Figure \@ref(fig:FIG-DISTRIBUTION-MULTI-DENSITY-HIST)):

```{r FIG-DISTRIBUTION-MULTI-DENSITY-HIST, fig.cap="Density curves overlaid on histograms"}
birthwt1 %>% 
  ggplot(aes(x = bwt, y = ..density..)) +
  geom_histogram(binwidth = 200, fill = "cornsilk", colour = "grey60", size = .2) +
  geom_density() +
  facet_grid(smoke ~ .)
```


Making a Frequency Polygon {#RECIPE-DISTRIBUTION-FREQPOLY}
--------------------------

### Problem

You want to make a frequency polygon.

### Solution

Use geom_`freqpoly()` (Figure \@ref(fig:FIG-DISTRIBUTION-FREQPOLY)):

```{r FIG-DISTRIBUTION-FREQPOLY-1, eval=FALSE}
ggplot(faithful, aes(x=waiting)) + geom_freqpoly()
```

### Discussion

A frequency polygon appears similar to a kernel density estimate curve, but it
shows the same information as a histogram. That is, like a histogram, it shows
what is in the data, whereas a kernel density estimate is just that -- an
estimate -- and requires you to pick some value for the bandwidth.

Like with a histogram, you can control the bin width for the frequency polygon
(Figure \@ref(fig:FIG-DISTRIBUTION-FREQPOLY), right):

```{r FIG-DISTRIBUTION-FREQPOLY-2, eval=FALSE}
faithful %>% 
  ggplot(aes(x = waiting)) + 
  geom_freqpoly(binwidth = 4)
```

```{r FIG-DISTRIBUTION-FREQPOLY, ref.label=c("FIG-DISTRIBUTION-FREQPOLY-1", "FIG-DISTRIBUTION-FREQPOLY-2"), echo=FALSE, fig.show="hold", fig.cap="Left: a frequency polygon; right: with wider bins", fig.width=3.5, fig.height=3.5}
```

Or, instead of setting the width of each bin directly, you can divide the *x*
range into a particular number of bins:

```{r eval=FALSE}
# Divide the x-axis range into 15 bins
binsize <- diff(range(faithful$waiting))/15

faithful %>% 
  ggplot(aes(x = waiting)) + 
  geom_freqpoly(binwidth = binsize)
```


### See Also

Histograms display the same information, but with bars instead of lines. See
Recipe \@ref(RECIPE-DISTRIBUTION-BASIC-HIST).


Making a Basic Box Plot {#RECIPE-DISTRIBUTION-BASIC-BOXPLOT}
-----------------------

### Problem

You want to make a box (or box-and-whiskers) plot.

### Solution

Use `geom_boxplot()`, mapping a continuous variable to y and a discrete variable
to x (Figure \@ref(fig:FIG-DISTRIBUTION-BOXPLOT-BASIC)):

```{r FIG-DISTRIBUTION-BOXPLOT-BASIC, fig.cap="A box plot"}
library(MASS) # Load the MASS package to access the birthwt data set

# Use factor() to convert a numeric variable into a discrete variable
birthwt %>% 
  ggplot(aes(x = factor(race), y = bwt)) + 
  geom_boxplot()
```

### Discussion

For this example, we used the `birthwt` data set from the `MASS` package. This
data set contains data about birth weights (`bwt`) and a number of risk factors
for low birth weight:

```{r}
birthwt
```

In Figure \@ref(fig:FIG-DISTRIBUTION-BOXPLOT-BASIC) we have visualized the
distributions of `bwt` by each `race` group. Because `race` is stored as a
numeric vector with the values of 1, 2, or 3, ggplot doesn't know how to use
this numeric version of `race` as a grouping variable. To make this work, we can
modify the data frame by converting `race` to a factor, or by telling ggplot to
treat `race` as a factor by using `factor(race)` inside of the `aes()`
statement. In the preceding example, we used `factor(race)`.

A box plot consists of a box and "whiskers." The box goes from the 25th
percentile to the 75th percentile of the data, also known as the *inter-quartile
range* (IQR). There's a line indicating the median, or the 50th percentile of
the data. The whiskers start from the edge of the box and extend to the furthest
data point that is within 1.5 times the IQR. Any data points that are past the
ends of the whiskers are considered outliers and displayed with dots. Figure
\@ref(fig:FIG-DISTRIBUTION-BOXPLOT-DIAGRAM) shows the relationship between a
histogram, a density curve, and a box plot, using a skewed data set.

```{r FIG-DISTRIBUTION-BOXPLOT-DIAGRAM, echo=FALSE, fig.cap="Box plot compared to histogram and density curve", figh.width=7, fig.height=3, warning=FALSE}

set.seed(122)

# Generate skewed data
ds <- data.frame(x = rnorm(1000, mean = 10, sd = 2)^3)

min <- -500
max <- max(ds$x)

sumx <- summary(ds$x)
iqr  <- sumx[["3rd Qu."]] - sumx[["1st Qu."]]

p1 <-
  ds %>% 
  ggplot(aes(x = x)) + 
  geom_histogram(aes(y = ..count../140), binwidth = 200, colour = "grey80", fill = "cornsilk", alpha = .5) + 
  geom_density(aes(y = ..scaled..), adjust = 1.5, colour = "grey70") +
  geom_vline(aes(xintercept = sumx[["1st Qu."]]), colour = "grey50") +
  geom_vline(aes(xintercept = sumx[["3rd Qu."]]), colour = "grey50") +
  geom_vline(aes(xintercept = sumx[["Min."]]), colour = "grey50") +
  geom_vline(aes(xintercept = sumx[["3rd Qu."]] + 1.5 * iqr), colour = "grey50") +
  geom_vline(aes(xintercept = sumx[["Median"]]), colour = "grey50") +
  annotate(
    "text", x = sumx[["Min."]], y = 0, label = "Minimum", 
    angle = 90, vjust = -0.2, hjust = 0, size = 4
    ) +
  annotate(
    "text", x = sumx[["1st Qu."]], y = 0, label = "25th percentile", 
    angle = 90, vjust = -0.2, hjust = 0, size = 4
    ) +
  annotate(
    "text", x = sumx[["Median"]], y = 0,  label = "Median", 
    angle = 90, vjust = -0.2, hjust = 0, size = 4
    ) +
  annotate(
    "text", x = sumx[["3rd Qu."]], y = 0, label = "75th percentile", 
    angle = 90, vjust = -0.2, hjust = 0, size = 4
    ) +
  geom_segment(
    aes(x = sumx[["Min."]], xend = sumx[["1st Qu."]], y = .75, yend = .75), 
    size = .2, arrow = arrow(ends = "both", length = unit(0.2,"cm"))
    ) +
  annotate(
    "text", x = mean(c(sumx[["Min."]], sumx[["1st Qu."]])), y = .75, label = "To minimum", 
    vjust = -0.2, size = 4, lineheight = .8
    ) +
  geom_segment(
    aes(x = sumx[["1st Qu."]], xend = sumx[["3rd Qu."]], y = .85, yend = .85), 
    size = .2, arrow = arrow(ends = "both", length = unit(0.2,"cm"))
    ) +
  annotate(
    "text", x = mean(c(sumx[["1st Qu."]], sumx[["3rd Qu."]])), y = .85, label = "IQR",
    vjust = -0.2, size = 4
    ) +
  geom_segment(
    aes(x = sumx[["3rd Qu."]], xend = sumx[["3rd Qu."]] + 1.5 * iqr, y = .75, yend = .75),
    size = .2, arrow = arrow(ends = "both", length = unit(0.2,"cm"))
  ) +
  annotate(
    "text", x = sumx[["3rd Qu."]] + .75*iqr, y = .75, vjust = -0.2, size = 4, label = "1.5 x IQR"
  ) +
  theme_bw() +
  scale_x_continuous(breaks = NULL, limits = c(0,max(ds$x))) +
  scale_y_continuous(breaks = NULL) +
  theme(axis.title.x = element_blank()) +
  theme(axis.title.y = element_blank()) +
  theme(panel.border = element_rect(fill = NA, colour = NA)) +
  theme(plot.margin = unit(c(0,0,0,0), "lines"))

p2 <-
  df %>% 
  ggplot(aes(x = 1, y = x)) +
  geom_boxplot(width = .5, outlier.size = 1.5) +
  coord_flip() +
  theme_bw() +
  scale_x_continuous(breaks = NULL) +
  scale_y_continuous(breaks = NULL, limits = c(0,max(ds$x))) +
  theme(axis.title.x = element_blank()) +
  theme(axis.title.y = element_blank()) +
  theme(panel.border = element_rect(fill = NA, colour = NA)) +
  theme(plot.margin = unit(c(0,0,0,0), "lines"))

library(grid)
grid.newpage()
pushViewport(viewport(layout = grid.layout(4, 1)))
vplayout <- function(x, y)
  viewport(layout.pos.row = x, layout.pos.col = y)

print(p1, vp = vplayout(1:3, c(1,1,1)))
print(p2, vp = vplayout(4, 1))
```

To change the width of the boxes, you can set width (Figure
\@ref(fig:FIG-DISTRIBUTION-BOXPLOT-WIDTH-POINT), left):

```{r FIG-DISTRIBUTION-BOXPLOT-WIDTH-POINT-1, eval=FALSE}
birthwt %>% 
  ggplot(aes(x = factor(race), y = bwt)) + 
  geom_boxplot(width = .5)
```

If there are many outliers and there is overplotting, you can change the size
and shape of the outlier points with `outlier.size` and `outlier.shape`. The
default size is 2 and the default shape is 16. This will use smaller points, and
hollow circles (Figure \@ref(fig:FIG-DISTRIBUTION-BOXPLOT-WIDTH-POINT), right):

```{r FIG-DISTRIBUTION-BOXPLOT-WIDTH-POINT-2, eval=FALSE}
birthwt %>% 
  ggplot(aes(x = factor(race), y = bwt)) +
  geom_boxplot(outlier.size = 1.5, outlier.shape = 21)
```

```{r FIG-DISTRIBUTION-BOXPLOT-WIDTH-POINT, ref.label=c("FIG-DISTRIBUTION-BOXPLOT-WIDTH-POINT-1", "FIG-DISTRIBUTION-BOXPLOT-WIDTH-POINT-2"), echo=FALSE, fig.show="hold", fig.cap="Left: box plot with narrower boxes; right: with smaller, hollow outlier points", fig.width=3.5, fig.height=3.5}
```

To make a box plot of just a single group, we have to provide some arbitrary
value for x; otherwise, ggplot won't know what *x* coordinate to use for the box
plot. In this case, we'll set it to 1 and remove the x-axis tick markers and
label (Figure \@ref(fig:FIG-DISTRIBUTION-BOXPLOT-SINGLE)):

```{r FIG-DISTRIBUTION-BOXPLOT-SINGLE, fig.cap="Box plot of a single group", fig.width=3.5, fig.height=3.5}
birthwt %>% 
  ggplot(aes(x = 1, y = bwt)) + 
  geom_boxplot() +
  scale_x_continuous(breaks = NULL) +
  theme(axis.title.x = element_blank())
```

> **Note**
>
> The calculation of quantiles works slightly differently from the boxplot()
function in base R. This can sometimes be noticeable for small sample sizes. See
?geom_boxplot for detailed information about how the calculations differ.


Adding Notches to a Box Plot {#RECIPE-DISTRIBUTION-BOXPLOT-NOTCH}
----------------------------

### Problem

You want to add notches to a box plot to assess whether the medians are
different.

### Solution

Use `geom_boxplot()` and set `notch = TRUE` (Figure
\@ref(fig:FIG-DISTRIBUTION-BOXPLOT-NOTCH)):

```{r FIG-DISTRIBUTION-BOXPLOT-NOTCH, fig.cap="A notched box plot"}
library(MASS) # Load the MASS package to access the birthwt data set

birthwt %>% 
  ggplot(aes(x = factor(race), y = bwt)) + 
  geom_boxplot(notch = TRUE)
```

### Discussion

Notches are used in box plots to help visually assess whether the medians of
distributions differ. If the notches do not overlap, this is evidence that the
medians are different.

With this particular data set, you'll see the following message:

```
Notch went outside hinges. Try setting notch=FALSE.
```

This means that the confidence region (the notch) went past the bounds (or
hinges) of one of the boxes. In this case, the upper part of the notch in the
middle box goes just barely outside the box body, but it's by such a small
amount that you can't see it in the final output. There's nothing inherently
wrong with a notch going outside the hinges, but it can look strange in more
extreme cases.


Adding Means to a Box Plot {#RECIPE-DISTRIBUTION-BOXPLOT-MEAN}
--------------------------

### Problem

You want to add markers for the mean to a box plot.

### Solution

Use `stat_summary()`. The mean is often shown with a diamond, so we'll use shape
23 with a white fill. We'll also make the diamond slightly larger by setting
`size = 3` (Figure \@ref(fig:FIG-DISTRIBUTION-BOXPLOT-MEAN)):

```{r FIG-DISTRIBUTION-BOXPLOT-MEAN, fig.cap="Mean markers on a box plot"}
library(MASS) # Load the MASS package to access the birthwt data set

birthwt %>% 
  ggplot(aes(x = factor(race), y = bwt)) + 
  geom_boxplot() +
  stat_summary(fun.y = "mean", geom = "point", shape = 23, size = 3, fill = "white")
```

### Discussion

The horizontal line in the middle of a box plot displays the median, not the
mean. For data that is normally distributed, the median and mean will be about
the same, but for skewed data these values will differ.


Making a Violin Plot {#RECIPE-DISTRIBUTION-VIOLIN}
--------------------

### Problem

You want to make a violin plot to compare density estimates of different groups.

### Solution

Use `geom_violin()` (Figure \@ref(fig:FIG-DISTRIBUTION-VIOLIN-BASIC)):

```{r FIG-DISTRIBUTION-VIOLIN-BASIC, fig.cap="A violin plot"}
library(gcookbook) # Load the gcookbook package to access the heightweight data set 

# Create a base ggplot object using the heightweight data set
p <- 
  heightweight %>% 
  ggplot(aes(x = sex, y = heightIn))

p + 
  geom_violin()
```

### Discussion

Violin plots are a way of comparing multiple data distributions. With ordinary
density curves, it is difficult to compare more than just a few distributions
because the lines visually interfere with each other. With a violin plot, it's
easier to compare several distributions since they're placed side by side.

A violin plot is a kernel density estimate, mirrored so that it forms a
symmetrical shape. Traditionally, they also have narrow box plots overlaid, with
a white dot at the median, as shown in Figure
\@ref(fig:FIG-DISTRIBUTION-VIOLIN-BOXPLOT). Additionally, the box plot outliers
are not displayed, which we do by setting `outlier.colour = NA`:

```{r FIG-DISTRIBUTION-VIOLIN-BOXPLOT, fig.cap="A violin plot with box plot overlaid on it", fig.height=3.5, fig.width=3.5}
p + 
  geom_violin() + 
  geom_boxplot(width = .1, fill = "black", outlier.colour = NA) +
  stat_summary(fun.y = median, geom = "point", fill = "white", shape = 21, size = 2.5)
```

In this example we layered the objects from the bottom up, starting with the
violin, then the box plot, then the white dot at the median, which is calculated
using `stat_summary()`.

The default range goes from the minimum to maximum data values; the flat ends of
the violins are at the extremes of the data. It's possible to keep the tails, by
setting `trim = FALSE` (Figure \@ref(fig:FIG-DISTRIBUTION-VIOLIN-TAIL)):

```{r FIG-DISTRIBUTION-VIOLIN-TAIL, fig.cap="A violin plot with tails", fig.height=3.5, fig.width=3.5}
p + 
  geom_violin(trim = FALSE)
```

By default, the violins are scaled so that the total area of each one is the
same (if `trim = TRUE`, then it scales what the area *would be* including the
tails). Instead of equal areas, you can use `scale = "count"` to scale the areas
proportionally to the number of observations in each group (Figure
\@ref(fig:FIG-DISTRIBUTION-VIOLIN-SCALECOUNT)). In this example, there are
slightly fewer females than males, so the female violin is slightly narrower:

```{r FIG-DISTRIBUTION-VIOLIN-SCALECOUNT, fig.cap="Violin plot with area proportional to number of observations", fig.height=3.5, fig.width=3.5}

# Scaled area proportional to number of observations
p + 
  geom_violin(scale = "count")
```

To change the amount of smoothing, use the adjust parameter, as described in
Recipe \@ref(RECIPE-DISTRIBUTION-BASIC-DENSITY). The default value is 1; use
larger values for more smoothing and smaller values for less smoothing (Figure
\@ref(fig:FIG-DISTRIBUTION-VIOLIN-ADJUST)):

```{r FIG-DISTRIBUTION-VIOLIN-ADJUST, fig.show="hold", fig.cap="Left: violin plot with more smoothing; right: with less smoothing", fig.width=3.5, fig.height=3.5}

# More smoothing
p + 
  geom_violin(adjust = 2)

# Less smoothing
p + 
  geom_violin(adjust = .5)
```

### See Also

To create a traditional density curve, see Recipe
\@ref(RECIPE-DISTRIBUTION-BASIC-DENSITY).

To use different point shapes, see Recipe
\@ref(RECIPE-LINE-GRAPH-POINT-APPEARANCE).


Making a Dot Plot {#RECIPE-DISTRIBUTION-DOT-PLOT}
-----------------

### Problem

You want to make a Wilkinson dot plot, which shows each data point.

### Solution

Use `geom_dotplot()`. For this example (Figure
\@ref(fig:FIG-DISTRIBUTION-DOTPLOT-BASIC)), we'll use a subset of the
`countries` data set:

```{r FIG-DISTRIBUTION-DOTPLOT-BASIC, fig.cap="A dot plot"}
library(gcookbook)# Load the gcookbook package to access the countries data set 

# Save a modified data set that only includes 2009 data for countries that spent > 2000 USD per capita
countries2009 <- 
  countries %>% 
  filter(Year == 2009 & healthexp > 2000)

# Create a base ggplot object using our modified countries2009 data set
p <- 
  countries2009 %>% 
  ggplot(aes(x = infmortality))

p + 
  geom_dotplot()
```

### Discussion

This kind of dot plot is sometimes called a *Wilkinson* dot plot. It's different
from the Cleveland dot plots shown in Recipe \@ref(RECIPE-BAR-GRAPH-DOT-PLOT).
In these Wilkinson dot plots, the placement of the bins depends on the data, and
the width of each dot corresponds to the maximum width of each bin. The maximum
bin size defaults to 1/30 of the range of the data, but it can be changed with
binwidth.

By default, `geom_dotplot()` bins the data along the x-axis and stacks on the
y-axis. The dots are stacked visually, and due to technical limitations of
ggplot2, the resulting graph has y-axis tick marks that aren't meaningful. The
y-axis labels can be removed by using `scale_y_continuous()`. In this example,
we'll also use `geom_rug()` to show exactly where each data point is (Figure
\@ref(fig:FIG-DISTRIBUTION-DOTPLOT-NO-Y-RUG)):

```{r FIG-DISTRIBUTION-DOTPLOT-NO-Y-RUG, fig.cap="Dot plot with no y labels, max bin size of .25, and a rug showing each data point"}
p + 
  geom_dotplot(binwidth = .25) +
  geom_rug() +
  scale_y_continuous(breaks = NULL) +   # Remove tick markers
  theme(axis.title.y = element_blank()) # Remove axis label
```

You may notice that the stacks aren't regularly spaced in the horizontal
direction. With the default dotdensity binning algorithm, the position of each
stack is centered above the set of data points that it represents. To use bins
that are arranged with a fixed, regular spacing, like a histogram, use
`method = "histodot"`. In Figure \@ref(fig:FIG-DISTRIBUTION-DOTPLOT-HISTODOT),
you'll notice that the stacks *aren't* centered above the data:

```{r FIG-DISTRIBUTION-DOTPLOT-HISTODOT, fig.cap="Dot plot with histodot (fixed-width) binning"}
p + 
  geom_dotplot(method = "histodot", binwidth = .25) +
  geom_rug() +
  scale_y_continuous(breaks = NULL) +
  theme(axis.title.y = element_blank())
```

The dots can also be stacked centered, or centered in such a way that stacks
with even and odd quantities stay aligned. This can by done by setting
`stackdir = "center"` or `stackdir = "centerwhole"`, as illustrated in Figure
\@ref(fig:FIG-DISTRIBUTION-DOTPLOT-CENTER):

```{r FIG-DISTRIBUTION-DOTPLOT-CENTER, fig.show="hold", fig.cap='Left: dot plot with stackdir = "center"; right: with stackdir = "centerwhole"', fig.width=3.5, fig.height=3.5}
p + 
  geom_dotplot(binwidth = .25, stackdir = "center") +
  scale_y_continuous(breaks = NULL) +
  theme(axis.title.y = element_blank())

p + 
  geom_dotplot(binwidth = .25, stackdir = "centerwhole") +
  scale_y_continuous(breaks = NULL) +
  theme(axis.title.y = element_blank())
```

### See Also

Leland Wilkinson, "Dot Plots," *The American Statistician* 53 (1999): 276281,
<http://www.cs.uic.edu/~wilkinson/Publications/dots.pdf>.


Making Multiple Dot Plots for Grouped Data {#RECIPE-DISTRIBUTION-DOT-PLOT-MULTI}
------------------------------------------

### Problem

You want to make multiple dot plots from grouped data.

### Solution

To compare multiple groups, it's possible to stack the dots along the y-axis,
and group them along the x-axis, by setting `binaxis = "y"`. For this example,
we'll use the heightweight data set (Figure
\@ref(fig:FIG-DISTRIBUTION-DOTPLOT-MULTI)):

```{r FIG-DISTRIBUTION-DOTPLOT-MULTI, fig.cap="Dot plot of multiple groups, binning along the y-axis"}
library(gcookbook) # Load the gcookbook package to access the heightweight data set 

heightweight %>% 
  ggplot(aes(x = sex, y = heightIn)) +
  geom_dotplot(binaxis = "y", binwidth = .5, stackdir = "center")
```

### Discussion

Dot plots are sometimes overlaid on box plots. In these cases, it may be helpful
to make the dots hollow and have the box plots *not* show outliers, since the
outlier points will appear to be part of the dot plot (Figure
\@ref(fig:FIG-DISTRIBUTION-DOTPLOT-MULTI-BOXPLOT)):

```{r FIG-DISTRIBUTION-DOTPLOT-MULTI-BOXPLOT, fig.cap="Dot plot overlaid on box plot"}
heightweight %>% 
  ggplot(aes(x = sex, y = heightIn)) +
  geom_boxplot(outlier.colour = NA, width = .4) +
  geom_dotplot(binaxis = "y", binwidth = .5, stackdir = "center", fill = NA)
```

It's also possible to show the dot plots next to the box plots, as shown in
Figure \@ref(fig:FIG-DISTRIBUTION-DOTPLOT-MULTI-SIDE). This requires using a bit
of a hack, by treating the *x* variable as a numeric variable and then
subtracting or adding a small quantity to shift the box plots and dot plots left
and right. When the *x* variable is treated as numeric you must also specify the
group, or else the data will be treated as a single group, with just one box
plot and dot plot. Finally, since the x-axis is treated as numeric, it will by
default show numbers for the x-axis tick labels; they must be modified with
`scale_x_continuous()` to show *x* tick labels as text corresponding to the
factor levels:

```{r FIG-DISTRIBUTION-DOTPLOT-MULTI-SIDE, fig.cap="Dot plot next to box plot"}
heightweight %>% 
  ggplot(aes(x = sex, y = heightIn)) +
  geom_boxplot(aes(x = as.numeric(sex) + .2, group = sex), width = .25) +
  geom_dotplot(
    aes(x = as.numeric(sex) - .2, group = sex), 
    binaxis = "y", 
    binwidth = .5, 
    stackdir = "center"
    ) +
  scale_x_continuous(
    breaks = 1:nlevels(heightweight$sex), 
    labels = levels(heightweight$sex)
    )
```


Making a Density Plot of Two-Dimensional Data {#RECIPE-DISTRIBUTION-DENSITY2D}
---------------------------------------------

### Problem

You want to plot the density of two-dimensional data.

### Solution

Use `stat_density2d()`. This makes a 2D kernel density estimate from the data.
First we'll plot the density contour along with the data points (Figure
\@ref(fig:FIG-DISTRIBUTION-DENSITY2D), left):

```{r FIG-DISTRIBUTION-DENSITY2D-1, eval=FALSE}
# Save a base ggplot object
p <- 
  faithful %>% 
  ggplot(aes(x = eruptions, y = waiting))

p + 
  geom_point() + 
  stat_density2d()
```

It's also possible to map the *height* of the density curve to the color of the
contour lines, by using `..level..` (Figure \@ref(fig:FIG-DISTRIBUTION-DENSITY2D),
right):

```{r FIG-DISTRIBUTION-DENSITY2D-2, eval=FALSE}
# Contour lines, with "height" mapped to color
p + 
  stat_density2d(aes(colour = ..level..))
```

```{r FIG-DISTRIBUTION-DENSITY2D, ref.label=c("FIG-DISTRIBUTION-DENSITY2D-1", "FIG-DISTRIBUTION-DENSITY2D-2"), echo=FALSE, fig.show="hold", fig.cap="Left: points and density contour; right: with ..level.. mapped to color", fig.width=3.5, fig.height=3.5}
```

### Discussion

The two-dimensional kernel density estimate is analogous to the one-dimensional
density estimate generated by `stat_density()`, but of course, it needs to be
viewed in a different way. The default is to use contour lines, but it's also
possible to use tiles and to map the density estimate to the fill color, or to
the transparency of the tiles, as shown in Figure
\@ref(fig:FIG-DISTRIBUTION-DENSITY2D-TILE):

```{r FIG-DISTRIBUTION-DENSITY2D-TILE, fig.show="hold", fig.cap="Left: with ..density.. mapped to fill; right: with points, and ..density.. mapped to alpha", fig.width=3.5, fig.height=3.5}
# Map density estimate to fill color
p + 
  stat_density2d(aes(fill = ..density..), geom = "raster", contour = FALSE)

# With points, and map density estimate to alpha
p + 
  geom_point() +
  stat_density2d(aes(alpha = ..density..), geom = "tile", contour = FALSE)
```

> **Note**
>
> We used `geom = "raster"` in the first of the preceding examples and `geom =
"tile"` in the second. The main difference is that the raster geom renders more
efficiently than the tile geom. In theory they *should* appear the same, but in
practice they often do not. If you are writing to a PDF file, the appearance
depends on the PDF viewer. On some viewers, when tile is used there may be faint
lines between the tiles, and when raster is used the edges of the tiles may
appear blurry (although it doesn't matter in this particular case).

As with the one-dimensional density estimate, you can control the bandwidth of
the estimate. To do this, pass a vector for the *x* and *y* bandwidths to `h`.
This argument gets passed on to the function that actually generates the density
estimate, `kde2d()`. In this example (Figure
\@ref(fig:FIG-DISTRIBUTION-DENSITY2D-BANDWIDTH)), we'll use a smaller bandwidth
in the *x* and *y* directions, so that the density estimate is more closely
fitted (perhaps overfitted) to the data:

```{r FIG-DISTRIBUTION-DENSITY2D-BANDWIDTH, fig.cap="Density plot with a smaller bandwidth in the x and y directions"}
p + 
  stat_density2d(
    aes(fill = ..density..), 
    geom = "raster",
    contour = FALSE, 
    h = c(.5,5)
    )
```

### See Also

The relationship between `stat_density2d()` and `stat_bin2d()` is the same as
the relationship between their one-dimensional counterparts, the density curve
and the histogram. The density curve is an *estimate* of the distribution under
certain assumptions, while the binned visualization represents the observed data
directly. See Recipe \@ref(RECIPE-SCATTER-OVERPLOT) for more about binning data.

If you want to use a different color palette, see Recipe
\@ref(RECIPE-COLORS-PALETTE-CONTINUOUS).

`stat_density2d()` passes options to `kde2d()`; see `?kde2d` for information on
the available options.

<!--chapter:end:ch06.Rmd-->

---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
source("utils.R", local = TRUE)
```

Annotations {#CHAPTER-ANNOTATE}
===========

Displaying just your data usually isn't enough-there's all sorts of other information that can help the viewer interpret the data. In addition to the standard repertoire of axis labels, tick marks, and legends, you can also add individual graphical or text elements to your plot. These can be used to add extra contextual information, highlight an area of the plot, or add some descriptive text about the data.


Adding Text Annotations {#RECIPE-ANNOTATE-TEXT}
-----------------------

### Problem

You want to add a text annotation to a plot.

### Solution

Use `annotate()` and a text geom (Figure \@ref(fig:FIG-ANNOTATE-TEXT)):

```{r FIG-ANNOTATE-TEXT, fig.cap="Text annotations", fig.width=4, fig.height=4}
p <- ggplot(faithful, aes(x = eruptions, y = waiting)) + geom_point()

p + annotate("text", x = 3, y = 48, label = "Group 1") +
    annotate("text", x = 4.5, y = 66, label = "Group 2")
```

### Discussion

The `annotate()` function can be used to add any type of geometric object. In this case, we used `geom="text"`.

Other text properties can be specified, as shown in Figure \@ref(fig:FIG-ANNOTATE-TEXT-PROPERTIES):

```{r FIG-ANNOTATE-TEXT-PROPERTIES, fig.cap="Modified text properties", fig.width=4, fig.height=4}
p + annotate("text", x = 3, y = 48, label = "Group 1", family = "serif",
             fontface = "italic", colour = "darkred", size = 3) +
    annotate("text", x = 4.5, y = 66, label = "Group 2", family = "serif",
             fontface = "italic", colour = "darkred", size = 3)
```

Be careful not to use `geom_text()` when you want to add individual text objects. While `annotate(geom="text")` will add a single text object to the plot, `geom_text()` will create many text objects based on the data, as discussed in Recipe \@ref(RECIPE-SCATTER-LABELS).

If you use `geom_text()`, the text will be heavily overplotted on the same location, with one copy per data point:

```{r FIG-ANNOTATE-TEXT-GEOM-OVERPLOT, fig.cap="Overplotting one of the labels -- both should be 90% transparent", fig.width=4, fig.height=4}
p + annotate("text", x = 3, y = 48, label = "Group 1", alpha = .1) +     # Normal
    geom_text(x = 4.5, y = 66, label = "Group 2", alpha = .1)            # Overplotted
```

In Figure \@ref(fig:FIG-ANNOTATE-TEXT-GEOM-OVERPLOT), each text label is 90% transparent, making it clear which one is overplotted. The overplotting can lead to output with aliased (jagged) edges when outputting to a bitmap.

If the axes are continuous, you can use the special values `Inf` and `-Inf` to place text annotations at the edge of the plotting area, as shown in Figure \@ref(fig:FIG-ANNOTATE-TEXT-EDGE). You will also need to adjust the position of the text relative to the corner using `hjust` and `vjust` -- if you leave them at their default values, the text will be centered on the edge. It may take a little experimentation with these values to get the text positioned to your liking:

```{r FIG-ANNOTATE-TEXT-EDGE, fig.cap="Text positioned at the edge of the plotting area", fig.width=4, fig.height=4}
p + annotate("text", x = -Inf, y = Inf, label = "Upper left", hjust = -.2, vjust = 2) +
    annotate("text", x = mean(range(faithful$eruptions)), y = -Inf, vjust = -0.4,
             label = "Bottom middle")
```

### See Also

See Recipe \@ref(RECIPE-SCATTER-LABELS) for making a scatter plot with text.

For more on controlling the appearance of the text, see Recipe \@ref(RECIPE-APPEARANCE-TEXT-APPEARANCE).


Using Mathematical Expressions in Annotations {#RECIPE-ANNOTATE-TEXT-MATH}
---------------------------------------------

### Problem

You want to add a text annotation with mathematical notation.

### Solution

Use `annotate(geom="text")` with `parse=TRUE` (Figure \@ref(fig:FIG-ANNOTATE-TEXT-MATH)):

```{r FIG-ANNOTATE-TEXT-MATH, fig.cap="Annotation with mathematical expressions"}
# A normal curve
p <- ggplot(data.frame(x = c(-3,3)), aes(x = x)) + stat_function(fun = dnorm)

p + annotate("text", x = 2, y = 0.3, parse = TRUE,
             label = "frac(1, sqrt(2 * pi)) * e ^ {-x^2 / 2}")
```

### Discussion

Mathematical expressions made with text geoms using `parse=TRUE` in ggplot2 have a format similar to those made with `plotmath` and `expression` in base R, except that they are stored as strings, rather than as expression objects.

To mix regular text with expressions, use single quotes within double quotes (or vice versa) to mark the plain-text parts. Each block of text enclosed by the inner quotes is treated as a variable in a mathematical expression. Bear in mind that, in R's syntax for mathematical expressions, you can't simply put a variable right next to another without something else in between. To display two variables next to each other, as in Figure \@ref(fig:FIG-ANNOTATE-TEXT-MATH-MIX), put a `*` operator between them; when displayed in a graphic, this is treated as an invisible multiplication sign (for a visible multiplication sign, use `%*%`):

```{r FIG-ANNOTATE-TEXT-MATH-MIX, fig.cap="Mathematical expression with regular text"}
p + annotate("text", x = 0, y = 0.05, parse = TRUE, size = 4,
             label = "'Function:  ' * y==frac(1, sqrt(2*pi)) * e^{-x^2/2}")
```

### See Also

See `?plotmath` for many examples of mathematical expressions, and `?demo(plotmath)` for graphical examples of mathematical expressions.

See Recipe \@ref(RECIPE-SCATTER-FITLINES-TEXT) for adding regression coefficients to a graph.

For using other fonts in mathematical expressions, see Recipe \@ref(RECIPE-OUTPUT-FONTS-PDF).

Adding Lines {#RECIPE-ANNOTATE-LINES}
------------

### Problem

You want to add lines to a plot.

### Solution

For horizontal and vertical lines, use `geom_hline()` and `geom_vline()`, and for angled lines, use `geom_abline()` (Figure \@ref(fig:FIG-ANNOTATE-LINES)). For this example, we'll use the `heightweight` data set:

```{r FIG-ANNOTATE-LINES, fig.show="hold", fig.cap="Left: horizontal and vertical lines; right: angled line", fig.width=3.5, fig.height=3.5}
library(gcookbook) # For the data set

p <- ggplot(heightweight, aes(x = ageYear, y = heightIn, colour = sex)) + geom_point()

# Add horizontal and vertical lines
p + geom_hline(yintercept = 60) + geom_vline(xintercept = 14)

# Add angled line
p + geom_abline(intercept = 37.4, slope = 1.75)
```

### Discussion

The previous examples demonstrate setting the positions of the lines manually, resulting in one line drawn for each geom added. It is also possible to *map* values from the data to `xintercept`, `yintercept`, and so on, and even draw them from another data frame.

Here we'll take the average height for males and females and store it in a data frame, `hw_means`. Then we'll draw a horizontal line for each, and set the `linetype` and `size` (Figure \@ref(fig:FIG-ANNOTATE-LINES-MULTI)):

```{r FIG-ANNOTATE-LINES-MULTI, fig.cap="Multiple lines, drawn at the mean of each group"}
library(dplyr)

hw_means <- heightweight %>%
    group_by(sex) %>%
    summarise(heightIn = mean(heightIn))
hw_means

p + geom_hline(aes(yintercept = heightIn, colour = sex), data = hw_means, linetype = "dashed", size = 1)
```

If one of the axes is discrete rather than continuous, you can't specify the intercepts as just a character string -- they must still be specified as numbers. If the axis represents a factor, the first level has a numeric value of 1, the second level has a value of 2, and so on. You can specify the numerical intercept manually, or calculate the numerical value using `which(levels(...))` (Figure \@ref(fig:FIG-ANNOTATE-LINES-FACTOR)):

```{r FIG-ANNOTATE-LINES-FACTOR, fig.cap="Lines with a discrete axis"}
pg <- ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_point()

pg + geom_vline(xintercept = 2)

pg + geom_vline(xintercept = which(levels(PlantGrowth$group) == "ctrl"))
```

> **Note**
>
> You may have noticed that adding lines differs from adding other annotations. Instead of using the `annotate()` function, we've used `geom_hline()` and friends. This is because previous versions of ggplot2 didn't have the `annotate()` function. The line geoms had code to handle the special cases where they were used to add a single line, and changing it would break backward compatibility. In a future version of ggplot2, this will change, and `annotate()` will work with line geoms.

### See Also

For adding regression lines, see Recipes Recipe \@ref(RECIPE-SCATTER-FITLINES) and Recipe \@ref(RECIPE-SCATTER-FITLINES-MODEL).

Lines are often used to indicate summarized information about data. See Recipe \@ref(RECIPE-DATAPREP-SUMMARIZE) for more on how to summarize data by groups.


Adding Line Segments and Arrows {#RECIPE-ANNOTATE-SEGMENT}
-------------------------------

### Problem

You want to add line segments or arrows to a plot.

### Solution

Use `annotate("segment")`. In this example, we'll use the climate data set and use a subset of data from the Berkeley source (Figure \@ref(fig:FIG-ANNOTATE-SEGMENT)):

```{r FIG-ANNOTATE-SEGMENT, fig.cap="Line segment annotation"}
library(gcookbook) # For the data set

p <- ggplot(subset(climate, Source=="Berkeley"), aes(x = Year, y = Anomaly10y)) +
     geom_line()

p + annotate("segment", x = 1950, xend = 1980, y = -.25, yend = -.25)
```

### Discussion

It's possible to add arrowheads or flat ends to the line segments, using `arrow()` from the grid package. In this example, we'll do both (Figure \@ref(fig:FIG-ANNOTATE-SEGMENT-ARROWS)):

```{r FIG-ANNOTATE-SEGMENT-ARROWS, fig.cap="Line segments with arrow heads"}
library(grid)
p + annotate("segment", x = 1850, xend = 1820, y = -.8, yend = -.95, colour = "blue",
             size = 2, arrow = arrow()) +
    annotate("segment", x = 1950, xend = 1980, y = -.25, yend = -.25,
             arrow = arrow(ends = "both", angle = 90, length = unit(.2,"cm")))
```

The default angle is 30, and the default length of the arrowhead lines is 0.2 inches.

If one or both axes are discrete, the *x* and *y* positions are such that the categorical items have coordinate values 1, 2, 3, and so on.

### See Also

For more information about the parameters for drawing arrows, load the grid package and see `?arrow`.


Adding a Shaded Rectangle {#RECIPE-ANNOTATE-RECT}
-------------------------

### Problem

You want to add a shaded region.

### Solution

Use `annotate("rect")` (Figure \@ref(fig:FIG-ANNOTATE-RECT)):

```{r FIG-ANNOTATE-RECT, fig.cap="A shaded rectangle"}
library(gcookbook) # For the data set

p <- ggplot(subset(climate, Source == "Berkeley"), aes(x = Year, y = Anomaly10y)) +
     geom_line()

p + annotate("rect", xmin = 1950, xmax = 1980, ymin = -1, ymax = 1, alpha = .1,
             fill = "blue")
```

### Discussion

Each layer is drawn in the order that it's added to the ggplot object, so in the preceding example, the rectangle is drawn on top of the line. It's not a problem in that case, but if you'd like to have the line above the rectangle, add the rectangle first, and then the line.

Any geom can be used with `annotate()`, as long as you pass in the proper parameters. In this case, `geom_rect()` requires min and max values for x and y.


Highlighting an Item {#RECIPE-ANNOTATE-HIGHLIGHT}
--------------------

### Problem

You want to change the color of an item to make it stand out.

### Solution

To highlight one or more items, create a new column in the data and map it to the color. In this example, we'll create a new column, `hl`, and set its value based on the value of group:

```{r}
pg <- PlantGrowth                 # Make a copy of the PlantGrowth data
pg$hl <- "no"                     # Set all to "no"
pg$hl[pg$group=="trt2"] <- "yes"  # If group is "trt2", set to "yes"
```

Then we'll plot it with manually specified colors and with no legend (Figure \@ref(fig:FIG-ANNOTATE-HIGHLIGHT)):

```{r FIG-ANNOTATE-HIGHLIGHT, fig.cap="Highlighting one item"}
ggplot(pg, aes(x = group, y = weight, fill = hl)) + geom_boxplot() +
    scale_fill_manual(values = c("grey85", "#FFDDCC"), guide = FALSE)
```

### Discussion

If you have a small number of items, as in this example, instead of creating a new column you could use the original one and specify the colors for every level of that variable. For example, the following code will use the group column from `PlantGrowth` and manually set the colors for each of the three levels. The result will appear the same as with the preceding code:

```{r eval=FALSE}
ggplot(PlantGrowth, aes(x = group, y = weight, fill = group)) + geom_boxplot() +
    scale_fill_manual(values = c("grey85", "grey85", "#FFDDCC"), guide = FALSE)
```

### See Also

See Chapter \@ref(CHAPTER-COLORS) for more information about specifying colors.

For more information about removing the legend, see Recipe \@ref(RECIPE-LEGEND-REMOVE).


Adding Error Bars {#RECIPE-ANNOTATE-ERROR-BAR}
-----------------

### Problem

You want to add error bars to a graph.

### Solution

Use `geom_errorbar()` and map variables to the values for `ymin` and `ymax`. Adding the error bars is done the same way for bar graphs and line graphs, as shown in Figure \@ref(fig:FIG-ANNOTATE-ERRORBAR-BASIC) (notice that default *y* range is different for bars and lines, though):

```{r FIG-ANNOTATE-ERRORBAR-BASIC, fig.show="hold", fig.cap="Left: error bars on a bar graph; right: on a line graph", fig.width=3.5, fig.height=3.5}
library(gcookbook) # For the data set
# Take a subset of the cabbage_exp data for this example
ce <- subset(cabbage_exp, Cultivar == "c39")

# With a bar graph
ggplot(ce, aes(x = Date, y = Weight)) +
    geom_bar(stat = "identity", fill = "white", colour = "black") +
    geom_errorbar(aes(ymin = Weight-se, ymax = Weight+se), width = .2)

# With a line graph
ggplot(ce, aes(x = Date, y = Weight)) +
    geom_line(aes(group = 1)) +
    geom_point(size = 4) +
    geom_errorbar(aes(ymin = Weight-se, ymax = Weight+se), width = .2)
```

### Discussion

In this example, the data already has values for the standard error of the mean (`se`), which we'll use for the error bars (it also has values for the standard deviation, `sd`, but we're not using that here):


```{r}
ce
```

To get the values for `ymax` and `ymin`, we took the y variable, `Weight`, and
added/subtracted `se`.

We also specified the width of the ends of the error bars, with `width=.2`. It's best to play around with this to find a value that looks good. If you don't set the width, the error bars will be very wide, spanning all the space between items on the x-axis.

For a bar graph with groups of bars, the error bars must also be *dodged*; otherwise, they'll have the exact same *x* coordinate and won't line up with the bars. (See Recipe \@ref(RECIPE-BAR-GRAPH-GROUPED-BAR) for more information about grouped bars and dodging.)

We'll work with the full `cabbage_exp` data set this time:

```{r}
cabbage_exp
```

The default dodge width for `geom_bar()` is 0.9, and you'll have to tell the error bars to be dodged the same width. If you don't specify the dodge width, it will default to dodging by the width of the error bars, which is usually less than the width of the bars (Figure \@ref(fig:FIG-ANNOTATE-ERRORBAR-GROUP-BAR)):

```{r FIG-ANNOTATE-ERRORBAR-GROUP-BAR, fig.show="hold", fig.cap="Left: error bars on a grouped bar graph without dodging width specified; right: with dodging width specified", fig.width=3.5, fig.height=3.5}
# Bad: dodge width not specified
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_bar(stat = "identity", position = "dodge") +
    geom_errorbar(aes(ymin = Weight-se, ymax = Weight+se),
                  position = "dodge", width = .2)

# Good: dodge width set to same as bar width (0.9)
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_bar(stat = "identity", position = "dodge") +
    geom_errorbar(aes(ymin = Weight-se, ymax = Weight+se),
                  position = position_dodge(0.9), width = .2)
```

> **Note**
>
> Notice that we used `position="dodge"`, which is shorthand for `position=position_dodge()`, in the first version. But to pass a specific value, we have to spell it out, as in `position_dodge(0.9)`.

For line graphs, if the error bars are a different color than the lines and points, you should draw the error bars first, so that they are underneath the points and lines. Otherwise the error bars will be drawn on top of the points and lines, which won't look right.

Additionally, you should dodge all the geometric elements so that they will align with the error bars, as shown in Figure \@ref(fig:FIG-ANNOTATE-ERRORBAR-GROUP-LINE-DODGE):

```{r FIG-ANNOTATE-ERRORBAR-GROUP-LINE-DODGE, fig.show="hold", fig.cap="Error bars on a line graph, dodged so they don't overlap", fig.width=3.5, fig.height=3.5}
pd <- position_dodge(.3)  # Save the dodge spec because we use it repeatedly

ggplot(cabbage_exp, aes(x = Date, y = Weight, colour = Cultivar, group = Cultivar)) +
    geom_errorbar(aes(ymin = Weight-se, ymax = Weight+se),
                  width = .2, size = 0.25, colour = "black", position = pd) +
    geom_line(position = pd) +
    geom_point(position = pd, size = 2.5)

# Thinner error bar lines with size=0.25, and larger points with size=2.5
```

Notice that we set `colour="black"` to make the error bars black; otherwise, they would inherit `colour`. We also made sure the `Cultivar` was used as a grouping variable by mapping it to group.

When a discrete variable is *mapped* to an aesthetic like colour or fill (as in the case of the bars), that variable is used for grouping the data. But by *setting* the colour of the error bars, we made it so that the variable for colour was not used for grouping, and we needed some other way to inform ggplot that the two data entries at each *x* were in different groups so that they would be dodged.

### See Also

See Recipe \@ref(RECIPE-BAR-GRAPH-GROUPED-BAR) for more about creating grouped bar graphs, and Recipe \@ref(RECIPE-LINE-GRAPH-MULTIPLE-LINE) for more about creating line graphs with multiple lines.

See Recipe \@ref(RECIPE-DATAPREP-SUMMARIZE-SE) for calculating summaries with means, standard deviations, standard errors, and confidence intervals.

See Recipe \@ref(RECIPE-LINE-GRAPH-REGION) for adding a confidence region when the data has a higher density along the x-axis.


Adding Annotations to Individual Facets {#RECIPE-ANNOTATE-FACET}
---------------------------------------

### Problem

You want to add annotations to each facet in a plot.

### Solution

Create a new data frame with the faceting variable(s), and a value to use in each facet. Then use `geom_text()` with the new data frame (Figure \@ref(fig:FIG-ANNOTATE-FACET)):

```{r FIG-ANNOTATE-FACET, fig.show="hold", fig.cap="Top: different annotations in each facet; bottom: the same annotation in each facet", fig.width=7, fig.height=3}
# The base plot
p <- ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + facet_grid(. ~ drv)

# A data frame with labels for each facet
f_labels <- data.frame(drv = c("4", "f", "r"), label = c("4wd", "Front", "Rear"))

p + geom_text(x = 6, y = 40, aes(label = label), data = f_labels)

# If you use annotate(), the label will appear in all facets
p + annotate("text", x = 6, y = 42, label = "label text")
```

### Discussion

This method can be used to display information about the data in each facet, as shown in Figure \@ref(fig:FIG-ANNOTATE-FACET-MATH). For example, in each facet we can show linear regression lines, the formula for each line, and the *r^2^* value. To do this, we'll write a function that takes a data frame and returns another data frame containing a string for a regression equation, and a string for the *r^2^* value. Then we'll use dplyr's `do()` function to apply that function to each group of the data:

```{r FIG-ANNOTATE-FACET-MATH, fig.cap="Annotations in each facet with information about the data"}
# This function returns a data frame with strings representing the regression
# equation, and the r^2 value.
# These strings will be treated as R math expressions
lm_labels <- function(dat) {
    mod <- lm(hwy ~ displ, data = dat)
    formula <- sprintf("italic(y) == %.2f %+.2f * italic(x)",
                       round(coef(mod)[1], 2), round(coef(mod)[2], 2))
    r <- cor(dat$displ, dat$hwy)
    r2 <- sprintf("italic(R^2) == %.2f", r^2)
    data.frame(formula = formula, r2 = r2, stringsAsFactors = FALSE)
}

library(dplyr)
labels <- mpg %>%
    group_by(drv) %>%
    do(lm_labels(.))
labels

# Plot with formula and R^2 values
p + geom_smooth(method = lm, se = FALSE) +
    geom_text(x = 3, y = 40, aes(label = formula), data = labels, parse = TRUE, hjust = 0) + geom_text(x = 3, y = 35, aes(label = r2), data = labels, parse = TRUE, hjust = 0)
```

We needed to write our own function here because generating the linear model and extracting the coefficients requires operating on each subset data frame directly. If you just want to display the r^2^ values, it's possible to do something simpler, by using the `group_by()` and with the `summarise()` function and then passing additional arguments for `summarise()`:

```{r}
# Find r^2 values for each group
labels <- mpg %>%
    group_by(drv) %>%
    summarise(r2 = cor(displ, hwy)^2)
labels$r2 <- sprintf("italic(R^2) == %.2f", labels$r2)
labels
```

Text geoms aren't the only kind that can be added individually for each facet. Any geom can be used, as long as the input data is structured correctly.

### See Also

See Recipe \@ref(RECIPE-ANNOTATE-TEXT-MATH) for more about using math expressions in plots.

If you want to make prediction lines from your own model objects, instead of having ggplot2 do it for you with `stat_smooth()`, see Recipe \@ref(RECIPE-SCATTER-FITLINES-MODEL-MULTI).

<!--chapter:end:ch07.Rmd-->

---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
# This block needs cache=FALSE to set fig.width and fig.height, and have those
# persist across cached builds.

source("utils.R", local = TRUE)
knitr::opts_chunk$set(fig.width = 3, fig.height = 3)
```

Axes {#CHAPTER-AXES}
====

The x- and y-axes provide context for interpreting the displayed data. Ggplot will display the axes with defaults that look good in most cases, but you might want to control, for example, the axis labels, the number and placement of tick marks, the tick mark labels, and so on. In this chapter, I'll cover how to fine-tune the appearance of the axes.


Swapping X- and Y-Axes {#RECIPE-AXES-SWAP-AXES}
----------------------

### Problem

You want to swap the x- and y-axes on a graph.

### Solution

Use `coord_flip()` to flip the axes (Figure \@ref(fig:FIG-AXES-SWAP-AXES)):

```{r FIG-AXES-SWAP-AXES, fig.show="hold", fig.cap="Left: a box plot with regular axes; right: with swapped axes"}
ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot()

ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot() + coord_flip()
```

### Discussion

For a scatter plot, it is trivial to change what goes on the vertical axis and what goes on the horizontal axis: just exchange the variables mapped to x and y. But not all the geoms in ggplot treat the x- and y-axes equally. For example, box plots summarize the data along the y-axis, the lines in line graphs move in only one direction along the x-axis, error bars have a single *x* value and a range of *y* values, and so on. If you're using these geoms and want them to behave as though the axes are swapped, `coord_flip()` is what you need.

Sometimes when the axes are swapped, the order of items will be the reverse of what you want. On a graph with standard x- and y-axes, the *x* items start at the left and go to the right, which corresponds to the normal way of reading, from left to right. When you swap the axes, the items still go from the origin outward, which in this case will be from bottom to top -- but this conflicts with the normal way of reading, from top to bottom. Sometimes this is a problem, and sometimes it isn't. If the *x* variable is a factor, the order can be reversed by using `scale_x_$discrete()` with `limits=rev(levels(...))`, as in Figure \@ref(fig:FIG-AXES-SWAP-AXES-REVLEVELS):

```{r FIG-AXES-SWAP-AXES-REVLEVELS, fig.cap="A box plot with swapped axes and x-axis order reversed"}
ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot() + coord_flip() +
    scale_x_discrete(limits = rev(levels(PlantGrowth$group)))
```

### See Also

If the variable is continuous, see Recipe \@ref(RECIPE-AXES-REVERSE) to reverse the direction.


Setting the Range of a Continuous Axis {#RECIPE-AXES-RANGE}
--------------------------------------

### Problem

You want to set the range (or limits) of an axis.

### Solution

You can use `xlim()` or `ylim()` to set the minimum and maximum values of a continuous axis. Figure \@ref(fig:FIG-AXES-RANGE) shows one graph with the default *y* limits, and one with manually set *y* limits:

```{r FIG-AXES-RANGE, fig.show="hold", fig.cap="Left: box plot with default range; right: with manually set range"}
p <- ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot()
# Display the basic graph
p

p + ylim(0, max(PlantGrowth$weight))
```

The latter example sets the *y* range from 0 to the maximum value of the `weight` column, though a constant value (like 10) could instead be used as the maximum.

### Discussion

`ylim()` is shorthand for setting the limits with `scale_y_continuous()`. (The same is true for `xlim()` and `scale_x_continuous()`.) The following are equivalent:

```{r eval=FALSE}
ylim(0, 10)
scale_y_continuous(limits = c(0, 10))
```

Sometimes you will need to set other properties of `scale_y_continuous()`, and in these cases using `xlim()` and `scale_y_continuous()` together may result in some unexpected behavior, because only the first of the directives will have an effect. In these two examples, `ylim(0, 10)` should set the *y* range from 0 to 10, and `scale_y_continuous(breaks=c(0, 5, 10))` should put tick marks at 0, 5, and 10. However, in both cases, only the second directive has any effect:

```{r eval=FALSE}
p + ylim(0, 10) + scale_y_continuous(breaks = NULL)

p + scale_y_continuous(breaks = NULL) + ylim(0, 10)
```

To make both changes work, get rid of `ylim()` and set both limits and breaks in `scale_y_continuous()`:

```{r eval=FALSE}
p + scale_y_continuous(limits = c(0, 10), breaks = NULL)
```

In ggplot, there are two ways of setting the range of the axes. The first way is to modify the *scale*, and the second is to apply a *coordinate transform*. Whenyou modify the limits of the *x* or *y* scale, any data outside of the limits is removed -- that is, the out-of-range data is not only not displayed, it is removed from consideration entirely.

With the box plots in these examples, if you restrict the *y* range so that some of the original data is clipped, the box plot statistics will be computed based on clipped data, and the shape of the box plots will change.

With a coordinate transform, the data is not clipped; in essence, it zooms in or out to the specified range. Figure \@ref(fig:FIG-AXES-RANGE-SCALE-COORD) shows the difference between the two methods:

```{r FIG-AXES-RANGE-SCALE-COORD, fig.show="hold", fig.cap='Left: smaller y range using a scale (data has been dropped, so the box plots have changed shape); right: "zooming in" using a coordinate transform'}
p + scale_y_continuous(limits = c(5, 6.5))  # Same as using ylim()

p + coord_cartesian(ylim = c(5, 6.5))
```

Finally, it's also possible to *expand* the range in one direction, using `expand_limits()` (Figure \@ref(fig:FIG-AXES-RANGE-EXPAND)). You can't use this to shrink the range, however:

```{r FIG-AXES-RANGE-EXPAND, fig.cap="Box plot on which y range has been expanded to include 0"}
p + expand_limits(y = 0)
```


Reversing a Continuous Axis {#RECIPE-AXES-REVERSE}
---------------------------

### Problem

You want to reverse the direction of a continuous axis.

### Solution

Use `scale_y_reverse()` or `scale_x_reverse()` (Figure \@ref(fig:FIG-AXES-REVERSE)). The direction of an axis can also be reversed by specifying the limits in reversed order, with the maximum first, then the minimum:

```{r FIG-AXES-REVERSE, fig.cap="Box plot with reversed y-axis"}
ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot() + scale_y_reverse()

# Similar effect by specifying limits in reversed order
ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot() + ylim(6.5, 3.5)
```

### Discussion

Like `scale_y_continuous()`, `scale_y_reverse()` does not work with `ylim()`. (The same is true for the x-axis properties.) If you want to reverse an axis *and* set its range, you must do it within the `scale_y_reverse()` statement, by setting the limits in reversed order (Figure \@ref(fig:FIG-AXES-REVERSE-LIMITS)):

```{r FIG-AXES-REVERSE-LIMITS, fig.cap="Box plot with reversed y-axis with manually set limits"}
ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot() +
    scale_y_reverse(limits = c(8, 0))
```

### See Also

To reverse the order of items on a *discrete* axis, see Recipe \@ref(RECIPE-AXIS-ORDER).


Changing the Order of Items on a Categorical Axis {#RECIPE-AXIS-ORDER}
-------------------------------------------------

### Problem

You want to change the order of items on a categorical axis.

### Solution

For a categorical (or discrete) axis-one with a factor mapped to it-the order of items can be changed by setting limits in `scale_x_discrete()` or `scale_y_discrete()`.

To manually set the order of items on the axis, specify limits with a vector of the levels in the desired order. You can also omit items with this vector, as shown in Figure \@ref(fig:FIG-AXES-ORDER-MANUAL):

```{r FIG-AXES-ORDER-MANUAL-1, eval=FALSE}
p <- ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot()

p + scale_x_discrete(limits = c("trt1","ctrl","trt2"))
```

### Discussion

You can also use this method to display a subset of the items on the axis. This will show only `ctrl` and `trt1` (Figure \@ref(fig:FIG-AXES-ORDER-MANUAL), right):

```{r FIG-AXES-ORDER-MANUAL-2, eval=FALSE}
p + scale_x_discrete(limits = c("ctrl","trt1"))
```

```{r FIG-AXES-ORDER-MANUAL, ref.label=c("FIG-AXES-ORDER-MANUAL-1", "FIG-AXES-ORDER-MANUAL-2"), echo=FALSE, fig.cap="Left: box plot with manually specified items on the x-axis; right: with only two items"}
```

To reverse the order, set `limits=rev(levels(...))`, and put the factor inside. This will reverse the order of the `PlantGrowth$group` factor, as shown in Figure \@ref(fig:FIG-AXES-ORDER-REV):

```{r FIG-AXES-ORDER-REV, fig.cap="Box plot with order reversed on the x-axis"}
p + scale_x_discrete(limits = rev(levels(PlantGrowth$group)))
```

### See Also

To reorder factor levels based on data values from another column, see Recipe \@ref(RECIPE-DATAPREP-FACTOR-REORDER-VALUE).


Setting the Scaling Ratio of the X- and Y-Axes {#RECIPE-AXES-SCALE}
----------------------------------------------

### Problem

You want to set the ratio at which the x- and y-axes are scaled.

### Solution

Use `coord_fixed()`. This will result in a 1:1 scaling between the x- and y-axes, as shown in Figure \@ref(fig:FIG-AXES-SCALE-EQUAL):

```{r FIG-AXES-SCALE-EQUAL-1, eval=FALSE}
library(gcookbook) # For the data set

sp <- ggplot(marathon, aes(x = Half,y = Full)) + geom_point()

sp + coord_fixed()
```

### Discussion

The marathon data set contains runners' marathon and half-marathon times. In this case it might be useful to force the x- and y-axes to have the same scaling.

It's also helpful to set the tick spacing to be the same, by setting breaks in `scale_y_continuous()` and `scale_x_continuous()` (also in
Figure \@ref(fig:FIG-AXES-SCALE-EQUAL)):

```{r FIG-AXES-SCALE-EQUAL-2, eval=FALSE}
sp + coord_fixed() +
    scale_y_continuous(breaks = seq(0, 420, 30)) +
    scale_x_continuous(breaks = seq(0, 420, 30))
```

```{r FIG-AXES-SCALE-EQUAL, ref.label=c("FIG-AXES-SCALE-EQUAL-1", "FIG-AXES-SCALE-EQUAL-2"), echo=FALSE, fig.show="hold", fig.cap="Left: scatter plot with equal scaling of axes; right: with tick marks at specified positions"}
```

If, instead of an equal ratio, you want some other fixed ratio between the axes, set the ratio parameter. With the marathon data, we might want the axis with half-marathon times stretched out to twice that of the axis with the marathon times (Figure \@ref(fig:FIG-AXES-SCALE-HALF)). We'll also add tick marks twice as often on the x-axis:

```{r FIG-AXES-SCALE-HALF, fig.cap="Scatter plot with a 1/2 scaling ratio for the axes"}
sp + coord_fixed(ratio = 1/2) +
    scale_y_continuous(breaks = seq(0, 420, 30)) +
    scale_x_continuous(breaks = seq(0, 420, 15))
```


Setting the Positions of Tick Marks {#RECIPE-AXES-SET-TICKS}
-----------------------------------

### Problem

You want to set where the tick marks appear on the axis.

### Solution

Usually ggplot does a good job of deciding where to put the tick marks, but if you want to change them, set `breaks` in the scale (Figure \@ref(fig:FIG-AXES-SET-TICKS)):

```{r FIG-AXES-SET-TICKS, fig.show="hold", fig.cap="Left: box plot with automatic tick marks; right: with manually set tick marks"}
ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot()

ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot() +
    scale_y_continuous(breaks = c(4, 4.25, 4.5, 5, 6, 8))
```

### Discussion

The location of the tick marks defines where *major* grid lines are drawn. If the axis represents a continuous variable, *minor* grid lines, which are fainter and unlabeled, will by default be drawn halfway between each major grid line.

You can also use the `seq()` function or the `:` operator to generate vectors for tick marks:

```{r}
seq(4, 7, by = .5)
5:10
```

If the axis is discrete instead of continuous, then there is by default a tick mark for each item. For discrete axes, you can change the order of items or remove them by specifying the limits (see Recipe \@ref(RECIPE-AXIS-ORDER)). Setting breaks will change which of the levels are labeled, but will not remove them or change their order. Figure \@ref(fig:FIG-AXES-SET-TICKS-DISCRETE) shows what happens when you set limits and breaks:

```{r FIG-AXES-SET-TICKS-DISCRETE, fig.cap="For a discrete axis, setting limits reorders and removes items, and setting breaks controls which items have labels"}
# Set both breaks and labels for a discrete axis
ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot() +
    scale_x_discrete(limits = c("trt2", "ctrl"), breaks = "ctrl")
```

### See Also

To remove the tick marks and labels (but not the data) from thegraph, see Recipe \@ref(RECIPE-AXIS-REMOVE-TICKS).


Removing Tick Marks and Labels {#RECIPE-AXIS-REMOVE-TICKS}
------------------------------

### Problem

You want to remove tick marks and labels.

### Solution

To remove just the tick labels, as in Figure \@ref(fig:FIG-AXES-SET-TICKS-NONE) (left), use `theme(axis.text.y=element_blank()`) (or do the same for `axis.text.x`). This will work for both continuous and categorical axes:

```{r FIG-AXES-SET-TICKS-NONE-1, eval=FALSE}
p <- ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot()

p + theme(axis.text.y = element_blank())
```

To remove the tick marks, use `theme(axis.ticks=element_blank())`. This will remove the tick marks on both axes. (It's not possible to hide the tick marks on just one axis.) In this example, we'll hide all tick marks as well as the *y* tick labels (Figure \@ref(fig:FIG-AXES-SET-TICKS-NONE), center):

```{r FIG-AXES-SET-TICKS-NONE-2, eval=FALSE}
p + theme(axis.ticks = element_blank(), axis.text.y = element_blank())
```

To remove the tick marks, the labels, and the grid lines, set breaks to
`NULL` (Figure \@ref(fig:FIG-AXES-SET-TICKS-NONE), right):

```{r FIG-AXES-SET-TICKS-NONE-3, eval=FALSE}
p + scale_y_continuous(breaks = NULL)
```

```{r FIG-AXES-SET-TICKS-NONE, ref.label=c("FIG-AXES-SET-TICKS-NONE-1", "FIG-AXES-SET-TICKS-NONE-2", "FIG-AXES-SET-TICKS-NONE-3"), echo=FALSE, fig.show="hold", fig.cap="Left: no tick labels on y-axis; middle: no tick marks and no tick labels on y-axis; right: with breaks=NULL"}
```

This will work for continuous axes only; if you remove items from a categorical axis using limits, as in Recipe \@ref(RECIPE-AXIS-ORDER), the data with that value won't be shown at all.

### Discussion

There are actually three related items that can be controlled: tick labels, tick marks, and the grid lines. For continuous axes, `ggplot()` normally places a tick label, tick mark, and major grid line at each value of breaks. For categorical axes, these things go at each value of limits.

The tick labels on each axis can be controlled independently. However, the tick marks and grid lines must be controlled all together.


Changing the Text of Tick Labels {#RECIPE-AXES-TICK-LABEL}
--------------------------------

### Problem

You want to change the text of tick labels.

### Solution

Consider the scatter plot in Figure \@ref(fig:FIG-AXES-TICK-LABEL), where height is reported in inches:

```{r FIG-AXES-TICK-LABEL-1, eval=FALSE}
library(gcookbook) # For the data set

hwp <- ggplot(heightweight, aes(x = ageYear, y = heightIn)) +
          geom_point()

hwp
```

To set arbitrary labels, as in Figure \@ref(fig:FIG-AXES-TICK-LABEL) (right), pass values to breaks and labels in the scale. One of the labels has a newline (`\n`) character, which tells ggplot to put a line break there:

```{r FIG-AXES-TICK-LABEL-2, eval=FALSE}
hwp + scale_y_continuous(breaks = c(50, 56, 60, 66, 72),
                         labels = c("Tiny", "Really\nshort", "Short",
                                  "Medium", "Tallish"))
```


```{r FIG-AXES-TICK-LABEL, ref.label=c("FIG-AXES-TICK-LABEL-1", "FIG-AXES-TICK-LABEL-2"), echo=FALSE, fig.show="hold", fig.cap="Left: scatter plot with automatic tick labels; right: with manually specified labels on the y-axis"}
```

### Discussion

Instead of setting completely arbitrary labels, it is more common to have your data stored in one format, while wanting the labels to be displayed in another. We might, for example, want heights to be displayed in feet and inches (like 5'6") instead of just inches. To do this, we can define a *formatter* function, which takes in a value and returns the corresponding string. For example, this function will convert inches to feet and inches:

```{r}
footinch_formatter <- function(x) {
    foot <- floor(x/12)
    inch <- x %% 12
    return(paste(foot, "'", inch, "\"", sep = ""))
}
```

Here's what it returns for values 56--64 (the backslashes are there as escape characters, to distinguish the quotes *in* a string from the quotes that *delimit* a string):

```{r}
footinch_formatter(56:64)
```

Now we can pass our function to the scale, using the labels parameter (Figure \@ref(fig:FIG-AXES-TICK-LABEL-FORMATTER), left):

```{r FIG-AXES-TICK-LABEL-FORMATTER-1, eval=FALSE}
hwp + scale_y_continuous(labels = footinch_formatter)
```

Here, the automatic tick marks were placed every five inches, but that looks a little off for this data. We can instead have ggplot set tick marks every four inches, by specifying breaks (Figure \@ref(fig:FIG-AXES-TICK-LABEL-FORMATTER), right):

```{r FIG-AXES-TICK-LABEL-FORMATTER-2, eval=FALSE}
hwp + scale_y_continuous(breaks = seq(48, 72, 4), labels = footinch_formatter)
```

```{r FIG-AXES-TICK-LABEL-FORMATTER, ref.label=c("FIG-AXES-TICK-LABEL-FORMATTER-1", "FIG-AXES-TICK-LABEL-FORMATTER-2"), echo=FALSE, fig.show="hold", fig.cap="Left: scatter plot with a formatter function; right: with manually specified breaks on the y-axis"}
```

Another common task is to convert time measurements to HH:MM:SS format, or something similar. This function will take numeric minutes and convert them to this format, rounding to the nearest second (it can be customized for your particular needs):

```{r}
timeHMS_formatter <- function(x) {
    h <- floor(x/60)
    m <- floor(x %% 60)
    s <- round(60*(x %% 1))                   # Round to nearest second
    lab <- sprintf("%02d:%02d:%02d", h, m, s) # Format the strings as HH:MM:SS
    lab <- gsub("^00:", "", lab)              # Remove leading 00: if present
    lab <- gsub("^0", "", lab)                # Remove leading 0 if present
    return(lab)
}
```

Running it on some sample numbers yields:

```{r}
timeHMS_formatter(c(.33, 50, 51.25, 59.32, 60, 60.1, 130.23))
```

The scales package, which is installed with ggplot2, comes with some built-in formatting functions:

* `comma()` adds commasto numbers, in the thousand, million, billion, etc. places.
* `dollar()` adds a dollar sign and rounds to the nearest cent.
* `percent()` multiplies by 100, rounds to the nearest integer, and adds a percent sign.
* `scientific()` gives numbers in scientific notation, like `3.30e+05`, for large and small numbers.

If you want to use these functions, you must first load the scales package, with `library(scales)`.


Changing the Appearance of Tick Labels {#RECIPE-AXES-TICK-LABEL-APPEARANCE}
--------------------------------------

### Problem

You want to change the appearance of tick labels.

### Solution

In Figure \@ref(fig:FIG-AXES-TICK-LABEL-ROTATE) (left), we've manually set the labels to be long-long enough that they overlap:

```{r FIG-AXES-TICK-LABEL-ROTATE-1, eval=FALSE}
bp <- ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot() +
      scale_x_discrete(breaks = c("ctrl", "trt1", "trt2"),
                       labels = c("Control", "Treatment 1", "Treatment 2"))
bp
```

To rotate the text 90 degrees counterclockwise (Figure \@ref(fig:FIG-AXES-TICK-LABEL-ROTATE), middle), use:

```{r FIG-AXES-TICK-LABEL-ROTATE-2, eval=FALSE}
bp + theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5))
```

Rotating the text 30 degrees (Figure \@ref(fig:FIG-AXES-TICK-LABEL-ROTATE), right) uses less vertical space and makes the labels easier to read without tilting your head:

```{r FIG-AXES-TICK-LABEL-ROTATE-3, eval=FALSE}
bp + theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1))
```

```{r FIG-AXES-TICK-LABEL-ROTATE, ref.label=c("FIG-AXES-TICK-LABEL-ROTATE-1", "FIG-AXES-TICK-LABEL-ROTATE-2", "FIG-AXES-TICK-LABEL-ROTATE-3"), echo=FALSE, fig.show="hold", fig.cap="X-axis tick labels rotated 0 (left), 90 (middle), and 30 degrees (right)", fig.width=3.5, fig.height=3.5}

The `hjust` and `vjust` settings specify the horizontal alignment (left/center/right) and vertical alignment (top/middle/bottom).

### Discussion

Besides rotation, other text properties, such as size, style (bold/italic/normal), and the font family (such as Times or Helvetica) can be set with `element_text()`, as shown in Figure \@ref(fig:FIG-AXES-TICK-LABEL-FONT):

```{r FIG-AXES-TICK-LABEL-FONT, fig.cap="X-axis tick labels with manually specified appearance"}
bp + theme(axis.text.x = element_text(family = "Times", face = "italic",
                                      colour = "darkred", size = rel(0.9)))
```

In this example, the size is set to `rel(0.9)`, which means that it is 0.9 times the size of the base font size for the theme.

These commands control the appearance of only the tick labels, on only one axis. They don't affect the other axis, the axis label, the overall title, or the legend. To control all of these at once, you can use the theming system, as discussed in Recipe \@ref(RECIPE-APPEARANCE-THEME).

### See Also

See Recipe \@ref(RECIPE-APPEARANCE-TEXT-APPEARANCE) for more about controlling the appearance of the text.


Changing the Text of Axis Labels {#RECIPE-AXES-AXIS-LABEL}
--------------------------------

### Problem

You want to change the text of axis labels.

### Solution

Use `xlab()` or `ylab()` to change the text of the axis labels (Figure \@ref(fig:FIG-AXES-AXIS-LABEL)):

```{r FIG-AXES-AXIS-LABEL, fig.show="hold", fig.cap="Left: scatter plot with the default axis labels; right: manually specified labels for the x- and y-axes", fig.width=3.5, fig.height=3.5}
library(gcookbook) # For the data set

hwp <- ggplot(heightweight, aes(x = ageYear, y = heightIn, colour = sex)) +
       geom_point()
# With default axis labels
hwp

# Set the axis labels
hwp + xlab("Age in years") + ylab("Height in inches")
```

### Discussion

By default the graphs will just use the column names from the data frame as axis labels. This might be fine for exploring data, but for presenting it, you may want more descriptive axis labels.

Instead of `xlab()` and `ylab()`, you can use `labs()`:

```{r, eval=FALSE}
hwp + labs(x = "Age in years", y = "Height in inches")
```

Another way of setting the axis labels is in the scale specification, like this:

```{r, eval=FALSE}
hwp + scale_x_continuous(name = "Age in years")
```

This may look a bit awkward, but it can be useful if you're also setting other properties of the scale, such as the tick mark placement, range, and so on.

This also applies, of course, to other axis scales, such as `scale_y_continuous()`, `scale_x_discrete()`, and so on.

You can also add line breaks with `\n`, as shown in Figure \@ref(fig:FIG-AXES-AXIS-LABEL-NEWLINE):

```{r FIG-AXES-AXIS-LABEL-NEWLINE, fig.cap="X-axis label with a line break"}
hwp + scale_x_continuous(name = "Age\n(years)")
```


Removing Axis Labels {#RECIPE-AXES-AXIS-LABEL-REMOVE}
--------------------

### Problem

You want to remove the label on an axis.

### Solution

For the x-axis label, use `theme(axis.title.x=element_blank())`. For the y-axis label, do the same with `axis.title.y`.

We'll hide the x-axis in this example (Figure \@ref(fig:FIG-AXES-AXIS-LABEL-REMOVE)):

```{r FIG-AXES-AXIS-LABEL-REMOVE-1, eval=FALSE}
p <- ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot()

p + theme(axis.title.x = element_blank())
```

### Discussion

Sometimes axis labels are redundant or obvious from the context, and don't need to be displayed. In the example here, the x-axis represents group, but this should be obvious from the context. Similarly, if the *y* tick labels had *kg* or some other unit in each label, the axis label "weight" would be unnecessary.

Another way to remove the axis label is to set it to an empty string. However, if you do it this way, the resulting graph will still have space reserved for the text, as shown in the graph on the right in Figure \@ref(fig:FIG-AXES-AXIS-LABEL-REMOVE):

```{r FIG-AXES-AXIS-LABEL-REMOVE-2, eval=FALSE}
p + xlab("")
```

(ref:cap-FIG-AXES-AXIS-LABEL-REMOVE) Left: x-axis label with `element_blank()`; right: with the label set to `""`

```{r FIG-AXES-AXIS-LABEL-REMOVE, ref.label=c("FIG-AXES-AXIS-LABEL-REMOVE-1", "FIG-AXES-AXIS-LABEL-REMOVE-2"), echo=FALSE, fig.show="hold", fig.cap="(ref:cap-FIG-AXES-AXIS-LABEL-REMOVE)", fig.width=3.5, fig.height=3.5}
```

When you use `theme()` to set `axis.title.x=element_blank()`, the name of the *x* or *y* scale is unchanged, but the text is not displayed and no space is reserved for it. When you set the label to `""`, the name of the scale is changed and the (empty) text does display.


Changing the Appearance of Axis Labels {#RECIPE-AXES-AXIS-LABEL-APPEARANCE}
--------------------------------------

### Problem

You want to change the appearance of axis labels.

### Solution

To change the appearance of the x-axis label (Figure \@ref(fig:FIG-AXES-AXIS-LABEL-APPEARANCE)), use `axis.title.x`:


```{r FIG-AXES-AXIS-LABEL-APPEARANCE, fig.cap="X-axis label with customized appearance"}
library(gcookbook) # For the data set

hwp <- ggplot(heightweight, aes(x = ageYear, y = heightIn)) + geom_point()

hwp + theme(axis.title.x = element_text(face = "italic", colour = "darkred", size = 14))
```

### Discussion

For the y-axis label, it might also be useful to display the text unrotated, as shown in Figure \@ref(fig:FIG-AXES-AXIS-LABEL-YROTATE) (left). The `\n` in the label represents a newline character:

```{r FIG-AXES-AXIS-LABEL-YROTATE-1, eval=FALSE}
    hwp + ylab("Height\n(inches)") +
        theme(axis.title.y = element_text(angle = 0, face = "italic", size = 14))
```

When you call `element_text()`, the default `angle` is 0, so if you set `axis.title.y` but don't specify the `angle`, it will show in this orientation, with the top of the text pointing up. If you change any other properties of `axis.title.y` and want it to be displayed in its usual orientation, rotated 90 degrees, you must manually specify the `angle` (Figure \@ref(fig:FIG-AXES-AXIS-LABEL-YROTATE), right):

```{r FIG-AXES-AXIS-LABEL-YROTATE-2, eval=FALSE}
    hwp + ylab("Height\n(inches)") +
        theme(axis.title.y = element_text(angle = 90, face = "italic", colour = "darkred",
                                        size = 14))
```


```{r FIG-AXES-AXIS-LABEL-YROTATE, ref.label=c("FIG-AXES-AXIS-LABEL-YROTATE-1", "FIG-AXES-AXIS-LABEL-YROTATE-2"), echo=FALSE, fig.show="hold", fig.cap="Left: y-axis label with angle=0; right: with angle=90"}
```

### See Also

See Recipe \@ref(RECIPE-APPEARANCE-TEXT-APPEARANCE) for more about controlling the appearance of the text.


Showing Lines Along the Axes {#RECIPE-AXES-AXIS-LINES}
----------------------------

### Problem

You want to display lines along the x- and y-axes, but not on the other sides of the graph.

### Solution

Using themes, use `axis.line` (Figure \@ref(fig:FIG-AXES-AXIS-LINE)):

```{r FIG-AXES-AXIS-LINE-1, eval=FALSE}
library(gcookbook) # For the data set

p <- ggplot(heightweight, aes(x = ageYear, y = heightIn)) + geom_point()

p + theme(axis.line = element_line(colour = "black"))
```


### Discussion

If you are starting with a theme that has a border around the plotting
area, like theme_bw(), you will also need to unset panel.border
(Figure \@ref(fig:FIG-AXES-AXIS-LINE), right):

```{r FIG-AXES-AXIS-LINE-2, eval=FALSE}
p + theme_bw() +
    theme(panel.border = element_blank(),
          axis.line = element_line(colour = "black"))
```

(ref:cap-FIG-AXES-AXIS-LINE) Left: scatter plot with axis lines; right: with theme_bw(), panel.border must also be made blank

```{r FIG-AXES-AXIS-LINE, ref.label=c("FIG-AXES-AXIS-LINE-1", "FIG-AXES-AXIS-LINE-2"), echo=FALSE, fig.show="hold", fig.cap="(ref:cap-FIG-AXES-AXIS-LINE)"}
```


If the lines are thick, the ends will only partially overlap (Figure \@ref(fig:FIG-AXES-AXIS-LINE-LINEEND), left). To make them fully overlap (Figure \@ref(fig:FIG-AXES-AXIS-LINE-LINEEND), right), set `lineend="square"`:

```{r FIG-AXES-AXIS-LINE-LINEEND, fig.show="hold", fig.cap="Left: with thick lines, the ends don't fully overlap; right: full overlap with lineend=\"square\""}
# With thick lines, only half overlaps
p + theme_bw() +
    theme(panel.border = element_blank(),
          axis.line = element_line(colour = "black", size = 4))

# Full overlap
p + theme_bw() +
    theme(panel.border = element_blank(),
          axis.line = element_line(colour = "black", size = 4, lineend = "square"))
```

### See Also

For more information about how the theming system works,see Recipe \@ref(RECIPE-APPEARANCE-THEME).


Using a Logarithmic Axis {#RECIPE-AXES-AXIS-LOG}
------------------------

### Problem

You want to use a logarithmic axis for a graph.

### Solution

Use `scale_x_log10()` and/or `scale_y_log10()` (Figure \@ref(fig:FIG-AXES-LOG)):

```{r FIG-AXES-LOG, fig.show="hold", fig.cap="Left: exponentially distributed data with linear-scaled axes; right: with logarithmic axes"}
library(MASS) # For the data set

# The base plot
p <- ggplot(Animals, aes(x = body, y = brain, label = rownames(Animals))) +
     geom_text(size = 3)
p

# With logarithmic x and y scales
p + scale_x_log10() + scale_y_log10()
```

### Discussion

With a log axis, a given visual distance represents a constant *proportional* change; for example, each centimeter on the y-axis might represent a multiplication of the quantity by 10. In contrast, with a linear axis, a given visual distance represents a constant quantity change; each centimeter might represent adding 10 to the quantity.

Some data sets are exponentially distributed on the x-axis, and others on the y-axis (or both). For example, the `Animals` data set from the MASS package contains data on the average brain mass (in g) and body mass (in kg) of various mammals, with a few dinosaurs thrown in for comparison:

```{r}
Animals
```

As shown in Figure \@ref(fig:FIG-AXES-LOG), we can make a scatter plot to visualize the relationship between brain and body mass. With the default linearly scaled axes, it's hard to make much sense of this graph. Because of a few very large animals, the rest of the animals get squished into the lower-left corner-a mouse barely looks different from a triceratops! This is a case where the data is distributed exponentially on both axes.

ggplot will try to make good decisions about where to place the tick marks, but if you don't like them, you can change them by specifying `breaks` and, optionally, `labels`. In the example here, the automatically generated tick marks are spaced farther apart than is ideal. For the y-axis tick marks, we can get a vector of every power of 10 from 10^0^ to 10^3^ like this:

```{r}
10^(0:3)
```

The x-axis tick marks work the same way, but because the range is large, R decides to format the output with scientific notation:

```{r}
10^(-1:5)
```

And then we can use those values as the breaks, as in Figure \@ref(fig:FIG-AXES-LOG-BREAKS) (left):

```{r FIG-AXES-LOG-BREAKS-1, eval=FALSE}
p + scale_x_log10(breaks = 10^(-1:5)) + scale_y_log10(breaks = 10^(0:3))
```

To instead use exponential notation for the break labels (Figure \@ref(fig:FIG-AXES-LOG-BREAKS), right), use the trans_format() function, from the scales package:

```{r FIG-AXES-LOG-BREAKS-2, eval=FALSE}
library(scales)
p + scale_x_log10(breaks = 10^(-1:5),
                  labels = trans_format("log10", math_format(10^.x))) +
    scale_y_log10(breaks = 10^(0:3),
                  labels = trans_format("log10", math_format(10^.x)))
```

```{r FIG-AXES-LOG-BREAKS, ref.label=c("FIG-AXES-LOG-BREAKS-1", "FIG-AXES-LOG-BREAKS-2"), echo=FALSE, fig.show="hold", fig.cap="Left: scatter plot with log~10~ x- and y-axes, and with manually specified breaks; right: with exponents for the tick labels"}
```


Another way to use log axes is to transform the data before mapping it to the *x* and *y* coordinates (Figure \@ref(fig:FIG-AXES-LOG-BEFORE-MAPPING)). Technically, the axes are still linear -- it's the quantity that is log-transformed:

```{r FIG-AXES-LOG-BEFORE-MAPPING, fig.cap="Plot with log transform before mapping to x- and y-axes"}
ggplot(Animals, aes(x = log10(body), y = log10(brain), label = rownames(Animals))) +
    geom_text(size = 3)
```

The previous examples used a log~10~ transformation, but it is possible to use other transformations, such as log~2~ and natural log, as shown in Figure \@ref(fig:FIG-AXES-LOG-2-E). It's a bit more complicated to use these -- `scale_x_log10()` is shorthand, but for these other log scales, we need to spell them out:

```{r FIG-AXES-LOG-2-E, fig.cap="Plot with exponents in tick labels. Notice that different bases are used for the x and y axes."}
library(scales)

# Use natural log on x, and log2 on y
p + scale_x_continuous(trans = log_trans(),
                       breaks = trans_breaks("log", function(x) exp(x)),
                       labels = trans_format("log", math_format(e^.x))) +
    scale_y_continuous(trans = log2_trans(),
                       breaks = trans_breaks("log2", function(x) 2^x),
                       labels = trans_format("log2", math_format(2^.x)))
```

It's possible to use a log axis for just one axis. It is often useful to represent financial data this way, because it better represents proportional change. Figure \@ref(fig:FIG-AXES-LOG-Y) shows Apple's stock price with linear and log y-axes. The default tick marks might not be spaced well for your graph; they can be set with the breaks in the scale:

```{r FIG-AXES-LOG-Y, fig.show="hold", fig.cap="Top: a stock chart with a linear x-axis and log y-axis; bottom: with manual breaks", fig.width=7, fig.height=2}
library(gcookbook) # For the data set

ggplot(aapl, aes(x = date,y = adj_price)) + geom_line()

ggplot(aapl, aes(x = date,y = adj_price)) + geom_line() +
    scale_y_log10(breaks = c(2,10,50,250))
```


Adding Ticks for a Logarithmic Axis {#RECIPE-AXES-AXIS-LOG-TICKS}
-----------------------------------

### Problem

You want to add tick marks with diminishing spacing for a logarithmic axis.

### Solution

Use `annotation_logticks()` (Figure \@ref(fig:FIG-AXES-LOG-TICKS)):

```{r FIG-AXES-LOG-TICKS, fig.cap="Log axes with diminishing tick marks", fig.width=5, fig.height=5}
library(MASS)   # For the data set
library(scales) # For the trans_format function

# Given a vector x, return a vector of powers of 10 that encompasses all values
# in x.
breaks_log10 <- function(x) {
    low <- floor(log10(min(x)))
    high <- ceiling(log10(max(x)))
    
    10^(seq.int(low, high))
}

ggplot(Animals, aes(x = body, y = brain, label = rownames(Animals))) +
    geom_text(size = 3) +
    annotation_logticks() +
    scale_x_log10(breaks = breaks_log10,
                  labels = trans_format(log10, math_format(10^.x))) +
    scale_y_log10(breaks = breaks_log10,
                  labels = trans_format(log10, math_format(10^.x)))
```

We also defined a function, `breaks_log10()`, which returns all powers of 10 that encompass the range of values passed to it. This tells `scale_x_log10` where to put the breaks. For example:

```{r}
breaks_log10(c(0.12, 6))
```

### Discussion

The tick marks created by `annotation_logticks()` are actually geoms inside the plotting area. There is a long tick mark at each power of 10, and a mid-length tick mark at each 5.

To get the colors of the tick marks and the grid lines to match up a bit better, you can use `theme_bw()`.

By default, the minor grid lines appear visually halfway between the major grid lines, but this is not the same place as the "5" tick marks on a logarithmic scale. To get them to be the same, we can supply a function for the scales `minor_breaks`.

We'll define `breaks_5log10()`, which returns 5 times powers of 10 that encompass the values passed to it.

```{r}
breaks_5log10 <- function(x) {
    low <- floor(log10(min(x)/5))
    high <- ceiling(log10(max(x)/5))
    
    5 * 10^(seq.int(low, high))
}

breaks_5log10(c(0.12, 6))
```

Then we'll use that function for the `minor breaks` (Figure \@ref(fig:FIG-AXES-LOG-TICKS-CUSTOM)):

```{r FIG-AXES-LOG-TICKS-CUSTOM, fig.cap="Log axes with ticks at each 5, and fixed coordinate ratio", fig.width=5, fig.height=3.5}
ggplot(Animals, aes(x = body, y = brain, label = rownames(Animals))) +
    geom_text(size = 3) +
    annotation_logticks() +
    scale_x_log10(breaks = breaks_log10,
                  labels = trans_format(log10, math_format(10^.x)),
                  minor_breaks = breaks_5log10) +
    scale_y_log10(breaks = breaks_log10,
                  labels = trans_format(log10, math_format(10^.x)),
                  minor_breaks = breaks_5log10) +
    coord_fixed() +
    theme_bw()
```


Making a Circular Plot {#RECIPE-AXES-POLAR}
-----------------------

### Problem

You want to make a circular plot.

### Solution

Use `coord_polar()`. For this example we'll use the `wind` data set from gcookbook. It contains samples of wind speed and direction for every 5 minutes throughout a day. The direction of the wind is categorized into 15-degree bins, and the speed is categorized into 5 m/s increments:

```{r}
library(gcookbook) # For the data set
wind
```

We'll plot a count of the number of samples at each `SpeedCat` and `DirCat` using `geom_histogram()` (Figure \@ref(fig:FIG-AXES-POLAR)). We'll set `binwidth` to 15 and make the origin of the histogram start at 7.5, so that each bin is centered around 0, 15, 30, etc.:

```{r FIG-AXES-POLAR, fig.cap="Polar plot", fig.width=6, fig.height=5}
ggplot(wind, aes(x = DirCat, fill = SpeedCat)) +
    geom_histogram(binwidth = 15, boundary = -7.5) +
    coord_polar() +
    scale_x_continuous(limits = c(0,360))
```

### Discussion

Be cautious when using polar plots, since they can perceptually distort the data. In the example here, at 210 degrees there are 15 observations with a speed of 1520 and 13 observations with a speed of >20, but a quick glance at the picture makes it appear that there are more observations at >20. There are also three observations with a speed of 1015, but they're barely visible.

In this example we can make the plot a little prettier by reversing the legend, using a different palette, adding an outline, and setting the breaks to some more familiar numbers (Figure \@ref(fig:FIG-AXES-POLAR-CUSTOM)):

```{r FIG-AXES-POLAR-CUSTOM, fig.cap="Polar plot with different colors and breaks", fig.width=6, fig.height=5}
ggplot(wind, aes(x = DirCat, fill = SpeedCat)) +
    geom_histogram(binwidth = 15, boundary = -7.5, colour = "black", size = .25) +
    guides(fill = guide_legend(reverse = TRUE)) +
    coord_polar() +
    scale_x_continuous(limits = c(0,360), breaks = seq(0, 360, by = 45),
                       minor_breaks = seq(0, 360, by = 15)) +
    scale_fill_brewer()
```

It may also be useful to set the starting angle with the start argument, especially when using a discrete variable for *theta*. The starting angle is specified in radians, so if you know the adjustment in degrees, you'll have to convert it to radians:

```{r}
coord_polar(start = -45 * pi / 180)
```

Polar coordinates can be used with other geoms, including lines and points. There are a few important things to keep in mind when using these geoms. First, by default, for the variable that is mapped to *y* (or *r*), the smallest actual value gets mapped to the center; in other words, the smallest data value gets mapped to a visual radius value of 0. You may be expecting a data value of 0 to be mapped to a radius of 0, but to make sure this happens, you'll need to set the limits.

Next, when using a continuous *x* (or *theta*), the smallest and largest data values are merged. Sometimes this is desirable, sometimes not. To change this behavior, you'll need to set the limits.

Finally, the *theta* values of the polar coordinates do not wrap around-it is presently not possible to have a geom that crosses over the starting angle (usually vertical).

I'll illustrate these issues with an example. The following code creates a data frame from the `mdeaths` time series data set and produces the graph shown on the left in Figure \@ref(fig:FIG-AXES-POLAR-CONTINUOUS):

```{r FIG-AXES-POLAR-CONTINUOUS-1, eval=FALSE}
# Put mdeaths time series data into a data frame
md <- data.frame(deaths = as.numeric(mdeaths),
                 month  = as.numeric(cycle(mdeaths))) 

# Calculate average number of deaths in each month
library(dplyr)
md <- md %>%
    group_by(month) %>%
    summarise(deaths = mean(deaths))
md

# Make the base plot
p <- ggplot(md, aes(x = month, y = deaths)) +
    geom_line() +
    scale_x_continuous(breaks = 1:12)

# With coord_polar
p + coord_polar()
```

The first problem is that the data values (ranging from about 1000 to 2100) are mapped to the radius such that the smallest data value is at radius 0. We'll fix this by setting the *y* (or *r*) limits from 0 to the maximum data value, as shown in the graph on the right in Figure \@ref(fig:FIG-AXES-POLAR-CONTINUOUS):

```{r FIG-AXES-POLAR-CONTINUOUS-2, eval=FALSE}
# With coord_polar and y (r) limits going to zero
p + coord_polar() + ylim(0, max(md$deaths))
```

```{r FIG-AXES-POLAR-CONTINUOUS, ref.label=c("FIG-AXES-POLAR-CONTINUOUS-1", "FIG-AXES-POLAR-CONTINUOUS-2"), echo=FALSE, fig.show="hold", fig.cap="Left: polar plot with line (notice the data range of the radius); right: with the radius representing a data range starting from zero", fig.width=3.5, fig.height=3.5}
```

The next problem is that the lowest and highest month values, 1 and 12, are shown at the same angle. We'll fix this by setting the *x* limits from 0 to 12, creating the graph on the left in Figure \@ref(fig:FIG-AXES-POLAR-CONTINUOUS2) (notice that using `xlim()` overrides the `scale_x_continuous()` in `p`, so it no longer displays breaks for each month; see Recipe \@ref(RECIPE-AXES-RANGE) for more information):

```{r FIG-AXES-POLAR-CONTINUOUS2-1, eval=FALSE}
p + coord_polar() + ylim(0, max(md$deaths)) + xlim(0, 12)
```

There's one last issue, which is that the beginning and end aren't connected. To fix that, we need to modify our data frame by adding one row with a month of 0 that has the same value as the row with month 12. This will make the starting and ending points the same, as in the graph on the right in Figure \@ref(fig:FIG-AXES-POLAR-CONTINUOUS2) (alternatively, we could add a row with month 13, instead of month 0):

```{r FIG-AXES-POLAR-CONTINUOUS2-2, eval=FALSE}
# Connect the lines by adding a value for 0 that is the same as 12
mdx <- md[md$month==12, ]
mdx$month <- 0
mdnew <- rbind(mdx, md)

# Make the same plot as before, but with the new data, by using %+%
p %+% mdnew + coord_polar() + ylim(0, max(md$deaths))
```

```{r FIG-AXES-POLAR-CONTINUOUS2, ref.label=c("FIG-AXES-POLAR-CONTINUOUS2-1", "FIG-AXES-POLAR-CONTINUOUS2-2"), echo=FALSE, fig.show="hold", fig.cap="Left: polar plot with theta representing x values from 0 to 12; right: the gap is filled in by adding a dummy data point for month 0", fig.width=3.5, fig.height=3.5}
```

> **Note**
>
> Notice the use of the `%+%` operator. When you add a data frame to a ggplot object with `%+%`, it replaces the default data frame in the ggplot object. In this case, it changed the default data frame for `p` from `md` to `mdnew`.

### See Also

See Recipe \@ref(RECIPE-LEGEND-REVERSE) for more about reversing the direction of a legend.

See Recipe \@ref(RECIPE-AXES-SET-TICKS) for more about specifying which values will have tick marks (breaks) and labels.


Using Dates on an Axis {#RECIPE-AXES-AXIS-DATE}
----------------------

### Problem

You want to use dates on an axis.

### Solution

Map a column of class `Date` to the x- or y-axis. We'll use the `economics` data set for this example:

```{r}
# Look at the structure
str(economics)
```

The column date is an object of class `Date`, and mapping it to x will produce the result shown in Figure \@ref(fig:FIG-AXES-DATE):

```{r FIG-AXES-DATE, fig.cap="Dates on the x-axis", fig.width=7, fig.height=2.5}
ggplot(economics, aes(x = date, y = psavert)) + geom_line()
```

### Discussion

ggplot handles two kinds of time-related objects: dates (objects of class `Date`) and date-times (objects of class `POSIXt`). The difference between these is that `Date` objects represent dates and have a resolution of one day, while `POSIXt` objects represent moments in time and have a resolution of a fraction of a second.

Specifying the breaks is similar to with a numeric axis -- the main difference is in specifying the sequence of dates to use. We'll use a subset of the `economics` data, ranging from mid-1992 to mid-1993. If breaks aren't specified, they will be automatically selected, as shown in Figure \@ref(fig:FIG-AXES-DATE-BREAKS) (top):

```{r FIG-AXES-DATE-BREAKS-1, eval=FALSE}
library(dplyr)
# Take a subset of economics
econ <- subset(economics, date >= as.Date("1992-05-01") &
                          date <  as.Date("1993-06-01"))

# Base plot - without specifying breaks
p <- ggplot(econ, aes(x = date, y = psavert)) + geom_line()
p
```

The breaks can be created by using the `seq()` function with starting and ending dates, and an interval (Figure \@ref(fig:FIG-AXES-DATE-BREAKS), bottom):

```{r FIG-AXES-DATE-BREAKS-2, eval=FALSE}
# Specify breaks as a Date vector
datebreaks <- seq(as.Date("1992-06-01"), as.Date("1993-06-01"), by = "2 month")

# Use breaks, and rotate text labels
p + scale_x_date(breaks = datebreaks) +
    theme(axis.text.x = element_text(angle = 30, hjust = 1))
```

```{r FIG-AXES-DATE-BREAKS, ref.label=c("FIG-AXES-DATE-BREAKS-1", "FIG-AXES-DATE-BREAKS-2"), echo=FALSE, fig.show="hold", fig.cap="Top: with default breaks on the x-axis; bottom: with breaks specified", fig.width=7, fig.height=2.5}
```

Notice that the formatting of the breaks changed. You can specify the formatting by using the `date_format()` function from the scales package. Here we'll use `"%Y %b"`, which results in a format like `"1992 Jun"`, as shown in Figure \@ref(fig:FIG-AXES-DATE-FORMAT):

```{r FIG-AXES-DATE-FORMAT, fig.cap="Line graph with date format specified", fig.width=7, fig.height=2.5}
library(scales)
p + scale_x_date(breaks = datebreaks, labels = date_format("%Y %b")) +
    theme(axis.text.x = element_text(angle = 30, hjust = 1))
```

Common date format options are shown in Table \@ref(tab:TABLE-AXES-DATE-FORMATS). They are to be put in a string that is passed to `date_format()`, and the format specifiers will be replaced with the appropriate values. For example, if you use `"%B %d, %Y"`, it will result in labels like "June 01, 1992".

Table: (\#tab:TABLE-AXES-DATE-FORMATS) Date format options

+-----------------------------------+-----------------------------------+
| Option                            | Description                       |
+===================================+===================================+
| `%Y`                              | Year with century (2012)          |
+-----------------------------------+-----------------------------------+
| `%y`                              | Year without century (12)         |
+-----------------------------------+-----------------------------------+
| `%m`                              | Month as a decimal number (08)    |
+-----------------------------------+-----------------------------------+
| `%b`                              | Abbreviated month name in current |
|                                   | locale (Aug)                      |
+-----------------------------------+-----------------------------------+
| `%B`                              | Full month name in current locale |
|                                   | (August)                          |
+-----------------------------------+-----------------------------------+
| `%d`                              | Day of month as a decimal number  |
|                                   | (04)                              |
+-----------------------------------+-----------------------------------+
| `%U`                              | Week of the year as a decimal     |
|                                   | number, with Sunday as the first  |
|                                   | day of the week (0053)           |
+-----------------------------------+-----------------------------------+
| `%W`                              | Week of the year as a decimal     |
|                                   | number, with Monday as the first  |
|                                   | day of the week (0053)           |
+-----------------------------------+-----------------------------------+
| `%w`                              | Day of week (06, Sunday is 0)    |
+-----------------------------------+-----------------------------------+
| `%a`                              | Abbreviated weekday name (Thu)    |
+-----------------------------------+-----------------------------------+
| `%A`                              | Full weekday name (Thursday)      |
+-----------------------------------+-----------------------------------+


Some of these items are specific to the computer's locale. Months and days have different names in different languages (the examples here are generated with a US locale). You can change the locale with `Sys.setlocale()`. For example, this will change the date formatting to use an Italian locale:

```{r, eval=FALSE}
# Mac and Linux
Sys.setlocale("LC_TIME", "it_IT.UTF-8")

# Windows
Sys.setlocale("LC_TIME", "italian")
```

Note that the locale names may differ between platforms, and your computer must have support for the locale installed at the operating system level.

### See Also

See `?Sys.setlocale` for more about setting the locale.

See `?strptime` for information about converting strings to dates, and for information about formatting the date output.


Using Relative Times on an Axis {#RECIPE-AXES-TIME-REL}
-------------------------------

### Problem

You want to use relative times on an axis.

### Solution

Times are commonly stored as numbers. For example, the time of day can be stored as a number representing the hour. Time can also be stored as a number representing the number of minutes or seconds from some starting time. In these cases, you map a value to the x- or y-axis and use a formatter to generate the appropriate axis labels (Figure \@ref(fig:FIG-AXES-TIME-REL)):

```{r FIG-AXES-TIME-REL, fig.show="hold", fig.cap="Top: relative times on x-axis; bottom: with formatted times", fig.width=7, fig.height=2.5}
# Convert WWWusage time-series object to data frame
www <- data.frame(minute = as.numeric(time(WWWusage)),
                  users  = as.numeric(WWWusage))

# Define a formatter function - converts time in minutes to a string
timeHM_formatter <- function(x) {
    h <- floor(x/60)
    m <- floor(x %% 60)
    lab <- sprintf("%d:%02d", h, m) # Format the strings as HH:MM
    return(lab)
}

# Default x axis
ggplot(www, aes(x = minute, y = users)) + geom_line()

# With formatted times
ggplot(www, aes(x = minute, y = users)) + geom_line() +
    scale_x_continuous(name = "time", breaks = seq(0, 100, by = 10),
                       labels = timeHM_formatter)
```


### Discussion

In some cases it might be simpler to specify the breaks and labels manually, with something like this:

```{r, eval=FALSE}
scale_x_continuous(breaks = c(0, 20, 40, 60, 80, 100),
    labels = c("0:00", "0:20", "0:40", "1:00", "1:20", "1:40"))
```

In the preceding example, we used the `timeHM_formatter()` function to convert the numeric time (in minutes) to a string like `"1:10"`:

```{r}
timeHM_formatter(c(0, 50, 51, 59, 60, 130, 604))
```

To convert to HH:MM:SS format, you can use the following formatter
function:

```{r}
timeHMS_formatter <- function(x) {
    h <- floor(x/3600)
    m <- floor((x/60) %% 60)
    s <- round(x %% 60)                       # Round to nearest second
    lab <- sprintf("%02d:%02d:%02d", h, m, s) # Format the strings as HH:MM:SS
    lab <- sub("^00:", "", lab)               # Remove leading 00: if present
    lab <- sub("^0", "", lab)                 # Remove leading 0 if present
    return(lab)
}
```

Running it on some sample numbers yields:

```{r}
timeHMS_formatter(c(20, 3000, 3075, 3559.2, 3600, 3606, 7813.8))
```

### See Also

See Recipe \@ref(RECIPE-DATAPREP-TIMESERIES) for information about converting time series objects to data frames.

<!--chapter:end:ch08.Rmd-->

---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
# This block needs cache=FALSE to set fig.width and fig.height, and have those
# persist across cached builds.

source("utils.R", local = TRUE)
knitr::opts_chunk$set(fig.width = 3.5, fig.height = 3.5)
```

Controlling the Overall Appearance of Graphs {#CHAPTER-APPEARANCE}
============================================

In this chapter I'll discuss how to control the overall appearance of graphics made by ggplot2. The grammar of graphics that underlies ggplot2 is concerned with how data is processed and displayed -- it's not concerned with things like fonts, background colors, and so on. When it comes to presenting your data, there's a good chance that you'll want to tune the appearance of these things. ggplot2's theming system provides control over the appearance of non-data elements. I touched on the theme system in the previous chapter, and here I'll explain a bit more about how it works.

Setting the Title of a Graph {#RECIPE-APPEARANCE-TITLE}
----------------------------

### Problem

You want to set the title of a graph.

### Solution

Set title with `ggtitle()`, as shown in Figure \@ref(fig:FIG-APPEARANCE-TITLE):

(ref:cap-FIG-APPEARANCE-TITLE) Left: scatter plot with a title added; right: with a `\n` for a newline

```{r FIG-APPEARANCE-TITLE, fig.show="hold", fig.cap="(ref:cap-FIG-APPEARANCE-TITLE)"}
library(gcookbook) # For the data set

p <- ggplot(heightweight, aes(x = ageYear, y = heightIn)) + geom_point()

p + ggtitle("Age and Height of Schoolchildren")

# Use \n for a newline
p + ggtitle("Age and Height\nof Schoolchildren")
```

### Discussion

`ggtitle()` is equivalent to using `labs(title = "Title text")`.

If you want to move the title inside the plotting area, you can use one of two methods, both of which are a little bit of a hack (Figure \@ref(fig:FIG-APPEARANCE-TITLE-INSIDE)). The first method is to use `ggtitle()` with a negative `vjust` value. The drawback of this method is that it still reserves blank space above the plotting region for the title.

The second method is to instead use a text annotation, setting its *x* position to the middle of the *x* range and its *y* position to `Inf`, which places it at the top of the plotting region. This also requires a positive `vjust` value to bring the text fully inside the plotting region:

```{r FIG-APPEARANCE-TITLE-INSIDE, fig.show="hold", fig.cap="Left: title with ggtitle and a negative `vjust()` value (note the extra space above the plotting area); right: with a text annotation at the top of the figure"}
# Move the title inside
p + ggtitle("Age and Height of Schoolchildren") +
    theme(plot.title = element_text(vjust = -8))

# Use a text annotation instead
p + annotate("text", x = mean(range(heightweight$ageYear)), y = Inf,
             label = "Age and Height of Schoolchildren", vjust = 1.5, size = 4.5)
```


Changing the Appearance of Text {#RECIPE-APPEARANCE-TEXT-APPEARANCE}
-------------------------------

### Problem

You want to change the appearance of text in a plot.

### Solution

To set the appearance of theme items such as the title, axis labels, and axis tick marks, use theme() and set the item with `element_text()`. For example, `axis.title.x` controls the appearance of the x-axis label and `plot.title` controls the appearance of the title text (Figure \@ref(fig:FIG-APPEARANCE-TEXT-APPEARANCE-THEME)):

```{r FIG-APPEARANCE-TEXT-APPEARANCE-THEME, fig.show="hold", fig.cap='Left: `axis.title.x`; right: `plot.title`'}
library(gcookbook) # For the data set

# Base plot
p <- ggplot(heightweight, aes(x = ageYear, y = heightIn)) + geom_point()

# Controlling appearance of theme items
p + theme(axis.title.x = element_text(size = 16, lineheight = .9, family = "Times",
                                    face = "bold.italic", colour = "red"))

p + ggtitle("Age and Height\nof Schoolchildren") +
    theme(plot.title = element_text(size = rel(1.5), lineheight = .9, family = "Times",
                                  face = "bold.italic", colour = "red"))

# rel(1.5) means that the font will be 1.5 times the base font size of the theme.
# For theme elements, font size is in points.
```

To set the appearance of text geoms (text that's in the plot itself, with `geom_text()` or `annotate()`), set the text properties. For example (Figure \@ref(fig:FIG-APPEARANCE-TEXT-APPEARANCE-GEOM)):


(ref:cap-FIG-APPEARANCE-TEXT-APPEARANCE-GEOM) Left: `annotate("text")`; right: `geom_text()`

```{r FIG-APPEARANCE-TEXT-APPEARANCE-GEOM, fig.show="hold", fig.cap="(ref:cap-FIG-APPEARANCE-TEXT-APPEARANCE-GEOM)"}
p + annotate("text", x = 15, y = 53, label = "Some text", size = 7, family = "Times",
        fontface = "bold.italic", colour = "red")

p + geom_text(aes(label = weightLb), size = 4, family = "Times", colour = "red")

# For text geoms, font size is in mm
```


### Discussion

There are two kinds of text items in ggplot2: theme elements and text geoms. Theme elements are all the non-data elements in the plot: the title, legends, and axes. Text geoms are things that are part of the plot itself, and reflect the data content.

There are differences in the parameters, as shown in Table \@ref(tab:TABLE-APPEARANCE-PROPERTIES).

Table: (\#tab:TABLE-APPEARANCE-PROPERTIES) Text properties of theme elements and text geoms

+----------------------+----------------------+-----------------------+
| Theme elements       | Text geoms           | Description           |
+======================+======================+=======================+
| `family`             | `family`             | Helvetica, Times,     |
|                      |                      | Courier               |
+----------------------+----------------------+-----------------------+
| `face`               | `fontface`           | `plain`, `bold`, `italic,` |
|                      |                      | `bold.italic`         |
+----------------------+----------------------+-----------------------+
| `colour`             | `colour`             | Color (name or        |
|                      |                      | "#RRGGBB")            |
+----------------------+----------------------+-----------------------+
| `size`               | `size`               | Font size (in points  |
|                      |                      | for theme elements;   |
|                      |                      | in mm for geoms)      |
+----------------------+----------------------+-----------------------+
| `hjust`              | `hjust`              | Horizontal alignment: |
|                      |                      | 0=left, 0.5=center,   |
|                      |                      | 1=right               |
+----------------------+----------------------+-----------------------+
| `vjust`              | `vjust`              | Vertical alignment:   |
|                      |                      | 0=bottom, 0.5=middle, |
|                      |                      | 1=top                 |
+----------------------+----------------------+-----------------------+
| `angle`              | `angle`              | Angle in degrees      |
+----------------------+----------------------+-----------------------+
| `lineheight`         | `lineheight`         | Line spacing          |
|                      |                      | multiplier            |
+----------------------+----------------------+-----------------------+


The theme elements are listed in Table \@ref(tab:TABLE-APPEARANCE-THEME-TEXT-ELEMENTS). Most of them are straightforward. Some are shown in Figure \@ref(fig:FIG-APPEARANCE-TEXT-APPEARANCE-PROPERTIES).

Table: (\#tab:TABLE-APPEARANCE-THEME-TEXT-ELEMENTS) Theme items that control text appearance in `theme()`


+-----------------------------------+-----------------------------------+
| Element name                      | Description                       |
+===================================+===================================+
| `axis.title`                      | Appearance of axis labels on both |
|                                   | axes                              |
+-----------------------------------+-----------------------------------+
| `axis.title.x`                    | Appearance of x-axis label        |
+-----------------------------------+-----------------------------------+
| `axis.title.y`                    | Appearance of y-axis label        |
+-----------------------------------+-----------------------------------+
| `axis.ticks`                      | Appearance of tick labels on both |
|                                   | axes                              |
+-----------------------------------+-----------------------------------+
| `axis.ticks.x`                    | Appearance of x tick labels       |
+-----------------------------------+-----------------------------------+
| `axis.ticks.y`                    | Appearance of y tick labels       |
+-----------------------------------+-----------------------------------+
| `legend.title`                    | Appearance of legend title        |
+-----------------------------------+-----------------------------------+
| `legend.text`                     | Appearance of legend items        |
+-----------------------------------+-----------------------------------+
| `plot.title`                      | Appearance of overall plot title  |
+-----------------------------------+-----------------------------------+
| `strip.text`                      | Appearance of facet labels in     |
|                                   | both directions                   |
+-----------------------------------+-----------------------------------+
| `strip.text.x`                    | Appearance of horizontal facet    |
|                                   | labels                            |
+-----------------------------------+-----------------------------------+
| `strip.text.y`                    | Appearance of vertical facet      |
|                                   | labels                            |
+-----------------------------------+-----------------------------------+


```{r FIG-APPEARANCE-TEXT-APPEARANCE-PROPERTIES, fig.cap="Aligning with `hjust` and `vjust`, and spacing with `lineheight`", echo=FALSE, fig.width=8, fig.height=4}
ggplot(data.frame()) +
    geom_vline(xintercept=1, linetype="dashed", colour="red") +
    annotate("text", x=1, y=1,    label="hjust=1",   hjust=1) +
    annotate("text", x=1, y=0.75, label="hjust=0.5", hjust=0.5) +
    annotate("text", x=1, y=0.5,  label="hjust=0",   hjust=0) +
    geom_hline(yintercept=2, linetype="dashed", colour="red") +
    annotate("text", x=2.5, y=2, label="vjust=1",   vjust=1) +
    annotate("text", x=2,   y=2, label="vjust=0.5", vjust=0.5) +
    annotate("text", x=1.5, y=2, label="vjust=0",   vjust=0) +
    annotate("text", x=1.75, y=1, label="spacing with\nlineheight=0.9", lineheight=0.9) +
    annotate("text", x=2.5, y=1, label="spacing with\nlineheight=1", lineheight=1) +
    annotate("text", x=3.25, y=1, label="spacing with\nlineheight=1.2", lineheight=1.2) +
    xlim(0.5, 3.5) + ylim(0,2.5)
```


Using Themes {#RECIPE-APPEARANCE-THEME}
------------

### Problem

You want to use premade themes to control the overall plot appearance.

### Solution

To use a premade theme, add `theme_bw()` or `theme_grey()` (Figure \@ref(fig:FIG-APPEARANCE-THEME)):

(ref:cap-FIG-APPEARANCE-THEME) Left: scatter plot with `theme_grey()` (the default); right: with `theme_bw()`

```{r FIG-APPEARANCE-THEME, fig.show="hold", fig.cap="(ref:cap-FIG-APPEARANCE-THEME)"}
library(gcookbook) # For the data set

# Base plot
p <- ggplot(heightweight, aes(x = ageYear, y = heightIn)) + geom_point()

# Grey theme (the default)
p + theme_grey()

# Black-and-white theme
p + theme_bw()
```

### Discussion

Some commonly used properties of theme elements in ggplot2 are those things that are controlled by `theme()`. Most of these things, like the title, legend, and axes, are outside the plot area, but some of them are inside the plot area, such as grid lines and the background coloring.

The two included themes are `theme_grey()` and `theme_bw()`, but it is also possible to create your own.

You can set the base font family and size with either of the included themes (the default base font family is Helvetica, and the default size is 12):

```{r, eval=FALSE}
p + theme_grey(base_size = 16, base_family = "Times")
```

You can set the default theme for the current R session with `theme_set()`, although it's generally not a good idea to set options globally because it may affect other plots that are unrelated to your current project:

```{r, eval=FALSE}
# Set default theme for current session
theme_set(theme_bw())

# This will use theme_bw()
p

# Reset the default theme back to theme_grey()
theme_set(theme_grey())
```

### See Also

To modify a theme, see Recipe \@ref(RECIPE-APPEARANCE-THEME-MODIFY).

To create your own themes, see Recipe \@ref(RECIPE-APPEARANCE-THEME-CREATE).

See `?theme` to see all the available theme properties.


Changing the Appearance of Theme Elements {#RECIPE-APPEARANCE-THEME-MODIFY}
-----------------------------------------

### Problem

You want to change the appearance of theme elements.

### Solution

To modify a theme, add `theme()` with a corresponding `element_`*xx* object. These include `element_line`, `element_rect`, and `element_text`. The following code shows how to modify many of the commonly used theme properties (Figure \@ref(fig:FIG-APPEARANCE-THEME-MODIFY)):

```{r FIG-APPEARANCE-THEME-MODIFY, fig.show="hold", fig.cap="Clockwise from top left: modifying theme properties for the plotting area, the legend, the facets, and the text items"}
library(gcookbook) # For the data set

# Base plot
p <- ggplot(heightweight, aes(x = ageYear, y = heightIn, colour = sex)) + geom_point()

# Options for the plotting area
p + theme(
    panel.grid.major = element_line(colour = "red"),
    panel.grid.minor = element_line(colour = "red", linetype = "dashed", size = 0.2),
    panel.background = element_rect(fill = "lightblue"),
    panel.border = element_rect(colour = "blue", fill = NA, size = 2))

# Options for text items
p + ggtitle("Plot title here") +
    theme(
    axis.title.x = element_text(colour = "red", size = 14),
    axis.text.x  = element_text(colour = "blue"),
    axis.title.y = element_text(colour = "red", size = 14, angle = 90),
    axis.text.y  = element_text(colour = "blue"),
    plot.title = element_text(colour = "red", size = 20, face = "bold"))

# Options for the legend
p + theme(
    legend.background = element_rect(fill = "grey85", colour = "red", size = 1),
    legend.title = element_text(colour = "blue", face = "bold", size = 14),
    legend.text = element_text(colour = "red"),
    legend.key = element_rect(colour = "blue", size = 0.25))

# Options for facets
p + facet_grid(sex ~ .) + theme(
    strip.background = element_rect(fill = "pink"),
    strip.text.y = element_text(size = 14, angle = -90, face = "bold"))
    # strip.text.x is the same, but for horizontal facets
```

### Discussion

If you want to use a saved theme and tweak a few parts of it with `theme()`, the `theme()` must come after the theme specification. Otherwise, anything set by `theme()` will be unset by the theme you add:

```{r eval=FALSE}
# theme() has no effect if before adding a complete theme
p + theme(axis.title.x = element_text(colour = "red")) + theme_bw()

# theme() works if after a complete theme
p + theme_bw() + theme(axis.title.x = element_text(colour = "red", size = 12))
```

Many of the commonly used theme properties are shown in Table \@ref(tab:TABLE-APPEARANCE-THEME-ELEMENTS).


Table: (\#tab:TABLE-APPEARANCE-THEME-ELEMENTS) Theme items that control text appearance in `theme()`

+----------------------+----------------------+-----------------------+
| Name                 | Description          | Element type          |
+======================+======================+=======================+
| `text`               | All text elements    | `element_text()`      |
+----------------------+----------------------+-----------------------+
| `rect`               | All rectangular      | `element_rect()`      |
|                      | elements             |                       |
+----------------------+----------------------+-----------------------+
| `line`               | All line elements    | `element_line()`      |
+----------------------+----------------------+-----------------------+
| `axis.line`          | Lines along axes     | `element_line()`      |
+----------------------+----------------------+-----------------------+
| `axis.title`         | Appearance of both   | `element_text()`      |
|                      | axis labels          |                       |
+----------------------+----------------------+-----------------------+
| `axis.title.x`       | X-axis label         | `element_text()`      |
|                      | appearance           |                       |
+----------------------+----------------------+-----------------------+
| `axis.title.y`       | Y-axis label         | `element_text()`      |
|                      | appearance           |                       |
+----------------------+----------------------+-----------------------+
| `axis.text`          | Appearance of tick   | `element_text()`      |
|                      | labels on both axes  |                       |
+----------------------+----------------------+-----------------------+
| `axis.text.x `       | X-axis tick label    | `element_text()`      |
|                      | appearance           |                       |
+----------------------+----------------------+-----------------------+
| `axis.text.y`        | Y-axis tick label    | `element_text()`      |
|                      | appearance           |                       |
+----------------------+----------------------+-----------------------+
| `legend.background`  | Background of legend | `element_rect()`      |
+----------------------+----------------------+-----------------------+
| `legend.text`        | Legend item          | `element_text()`      |
|                      | appearance           |                       |
+----------------------+----------------------+-----------------------+
| `legend.title`       | Legend title         | `element_text()`      |
|                      | appearance           |                       |
+----------------------+----------------------+-----------------------+
| `legend.position`    | Position of the      | `"left"`, `"right"`,  |
|                      | legend               | `"bottom"`, `"top"`, or |
|                      |                      | two-element numeric   |
|                      |                      | vector if you wish to |
|                      |                      | place it inside the   |
|                      |                      | plot area (for more   |
|                      |                      | on legend placement,  |
|                      |                      | see Recipe            |
|                      |                      | \@ref(RECIPE-LEGEND-POSITION)) |
+----------------------+----------------------+-----------------------+
| `panel.background`   | Background of        | `element_rect()`      |
|                      | plotting area        |                       |
+----------------------+----------------------+-----------------------+
| `panel.border`       | Border around        | `element_rect(linetype="dashed")` |
|                      | plotting area        |                       |
+----------------------+----------------------+-----------------------+
| `panel.grid.major`   | Major grid lines     | `element_line()`      |
|                      |                      |                       |
+----------------------+----------------------+-----------------------+
| `panel.grid.major.x` | Major grid lines,    | `element_line()`      |
|                      | vertical             |                       |
+----------------------+----------------------+-----------------------+
| `panel.grid.major.y` | Major grid lines,    | `element_line()`      |
|                      | horizontal           |                       |
+----------------------+----------------------+-----------------------+
| `panel.grid.minor`   | Minor grid lines     | `element_line()`      |
|                      |                      |                       |
+----------------------+----------------------+-----------------------+
| `panel.grid.minor.x` | Minor grid lines,    | `element_line()`      |
|                      | vertical             |                       |
+----------------------+----------------------+-----------------------+
| `panel.grid.minor.y` | Minor grid lines,    | `element_line()`      |
|                      | horizontal           |                       |
+----------------------+----------------------+-----------------------+
| `plot.background`    | Background of the    | `element_rect(fill="white", colour=NA)`  |
|                      | entire plot          |                       |
+----------------------+----------------------+-----------------------+
| `plot.title`         | Title text           | `element_text()`      |
|                      | appearance           |                       |
+----------------------+----------------------+-----------------------+
| `strip.background`   | Background of facet  | `element_rect()`      |
|                      | labels               |                       |
+----------------------+----------------------+-----------------------+
| `strip.text`         | Text appearance for  | `element_text()`      |
|                      | vertical and         |                       |
|                      | horizontal facet     |                       |
|                      | labels               |                       |
+----------------------+----------------------+-----------------------+
| `strip.text.x`       | Text appearance for  | `element_text()`      |
|                      | horizontal facet     |                       |
|                      | labels               |                       |
+----------------------+----------------------+-----------------------+
| `strip.text.y`       | Text appearance for  | `element_text()`      |
|                      | vertical facet       |                       |
|                      | labels               |                       |
+----------------------+----------------------+-----------------------+


Creating Your Own Themes {#RECIPE-APPEARANCE-THEME-CREATE}
------------------------

### Problem

You want to create your own theme.

### Solution

You can create your own theme by adding elements to an existing theme (Figure \@ref(fig:FIG-APPEARANCE-THEME-SAVE)):

```{r FIG-APPEARANCE-THEME-SAVE, fig.cap="A modified default theme"}
library(gcookbook) # For the data set

# Start with theme_bw() and modify a few things
mytheme <- theme_bw() +
    theme(text       = element_text(colour = "red"),
          axis.title = element_text(size = rel(1.25)))

# Base plot
p <- ggplot(heightweight, aes(x = ageYear, y = heightIn)) + geom_point()

# Plot with modified theme
p + mytheme
```

### Discussion

With ggplot2, you can not only make use of the default themes, but also modify these themes to suit your needs. You can add new theme elements or change the values of existing ones, and apply your changes globally or to a single plot.

### See Also

The options for modifying themes are listed in Recipe \@ref(RECIPE-APPEARANCE-THEME-MODIFY).


Hiding Grid Lines {#RECIPE-APPEARANCE-HIDE-GRIDLINES}
-----------------

### Problem

You want to hide the grid lines in a plot.

### Solution

The major grid lines (those that align with the tick marks) are controlled with `panel.grid.major`. The minor grid lines (the ones between the major lines) are controlled with `panel.grid.minor`. This will hide them both, as shown in Figure \@ref(fig:FIG-APPEARANCE-HIDE-GRIDLINES) (left):

```{r FIG-APPEARANCE-HIDE-GRIDLINES-1, eval=FALSE}
library(gcookbook) # For the data set

p <- ggplot(heightweight, aes(x = ageYear, y = heightIn)) + geom_point()

p + theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank())
```

### Discussion

It's possible to hide just the vertical or horizontal grid lines, as shown in the middle and righthand graphs in Figure \@ref(fig:FIG-APPEARANCE-HIDE-GRIDLINES), with `panel.grid.major.x`, `panel.grid.major.y`, `panel.grid.minor.x`, and `panel.grid.minor.y`:

```{r FIG-APPEARANCE-HIDE-GRIDLINES-2, eval=FALSE}
# Hide the vertical grid lines (which intersect with the x-axis)
p + theme(panel.grid.major.x = element_blank(),
          panel.grid.minor.x = element_blank())

# Hide the horizontal grid lines (which intersect with the y-axis)
p + theme(panel.grid.major.y = element_blank(),
          panel.grid.minor.y = element_blank())
```

```{r FIG-APPEARANCE-HIDE-GRIDLINES, ref.label=c("FIG-APPEARANCE-HIDE-GRIDLINES-1", "FIG-APPEARANCE-HIDE-GRIDLINES-2"), echo=FALSE, fig.show="hold", fig.cap="Left: no grid lines; middle: no vertical lines; right: no horizontal lines", fig.height=2.5, fig.width=2.5}
```

<!--chapter:end:ch09.Rmd-->

---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
# This block needs cache=FALSE to set fig.width and fig.height, and have those
# persist across cached builds.

source("utils.R", local = TRUE)
knitr::opts_chunk$set(fig.width = 3.5, fig.height = 3.5)
```

Legends {#CHAPTER-LEGEND}
=======

Like the x- or y-axis, a legend is a guide: it shows people how to map visual (aesthetic) properties back to data values.

Removing the Legend {#RECIPE-LEGEND-REMOVE}
-------------------

### Problem

You want to remove the legend from a graph.

### Solution

Use `guides()`, and specify the scale that should have its legend removed (Figure \@ref(fig:FIG-LEGEND-REMOVE)):

```{r FIG-LEGEND-REMOVE, fig.cap="Left: default appearance; right: with legend removed"}
# The base plot (with legend)
p <- ggplot(PlantGrowth, aes(x = group, y = weight, fill = group)) + geom_boxplot()
p

# Remove the legend for fill
p + guides(fill = FALSE)
```

### Discussion

Another way to remove a legend is to set `guide=FALSE` in the scale. This will result in the exact same output as the preceding code:

```{r eval=FALSE}
# Remove the legend for fill
p + scale_fill_discrete(guide = FALSE)
```

Yet another way to remove the legend is to use the theming system. If you have more than one aesthetic mapping with a legend (`color` and `shape`, for example), this will remove legends for all of them:

```{r eval=FALSE}
p + theme(legend.position = "none")
```

Sometimes a legend is redundant, or it is supplied in another graph that will be displayed with the current one. In these cases, it can be useful to remove the legend from a graph.

In the example used here, the colors provide the same information that is on the x-axis, so the legend is unnecessary. Notice that with the legend removed, the area used for graphing the data is larger. If you want to achieve the same proportions in the graphing area, you will need to adjust the overall dimensions of the graph.

When a variable is mapped to `fill`, the default scale used is `scale_fill_discrete()` (equivalent to `scale_fill_hue()`), which maps the factor levels to colors that are equally spaced around the color wheel. There are other scales for `fill`, such as `scale_fill_manual()`. If you use scales for other aesthetics, such as `colour` (for lines and points) or `shape` (for points), you must use the appropriate scale. Commonly used scales include:

* `scale_fill_discrete()`
* `scale_fill_hue()`
* `scale_fill_manual()`
* `scale_fill_grey()`
* `scale_fill_brewer()`
* `scale_colour_discrete()`
* `scale_colour_hue()`
* `scale_colour_manual()`
* `scale_colour_grey()`
* `scale_colour_brewer()`
* `scale_shape_manual()`
* `scale_linetype()`


Changing the Position of a Legend {#RECIPE-LEGEND-POSITION}
---------------------------------

### Problem

You want to move the legend from its default place on the right side.

### Solution

Use `theme(legend.position=...)`. It can be put on the top, left, right, or bottom by using one of those strings as the position (Figure \@ref(fig:FIG-LEGEND-POSITION), left):

```{r FIG-LEGEND-POSITION, fig.cap="Left: legend on top; right: legend inside of graphing area"}
p <- ggplot(PlantGrowth, aes(x = group, y = weight, fill = group)) +
    geom_boxplot() +
    scale_fill_brewer(palette = "Pastel2")

p + theme(legend.position = "top")
```

The legend can also be placed inside the graphing area by specifying a coordinate position, as in `legend.position=c(1,0)` (Figure \@ref(fig:FIG-LEGEND-POSITION), right). The coordinate space starts at (0, 0) in the bottom left and goes to (1, 1) in the top right.

### Discussion

You can also use `legend.justification` to set which *part* of the legend box is set to the position at `legend.position`. By default, the center of the legend (.5, .5) is placed at the coordinate, but it is often useful to specify a different point.

For example, this will place the bottom-right corner of the legend (1, 0) in the bottom-right corner of the graphing area (1, 0):

```{r FIG-LEGEND-POSITION-JUSTIFICATION-1, eval=FALSE}
p + theme(legend.position = c(1, 0), legend.justification = c(1, 0))
```

And this will place the top-right corner of the legend in the top-right
corner of the graphing area, as in the graph on the right in
Figure \@ref(fig:FIG-LEGEND-POSITION-JUSTIFICATION):

```{r FIG-LEGEND-POSITION-JUSTIFICATION-2, eval=FALSE}
p + theme(legend.position = c(1, 1), legend.justification = c(1, 1))
```

```{r FIG-LEGEND-POSITION-JUSTIFICATION, ref.label=c("FIG-LEGEND-POSITION-JUSTIFICATION-1", "FIG-LEGEND-POSITION-JUSTIFICATION-2"), echo=FALSE, fig.cap="Left: legend in bottom-right corner; right: legend in top-right corner"}
```



When placing the legend inside of the graphing area, it may be helpful to add an opaque border to set it apart (Figure \@ref(fig:FIG-LEGEND-POSITION-BACKGROUND), left):

```{r FIG-LEGEND-POSITION-BACKGROUND-1}
p + theme(legend.position = c(.85, .2)) +
    theme(legend.background = element_rect(fill = "white", colour = "black"))
```

You can also remove the border around its elements so that itblends in
(Figure \@ref(fig:FIG-LEGEND-POSITION-BACKGROUND), right):

```{r FIG-LEGEND-POSITION-BACKGROUND-2}
p + theme(legend.position = c(.85, .2)) +
    theme(legend.background = element_blank()) +  # Remove overall border
    theme(legend.key = element_blank())           # Remove border around each item
```

```{r FIG-LEGEND-POSITION-BACKGROUND, ref.label=c("FIG-LEGEND-POSITION-BACKGROUND-1", "FIG-LEGEND-POSITION-BACKGROUND-2"), echo=FALSE, fig.cap="Left: legend with opaque background and outline; right: with no background or outlines"}
```


Changing the Order of Items in a Legend {#RECIPE-LEGEND-ORDER}
---------------------------------------

### Problem

You want to change the order of the items in a legend.

### Solution

Set the limits in the scale to the desired order (Figure \@ref(fig:FIG-LEGEND-ORDER)):

```{r FIG-LEGEND-ORDER, fig.cap="Left: default order for legend; right: modified order"}
# The base plot
p <- ggplot(PlantGrowth, aes(x = group, y = weight, fill = group)) + geom_boxplot()
p

# Change the order of items
p + scale_fill_discrete(limits = c("trt1", "trt2", "ctrl"))
```

### Discussion

Note that the order of the items on the x-axis did not change. To do that, you would have to set the limits of `scale_x_discrete()` (Recipe \@ref(RECIPE-AXIS-ORDER)), or change the data to have a different factor level order (Recipe \@ref(RECIPE-DATAPREP-FACTOR-REORDER)).

In the preceding example, group was mapped to the fill aesthetic. By default this uses `scale_fill_discrete()` (which is the sameas `scale_fill_hue()`), which maps the factor levels to colors that are equally spaced around the color wheel. We could have used a different `scale_fill_`**`xxx`**`()`, though. For example, we could use a grey palette (Figure \@ref(fig:FIG-LEGEND-ORDER2), left):

```{r FIG-LEGEND-ORDER2-1, eval=FALSE}
p + scale_fill_grey(start = .5, end = 1, limits = c("trt1", "trt2", "ctrl"))
```

Or we could use a palette from RColorBrewer
(Figure \@ref(fig:FIG-LEGEND-ORDER2), right):

```{r FIG-LEGEND-ORDER2-2, eval=FALSE}
p + scale_fill_brewer(palette = "Pastel2", limits = c("trt1", "trt2", "ctrl"))
```

```{r FIG-LEGEND-ORDER2, ref.label=c("FIG-LEGEND-ORDER2-1", "FIG-LEGEND-ORDER2-2"), echo=FALSE, fig.cap="Left: modified order with a grey palette; right: with a palette from RColorBrewer"}
```

All the previous examples were for fill. If you use scales for other aesthetics, such as colour (for lines and points) or shape (for points), you must use the appropriate scale. Commonly used scales include:

* `scale_fill_discrete()`
* `scale_fill_hue()`
* `scale_fill_manual()`
* `scale_fill_grey()`
* `scale_fill_brewer()`
* `scale_colour_discrete()`
* `scale_colour_hue()`
* `scale_colour_manual()`
* `scale_colour_grey()`
* `scale_colour_brewer()`
* `scale_shape_manual()`
* `scale_linetype()`

By default, using `scale_fill_discrete()` is equivalent to using `scale_fill_hue()`; the same is true for color scales.

### See Also

To reverse the order of the legend, see Recipe \@ref(RECIPE-LEGEND-REVERSE).

To change the order of factor levels, see Recipe \@ref(RECIPE-DATAPREP-FACTOR-REORDER). To order legend items based on values in another variable, see Recipe \@ref(RECIPE-DATAPREP-FACTOR-REORDER-VALUE).


Reversing the Order of Items in a Legend {#RECIPE-LEGEND-REVERSE}
----------------------------------------

### Problem

You want to reverse the order of items in a legend.

### Solution

Add guides (`fill=guide_legend(reverse=TRUE)`) to reverse the order of the legend, as in Figure \@ref(fig:FIG-LEGEND-TITLE-REVERSE) (for other aesthetics, replace `fill` with the name of the aesthetic, such as `colour` or `size`):

```{r FIG-LEGEND-TITLE-REVERSE, fig.cap="Left: default order for legend; right: reversed order"}
# The base plot
p <- ggplot(PlantGrowth, aes(x = group, y = weight, fill = group)) + geom_boxplot()
p

# Reverse the legend order
p + guides(fill = guide_legend(reverse = TRUE))
```

### Discussion

It is also possible to control the legend when specifying the scale, as in the following:

```{r eval=FALSE}
scale_fill_hue(guide = guide_legend(reverse = TRUE))
```


Changing a Legend Title {#RECIPE-LEGEND-TITLE-TEXT}
-----------------------

### Problem

You want to change the text of a legend title.

### Solution

Use `labs()` and set the value of `fill`, `colour`, `shape`, or whatever aesthetic is appropriate for the legend (Figure \@ref(fig:FIG-LEGEND-TITLE)):

```{r FIG-LEGEND-TITLE, fig.cap='With the legend title set to "Condition"'}
# The base plot
p <- ggplot(PlantGrowth, aes(x = group, y = weight, fill = group)) + geom_boxplot()
p

# Set the legend title to "Condition"
p + labs(fill = "Condition")
```

### Discussion

It's also possible to set the title of the legend in the scale specification. Since legends and axes are both guides, this works the same way as setting the title of the x- or y-axis.

This would have the same effect as the previous code:

```{r eval=FALSE}
p + scale_fill_discrete(name = "Condition")
```

If there are multiple variables mapped to aesthetics with a legend (those other than x and y), you can set the title of each individually. In the example here we'll use `\n` to add a line break in one of the titles (Figure \@ref(fig:FIG-LEGEND-TITLE-MULTI)):

```{r FIG-LEGEND-TITLE-MULTI, fig.cap="Left: two legends with original titles; right: with new titles"}
library(gcookbook) # For the data set

# Make the base plot
hw <- ggplot(heightweight, aes(x = ageYear, y = heightIn, colour = sex)) +
    geom_point(aes(size = weightLb)) +
    scale_size_continuous(range = c(1, 4))

hw

# With new legend titles
hw + labs(colour = "Male/Female", size = "Weight\n(pounds)")
```

If you have one variable mapped to two separate aesthetics, the default is to have a single legend that combines both. For example, if we map `sex` to both `shape` and `weight`, there will be just one legend (Figure \@ref(fig:FIG-LEGEND-TITLE-MULTI-SAME), left):

```{r FIG-LEGEND-TITLE-MULTI-SAME-1, eval=FALSE}
hw1 <- ggplot(heightweight, aes(x = ageYear, y = heightIn, shape = sex, colour = sex)) +
       geom_point()

hw1
```

To change the title (Figure \@ref(fig:FIG-LEGEND-TITLE-MULTI-SAME), right), you need to set the name for both of them. If you change the name for just one, it will result in two separate legends (Figure \@ref(fig:FIG-LEGEND-TITLE-MULTI-SAME), middle):

```{r FIG-LEGEND-TITLE-MULTI-SAME-2, eval=FALSE}
# Change just shape
hw1 + labs(shape = "Male/Female")

# Change both shape and colour
hw1 + labs(shape = "Male/Female", colour = "Male/Female")
```

It is also possible to control the legend title with the `guides()` function. It's a little more verbose, but it can be useful when you're already using it to control other properties:

```{r FIG-LEGEND-TITLE-MULTI-SAME-3, eval=FALSE}
p + guides(fill = guide_legend(title = "Condition"))
```

```{r FIG-LEGEND-TITLE-MULTI-SAME, ref.label=c("FIG-LEGEND-TITLE-MULTI-SAME-1", "FIG-LEGEND-TITLE-MULTI-SAME-2", "FIG-LEGEND-TITLE-MULTI-SAME-3"), echo=FALSE, fig.cap="Left: default legend with a variable mapped to shape and colour; middle: with shape renamed; right: with both shape and colour renamed"}
```


Changing the Appearance of a Legend Title {#RECIPE-LEGEND-TITLE-APPEARANCE}
-----------------------------------------

### Problem

You want to change the appearance of a legend title's text.

### Solution

Use theme(`legend.title=element_text()`) (Figure \@ref(fig:FIG-LEGEND-TITLE-APPEARANCE)):

```{r FIG-LEGEND-TITLE-APPEARANCE, fig.cap="Customized legend title appearance"}
p <- ggplot(PlantGrowth, aes(x = group, y = weight, fill = group)) + geom_boxplot()

p + theme(legend.title = element_text(face = "italic", family = "Times",
                                      colour = "red", size = 14))
```

### Discussion

It's also possible to specify the legend title's appearance via `guides()`, but this method can be a bit verbose. This has the same effect as the previous code:

```{r, eval=FALSE}
p + guides(fill = guide_legend(title.theme = element_text(face = "italic",
            family = "times", colour = "red", size = 14)))
```

### See Also

See Recipe \@ref(RECIPE-APPEARANCE-TEXT-APPEARANCE) for more on controlling the appearance of text.


Removing a Legend Title {#RECIPE-LEGEND-TITLE-REMOVE}
-----------------------

### Problem

You want to remove a legend title.

### Solution

Add `guides(fill=guide_legend(title=NULL))` to remove the title from a legend, as in Figure \@ref(fig:FIG-LEGEND-TITLE-REMOVE) (for other aesthetics, replace `fill` with the name of the aesthetic, such as `colour` or `size`):

```{r FIG-LEGEND-TITLE-REMOVE, fig.cap="Box plot with no legend title"}
ggplot(PlantGrowth, aes(x = group, y = weight, fill = group)) +
    geom_boxplot() +
    guides(fill = guide_legend(title = NULL))
```

### Discussion

It is also possible to control the legend title when specifying the scale. This has the same effect as the preceding code:

```{r, eval=FALSE}
scale_fill_hue(guide = guide_legend(title = NULL))
```


Changing the Labels in a Legend {#RECIPE-LEGEND-LABEL-TEXT}
-------------------------------

### Problem

You want to change the text of labels in a legend.

### Solution

Set the labels in the scale (Figure \@ref(fig:FIG-LEGEND-LABEL), left):

```{r FIG-LEGEND-LABEL-1, eval=FALSE}
library(gcookbook) # For the data set

# The base plot
p <- ggplot(PlantGrowth, aes(x = group, y = weight, fill = group)) + geom_boxplot()

# Change the legend labels
p + scale_fill_discrete(labels = c("Control", "Treatment 1", "Treatment 2"))
```

### Discussion

Note that the labels on the x-axis did not change. To do that, you would have to set the labels of `scale_x_discrete()` (Recipe \@ref(RECIPE-AXES-AXIS-LABEL)), or change the data to have different factor level names (Recipe \@ref(RECIPE-DATAPREP-FACTOR-RENAME)).

In the preceding example, group was mapped to the fill aesthetic. By default this uses `scale_fill_discrete()`, which maps the factor levels to colors that are equally spaced around the color wheel (the same as `scale_fill_hue()`). There are other fill scales we could use, and setting the labels works the same way. For example, to produce the graph on the right in Figure \@ref(fig:FIG-LEGEND-LABEL):

```{r FIG-LEGEND-LABEL-2, eval=FALSE}
p + scale_fill_grey(start = .5, end = 1,
                    labels = c("Control", "Treatment 1", "Treatment 2"))
```

```{r FIG-LEGEND-LABEL, ref.label=c("FIG-LEGEND-LABEL-1", "FIG-LEGEND-LABEL-2"), echo=FALSE, fig.cap="Left: manually specified legend labels with the default discrete scale; right: manually specified labels with a different scale"}
```


If you are also changing the order of items in the legend, the labels are matched to the items by position. In this example we'll change the item order, and make sure to set the labels in the same order (Figure \@ref(fig:FIG-LEGEND-LABEL-ORDER)):

```{r FIG-LEGEND-LABEL-ORDER, fig.cap="Modified legend label order and manually specified labels (note that the x-axis labels and their order are unchanged)"}
p + scale_fill_discrete(limits = c("trt1", "trt2", "ctrl"),
                        labels = c("Treatment 1", "Treatment 2", "Control"))
```

If you have one variable mapped to two separate aesthetics, the default is to have a single legend that combines both. If you want to change the legend labels, you must change them for both scales; otherwise you will end up with two separate legends, as shown in Figure \@ref(fig:FIG-LEGEND-LABEL-MULTI-APPEARANCE):

```{r FIG-LEGEND-LABEL-MULTI-APPEARANCE, fig.cap="Left: a variable mapped to `shape` and `colour`; middle: with new labels for `shape`; right: with new labels for both `shape` and colour`"}
# The base plot
p <- ggplot(heightweight, aes(x = ageYear, y = heightIn, shape = sex, colour = sex)) +
     geom_point()
p

# Change the labels for one scale
p + scale_shape_discrete(labels = c("Female", "Male"))

# Change the labels for both scales
p + scale_shape_discrete(labels = c("Female", "Male")) +
    scale_colour_discrete(labels = c("Female", "Male"))
```

Other commonly used scales with legends include:

* `scale_fill_discrete()`
* `scale_fill_hue()`
* `scale_fill_manual()`
* `scale_fill_grey()`
* `scale_fill_brewer()`
* `scale_colour_discrete()`
* `scale_colour_hue()`
* `scale_colour_manual()`
* `scale_colour_grey()`
* `scale_colour_brewer()`
* `scale_shape_manual()`
* `scale_linetype()`

By default, using `scale_fill_discrete()` is equivalent to using `scale_fill_hue()`; the same is true for color scales.


Changing the Appearance of Legend Labels {#RECIPE-LEGEND-LABEL-APPEARANCE}
----------------------------------------

### Problem

You want to change the appearance of labels in a legend.

### Solution

Use `theme(legend.text=element_text())` (Figure \@ref(fig:FIG-LEGEND-LABEL-APPEARANCE)):

```{r FIG-LEGEND-LABEL-APPEARANCE, fig.cap="Customized legend label appearance"}
# The base plot
p <- ggplot(PlantGrowth, aes(x = group, y = weight, fill = group)) + geom_boxplot()

# Change the legend label appearance
p + theme(legend.text = element_text(face = "italic", family = "Times", colour = "red",
                                     size = 14))
```

### Discussion

It's also possible to specify the legend label appearance via `guides()`, although this method is a bit unwieldy. This has the same effect as the previous code:

```{r eval=FALSE}
# Changes the legend title text for the fill legend
p + guides(fill = guide_legend(title.theme = element_text(face = "italic",
            family = "times", colour = "red", size = 14)))
```

### See Also

See Recipe \@ref(RECIPE-APPEARANCE-TEXT-APPEARANCE) for more on controlling the appearance of text.


Using Labels with Multiple Lines of Text {#RECIPE-LEGEND-LABEL-MULTILINE}
----------------------------------------

### Problem

You want to use legend labels that have more than one line of text.

### Solution

Set the labels in the scale, using `\n` to represent a newline. In this example, we'll use `scale_fill_discrete()` to control the legend for the fill scale (Figure \@ref(fig:FIG-LEGEND-LABEL-MULTILINE), left):

```{r FIG-LEGEND-LABEL-MULTILINE-1, eval=FALSE}
p <- ggplot(PlantGrowth, aes(x = group, y = weight, fill = group)) + geom_boxplot()

# Labels that have more than one line
p + scale_fill_discrete(labels = c("Control", "Type 1\ntreatment",
                                   "Type 2\ntreatment"))
```

### Discussion

As you can see in the version on the left in Figure \@ref(fig:FIG-LEGEND-LABEL-MULTILINE), with the default settings the lines of text will run into each other when you use labels that have more than one line. To deal with this problem, you can increase the height of the legend keys and decrease the spacing between lines, using `theme()` (Figure \@ref(fig:FIG-LEGEND-LABEL-MULTILINE), right). To do this, you will need to specify the height using the `unit()` function from the grid package:

```{r FIG-LEGEND-LABEL-MULTILINE-2, eval=FALSE}
library(grid)
p + scale_fill_discrete(labels = c("Control", "Type 1\ntreatment",
                                   "Type 2\ntreatment")) +
    theme(legend.text = element_text(lineheight = .8),
          legend.key.height = unit(1, "cm"))
```

```{r FIG-LEGEND-LABEL-MULTILINE, ref.label=c("FIG-LEGEND-LABEL-MULTILINE-1", "FIG-LEGEND-LABEL-MULTILINE-2"), echo=FALSE, fig.cap="Left: multiline legend labels; right: with increased key height and reduced line spacing"}
```

<!--chapter:end:ch10.Rmd-->

---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
# This block needs cache=FALSE to set fig.width and fig.height, and have those
# persist across cached builds.

source("utils.R", local = TRUE)
knitr::opts_chunk$set(fig.width=6, fig.height=6)
```

Facets {#CHAPTER-FACET}
======

One of the most useful techniques in data visualization is rendering groups of data alongside each other, making it easy to compare the groups. With ggplot2, one way to do this is by mapping a discrete variable to an aesthetic, like *x* position, color, or shape. Another way of doing this is to create a subplot for each group and draw the subplots side by side.

These kinds of plots are known as *Trellis* displays. They're implemented in the lattice package as well as in the ggplot2 package. In ggplot2, they're called *facets*. In this chapter I'll explain how to use them.

Splitting Data into Subplots with Facets {#RECIPE-FACET-BASIC}
----------------------------------------

### Problem

You want to plot subsets of your data in separate panels.

### Solution

Use `facet_grid()` or `facet_wrap()`, and specify the variables on which to split.

With `facet_grid()`, you can specify a variable to split the data into vertical subpanels, and another variable to split it into horizontal subpanels (Figure \@ref(fig:FIG-FACET-FACET-GRID)):

```{r FIG-FACET-FACET-GRID, fig.cap="Top: faceting horizontally by drv; bottom left: faceting vertically by cyl; bottom right: faceting in both directions, with both variables", fig.width=6, fig.height=4}
# The base plot
p <- ggplot(mpg, aes(x = displ, y = hwy)) + geom_point()

# Faceted by drv, in vertically arranged subpanels
p + facet_grid(drv ~ .)

# Faceted by cyl, in horizontally arranged subpanels
p + facet_grid(. ~ cyl)

# Split by drv (vertical) and cyl (horizontal)
p + facet_grid(drv ~ cyl)
```

With `facet_wrap()`, the subplots are laid out horizontally and wrap around, like words on a page, as in Figure \@ref(fig:FIG-FACET-FACET-WRAP):

(ref:cap-FIG-FACET-FACET-WRAP) A scatter plot with `facet_wrap()` on class
```{r FIG-FACET-FACET-WRAP, fig.cap="(ref:cap-FIG-FACET-FACET-WRAP)"}
# Facet on class
# Note there is nothing before the tilde
p + facet_wrap( ~ class)
```

### Discussion

With `facet_wrap()`, the default is to use the same number of rows and columns. In Figure \@ref(fig:FIG-FACET-FACET-WRAP), there were seven facets, and they fit into a 33 square. To change this, you can pass a value for `nrow` or `ncol`:

```{r, eval=FALSE}
# These will have the same result: 2 rows and 4 cols
p + facet_wrap( ~ class, nrow = 2)
p + facet_wrap( ~ class, ncol = 4)
```

The choice of faceting direction depends on the kind of comparison you would like to encourage. For example, if you want to compare heights of bars, it's useful to make the facets go horizontally. If, on the other hand, you want to compare the horizontal distribution of histograms, it makes sense to make the facets go vertically.

Sometimes both kinds of comparisons are important -- there may not be a clear answer as to which faceting direction is best. It may turn out that displaying the groups in a single plot by mapping the grouping variable to an aesthetic like color works better than using facets. In these situations, you'll have to rely on your judgment.


Using Facets with Different Axes {#RECIPE-FACET-FREE}
--------------------------------

### Problem

You want subplots with different ranges or items on their axes.

### Solution

Set the scales to "free_x", "free_y", or "free" (Figure \@ref(fig:FIG-FACET-FACET-FREE)):

```{r FIG-FACET-FACET-FREE, fig.cap="Top: with free y scales; bottom: with free x and y scales", fig.width=7, fig.height=5}
# The base plot
p <- ggplot(mpg, aes(x = displ, y = hwy)) + geom_point()

# With free y scales
p + facet_grid(drv ~ cyl, scales = "free_y")

# With free x and y scales
p + facet_grid(drv ~ cyl, scales = "free")
```

### Discussion

Each row of subplots has its own *y* range when free *y* scales are used; the same applies to columns when free *x* scales are used.

It's not possible to directly set the range of each row or column, but you can control the ranges by dropping unwanted data (to reduce the ranges), or by adding `geom_blank()` (to expand the ranges).

### See Also

See Recipe \@ref(RECIPE-BAR-GRAPH-DOT-PLOT) for an example of faceting with free scales and a discrete axis.


Changing the Text of Facet Labels {#RECIPE-FACET-LABEL-TEXT}
---------------------------------

### Problem

You want to change the text of facet labels.

### Solution

Change the names of the factor levels (Figure \@ref(fig:FIG-FACET-LABEL-TEXT)):

```{r FIG-FACET-LABEL-TEXT, fig.cap="Left: default facet labels; right: modified facet labels", fig.width=2.5}
mpg2 <- mpg  # Make a copy of the original data

# Rename 4 to 4wd, f to Front, r to Rear
levels(mpg2$drv)[levels(mpg2$drv) == "4"] <- "4wd"
levels(mpg2$drv)[levels(mpg2$drv) == "f"] <- "Front"
levels(mpg2$drv)[levels(mpg2$drv) == "r"] <- "Rear"

# Plot the new data
ggplot(mpg2, aes(x = displ, y = hwy)) + geom_point() + facet_grid(drv ~ .)
```

### Discussion

Unlike with scales where you can set the labels, to set facet labels you must change the data values. Also, at the time of this writing, there is no way to show the name of the faceting variable as a header for the facets, so it can be useful to use descriptive facet labels.

With `facet_grid()` but not `facet_wrap()`, at this time), it's possible to use a labeller function to set the labels. The labeller function `label_both()` will print out both the name of the variable and the value of the variable in each facet (Figure \@ref(fig:FIG-FACET-LABEL-TEXT-LABELLER), left):

```{r FIG-FACET-LABEL-TEXT-LABELLER-1, eval=FALSE}
ggplot(mpg2, aes(x = displ, y = hwy)) + geom_point() +
    facet_grid(drv ~ ., labeller = label_both)
```

Another useful labeller is label_parsed(), which takes strings
and treats them as R math expressions
(Figure \@ref(fig:FIG-FACET-LABEL-TEXT-LABELLER), right):

```{r FIG-FACET-LABEL-TEXT-LABELLER-2, eval=FALSE}
mpg3 <- mpg

levels(mpg3$drv)[levels(mpg3$drv) == "4"] <- "4^{wd}"
levels(mpg3$drv)[levels(mpg3$drv) == "f"] <- "- Front %.% e^{pi * i}"
levels(mpg3$drv)[levels(mpg3$drv) == "r"] <- "4^{wd} - Front"

ggplot(mpg3, aes(x = displ, y = hwy)) + geom_point() +
    facet_grid(drv ~ ., labeller = label_parsed)
```

(ref:cap-FIG-FACET-LABEL-TEXT-LABELLER) Left: with `label_both()`; right: with `label_parsed()` for mathematical expressions

```{r FIG-FACET-LABEL-TEXT-LABELLER, ref.label=c("FIG-FACET-LABEL-TEXT-LABELLER-1", "FIG-FACET-LABEL-TEXT-LABELLER-2"), echo=FALSE, fig.cap="(ref:cap-FIG-FACET-LABEL-TEXT-LABELLER)", fig.width=2.5}
```

### See Also

See Recipe \@ref(RECIPE-DATAPREP-FACTOR-RENAME) for more on renaming factor levels. If the faceting variable is not a factor but a character vector, changing the values is somewhat different. See Recipe \@ref(RECIPE-DATAPREP-CHARACTER-RENAME) for information on renaming items in character vectors.


Changing the Appearance of Facet Labels and Headers {#RECIPE-FACET-LABEL-APPEARANCE}
---------------------------------------------------

### Problem

You want to change the appearance of facet labels and headers.

### Solution

With the theming system, set `strip.text` to control the text appearance and `strip.background` to control the background appearance (Figure \@ref(fig:FIG-FACET-LABEL-APPEARANCE)):

```{r FIG-FACET-LABEL-APPEARANCE, fig.cap="Customized appearance for facet labels", fig.height=3}
library(gcookbook)  # For the data set

ggplot(cabbage_exp, aes(x = Cultivar, y = Weight)) + geom_bar(stat = "identity") +
    facet_grid(. ~ Date) +
    theme(strip.text = element_text(face = "bold", size = rel(1.5)),
          strip.background = element_rect(fill = "lightblue", colour = "black",
                                          size = 1))
```

### Discussion

Using `rel(1.5)` makes the label text 1.5 times the size of the base text
size for the theme. Using `size=1` for the background makes the outline of
the facets 1 mm thick.

### See Also

For more on how the theme system works, see Recipes Recipe \@ref(RECIPE-APPEARANCE-THEME) and Recipe \@ref(RECIPE-APPEARANCE-THEME-MODIFY).

<!--chapter:end:ch11.Rmd-->

---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
# This block needs cache=FALSE to set fig.width and fig.height, and have those
# persist across cached builds.

source("utils.R", local = TRUE)
knitr::opts_chunk$set(fig.width=3.5, fig.height=3.5)
```


Using Colors in Plots {#CHAPTER-COLORS}
=====================

In ggplot2's implementation of the grammar of graphics, color is an aesthetic, just like *x* position, *y* position, and size. If color is just another aesthetic, why does it deserve its own chapter? The reason is that color is a more complicated aesthetic than the others. Instead of simply moving geoms left and right or making them larger and smaller, when you use color, there are many degrees of freedom and many more choices to make. What palette should you use for discrete values? Should you use a gradient with several different hues? How do you choose colors that can be interpreted accurately by those with color-vision deficiencies? In this chapter, I'll address these issues.


Setting the Colors of Objects {#RECIPE-COLORS-SETTING}
-----------------------------

### Problem

You want to set the color of some geoms in your graph.

### Solution

In the call to the geom, set the values of `colour` or `fill` (Figure \@ref(fig:FIG-COLORS-SETTING)):

```{r FIG-COLORS-SETTING, fig.show="hold", fig.cap="Left: setting fill and colour; right: setting colour for points", message=FALSE}
library(MASS) # For the data set
ggplot(birthwt, aes(x = bwt)) + geom_histogram(fill = "red", colour = "black")

ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point(colour = "red")
```

### Discussion

In ggplot2, there's an important difference between *setting* and *mapping* aesthetic properties. In the preceding example, we set the color of the objects to "red".

Generally speaking, colour controls the color of lines and of the outlines of polygons, while fill controls the color of the fill area of polygons. However, point shapes are sometimes a little different. For most point shapes, the color of the entire point is controlled by colour, not fill. The exception is the point shapes (2125) that have both a fill and an outline.

### See Also

For more information about point shapes, see Recipe \@ref(RECIPE-LINE-GRAPH-POINT-APPEARANCE).

See Recipe \@ref(RECIPE-COLORS-PALETTE-DISCRETE-MANUAL) for more on specifying colors.


Representing Variables with Colors {#RECIPE-COLORS-MAPPING}
---------------------------

### Problem

You want to use a variable (column from a data frame) to control the color of geoms.

### Solution

In the call to the geom, inside of `aes()`, set the value of `colour` or `fill` to the name of one of the columns in the data (Figure \@ref(fig:FIG-COLORS-MAPPING)):

```{r eval=FALSE}
library(gcookbook) # For the data set

# These both have the same effect
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_bar(colour = "black", position = "dodge")

ggplot(cabbage_exp, aes(x = Date, y = Weight)) +
    geom_bar(aes(fill = Cultivar), colour = "black", position = "dodge")

# These both have the same effect
ggplot(mtcars, aes(x = wt, y = mpg, colour = cyl)) + geom_point()

ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point(aes(colour = cyl))
```

```{r FIG-COLORS-MAPPING, echo=FALSE, fig.show="hold", fig.cap="Left: mapping a variable to fill; right: mapping a variable to colour for points"}
library(gcookbook) # For the data set

ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
    geom_bar(colour = "black", position = "dodge", stat = "identity")

ggplot(mtcars, aes(x = wt, y = mpg, colour = cyl)) + geom_point()
```

When the mapping is specified in `ggplot()` it is used as the default mapping, which is inherited by all the geoms. Within a geom, the default mappings can be overridden.

### Discussion

In the `cabbage_exp` example, the variable `Cultivar` is mapped to `fill`. The `Cultivar` column in `cabbage_exp` is a factor, so ggplot treats it as a categorical variable. You can check the type using `str()`:

```{r}
str(cabbage_exp)
```

In the `mtcars` example, `cyl` is numeric, so it is treated as a continuous variable. Because of this, even though the actual values of `cyl` include only 4, 6, and 8, the legend has entries for the intermediate values 5 and 7. To make ggplot treat `cyl` as a categorical variable, you can convert it to a factor in the call to `ggplot()`, or you can modify the data so that the column is a character vector or factor (Figure \@ref(fig:FIG-COLORS-MAPPING-FACTOR)):

```{r FIG-COLORS-MAPPING-FACTOR, echo=FALSE, fig.show="hold", fig.cap="Mapping to colour with a continuous variable converted to a factor"}
# Convert to factor in call to ggplot()
ggplot(mtcars, aes(x = wt, y = mpg, colour = factor(cyl))) + geom_point()

# Another method: Convert to factor in the data
m <- mtcars              # Make a copy of mtcars
m$cyl <- factor(m$cyl)   # Convert cyl to a factor
ggplot(m, aes(x = wt, y = mpg, colour = cyl)) + geom_point()
```

### See Also

You may also want to change the colors that are used in the scale. For continuous data, see Recipe \@ref(RECIPE-COLORS-PALETTE-CONTINUOUS). For discrete data, see Recipe \@ref(RECIPE-COLORS-PALETTE-DISCRETE) and Recipe \@ref(RECIPE-COLORS-PALETTE-DISCRETE-MANUAL).


Using a Different Palette for a Discrete Variable {#RECIPE-COLORS-PALETTE-DISCRETE}
-------------------------------------------------

### Problem

You want to use different colors for a discrete mapped variable.

### Solution

Use one of the scales listed in Table \@ref(tab:TABLE-DISCRETE-FILL-AND-COLOR-SCALES).

Table: (\#tab:TABLE-DISCRETE-FILL-AND-COLOR-SCALES) Discrete fill and color scales

+-------------------------+---------------------------+-----------------------+
| Fill scale              | Color scale               | Description           |
+=========================+===========================+=======================+
| `scale_fill_discrete()` | `scale_colour_discrete()` | Colors evenly spaced  |
|                         |                           | around the color      |
|                         |                           | wheel (same as `hue`) |
+-------------------------+---------------------------+-----------------------+
| `scale_fill_hue()`      | `scale_colour_hue()`      | Colors evenly spaced  |
|                         |                           | around the color      |
|                         |                           | wheel (same as        |
|                         |                           | `discrete`)           |
+-------------------------+---------------------------+-----------------------+
| `scale_fill_grey()`     | `scale_colour_grey()`     | Greyscale palette     |
+-------------------------+---------------------------+-----------------------+
| `scale_fill_brewer()`   | `scale_colour_brewer()`   | ColorBrewer palettes  |
+-------------------------+---------------------------+-----------------------+
| `scale_fill_manual()`   | `scale_colour_manual()`   | Manually specified    |
|                         |                           | colors                |
+-------------------------+---------------------------+-----------------------+


In the example here we'll use the default palette (hue), and a ColorBrewer palette (Figure \@ref(fig:FIG-COLORS-PALETTE-DISCRETE)):

```{r FIG-COLORS-PALETTE-DISCRETE, fig.show="hold", fig.cap="Left: default palette (using hue); right: a ColorBrewer palette", fig.width=4.5}
library(gcookbook) # For the data set

# Base plot
p <- ggplot(uspopage, aes(x = Year, y = Thousands, fill = AgeGroup)) + geom_area()

# These three all have the same effect
p
# p + scale_fill_discrete()
# p + scale_fill_hue()

# ColorBrewer palette
p + scale_fill_brewer()
```

### Discussion

Changing a palette is a modification of the color (or fill) scale: it involves a change in the mapping from numeric or categorical values to aesthetic attributes. There are two types of scales that use colors: *fill* scales and *color* scales.

With `scale_fill_hue()`, the colors are taken from around the color wheel in the HCL (hue-chroma-lightness) color space. The default lightness value is 65 on a scale from 0100. This is good for filled areas, but it's a bit light for points and lines. To make the colors darker for points and lines, as in Figure \@ref(fig:FIG-COLORS-PALETTE-LIGHTNESS) (right), set the value of `l` (luminance/lightness):

```{r FIG-COLORS-PALETTE-LIGHTNESS, fig.show="hold", fig.cap="Left: points with default lightness; right: with lightness set to 45", fig.width=4.5}
# Basic scatter plot
h <- ggplot(heightweight, aes(x = ageYear, y = heightIn, colour = sex)) +
    geom_point()

# Default lightness = 65
h

# Slightly darker
h + scale_colour_hue(l = 45)
```


The ColorBrewer package provides a number of palettes. You can generate a graphic showing all of them, as shown in Figure \@ref(fig:FIG-COLORS-PALETTE-BREWER):

```{r FIG-COLORS-PALETTE-BREWER, fig.cap="All the ColorBrewer palettes", fig.height=8, fig.width=8}
library(RColorBrewer)
display.brewer.all()
```

The ColorBrewer palettes can be selected by name. For example, this will use the Oranges palette (Figure \@ref(fig:FIG-COLORS-PALETTE-BREWER-NAME)):

```{r FIG-COLORS-PALETTE-BREWER-NAME, fig.cap="Using a named ColorBrewer palette", fig.width=4.5}
p + scale_fill_brewer(palette = "Oranges")
```

You can also use a palette of greys. This is useful for print when the
output is in black and white. The default is to start at 0.2 and end at 0.8, on a scale from 0 (black) to 1 (white), but you can change the range, as shown in Figure \@ref(fig:FIG-COLORS-PALETTE-GREY).

```{r FIG-COLORS-PALETTE-GREY, fig.show="hold", fig.cap="Left: using the default grey palette; right: a different grey palette", fig.width=4.5}
p + scale_fill_grey()

# Reverse the direction and use a different range of greys
p + scale_fill_grey(start = 0.7, end = 0)
```

### See Also

See Recipe \@ref(RECIPE-LEGEND-REVERSE) for more information about reversing the legend.

To select colors manually, see Recipe \@ref(RECIPE-COLORS-PALETTE-DISCRETE-MANUAL).

For more about ColorBrewer, see <http://colorbrewer2.org>.


Using a Manually Defined Palette for a Discrete Variable {#RECIPE-COLORS-PALETTE-DISCRETE-MANUAL}
--------------------------------------------------------

### Problem

You want to use different colors for a discrete mapped variable.

### Solution

In the example here, we'll manually define colors by specifying values with `scale_colour_manual()` (Figure \@ref(fig:FIG-COLORS-PALETTE-DISCRETE-MANUAL)). The colors can be named, or they can be specified with RGB values:

```{r FIG-COLORS-PALETTE-DISCRETE-MANUAL, fig.show="hold", fig.cap="Left: scatter plot with named colors; right: with slightly different RGB colors", fig.width=4}
library(gcookbook) # For the data set

# Base plot
h <- ggplot(heightweight, aes(x = ageYear, y = heightIn, colour = sex)) + geom_point()

# Using color names
h + scale_colour_manual(values = c("red", "blue"))

# Using RGB values
h + scale_colour_manual(values = c("#CC6666", "#7777DD"))
```

For fill scales, use `scale_fill_manual()` instead.

### Discussion

The order of the items in the values vector matches the order of the factor levels for the discrete scale. In the preceding example, the order of sex is f, then m, so the first item in values goes with f and the second goes with m. Here's how to see the order of factor levels:

```{r}
levels(heightweight$sex)
```

If the variable is a character vector, not a factor, it will automatically be converted to a factor, and by default the levels will appear in alphabetical order.

It's possible to specify the colors in a different order by using a named vector:

```{r eval=FALSE}
h + scale_colour_manual(values = c(m = "blue", f = "red"))
```

There is a large set of named colors in R, which you can see by running `color()`. Some basic color names are useful: "white", "black", "grey80", "red", "blue", "darkred", and so on. There are many other named colors, but their names are generally not very informative (I certainly have no idea what "thistle3" and "seashell" look like), so it's often easier to use numeric RGB values for specifying colors.

RGB colors are specified as six-digit hexadecimal (base-16) numbers of the form `#RRGGBB`. In hexadecimal, the digits go from 0 to 9, and then continue with A (10 in base 10) to F (15 in base 10). Each color is represented by two digits and can range from 00 to FF (255 in base 10). So, for example, the color `#FF0099` has a value of 255 for red, 0 for green, and 153 for blue, resulting in a shade of magenta. The hexadecimal numbers for each color channel often repeat the same digit because it makes them a little easier to read, and because the precise value of the second digit has a relatively insignificant effect on appearance.

Here are some rules of thumb for specifying and adjusting RGB colors:

* In general, higher numbers are brighter and lower numbers are darker.
* To get a shade of grey, set all the channels to the same value.
* The opposites of RGB are CMY: Cyan, Magenta, and Yellow. Higher values for the red channel make it more red, and lower values make it more cyan. The same is true for the pairs green and magenta, and blue and yellow.

### See Also

A [chart of RGB color codes](http://html-color-codes.com).

 
Using a Colorblind-Friendly Palette {#RECIPE-COLORS-PALETTE-DISCRETE-COLORBLIND}
-----------------------------------

### Problem

You want to use colors that can be distinguished by colorblind viewers.

### Solution

Use the palette defined here (`cb_palette`) with `scale_fill_manual()` (Figure \@ref(fig:FIG-COLORS-PALETTE-DISCRETE-COLORBLIND)):

```{r FIG-COLORS-PALETTE-DISCRETE-COLORBLIND, fig.show="hold", fig.cap="A plot with the colorblind-friendly palette", fig.width=4.5}
library(gcookbook) # For the data set

# Base plot
p <- ggplot(uspopage, aes(x = Year, y = Thousands, fill = AgeGroup)) + geom_area()

# The palette with grey:
cb_palette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
                "#0072B2", "#D55E00", "#CC79A7")

# Add it to the plot
p + scale_fill_manual(values = cb_palette)
```

A chart of the colors is shown in Figure \@ref(fig:FIG-COLORS-PALETTE-DISCRETE-COLORBLIND-CHART).

```{r FIG-COLORS-PALETTE-DISCRETE-COLORBLIND-CHART, echo=FALSE, fig.cap="Colorblind palette with RGB values"}
knitr::include_graphics("fig/colorblind_palette.png")
```
In some cases it may be better to use black instead of grey. To do this, replace the `#999999` with `#000000` or `"black"`:

```{r}
c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00",
  "#CC79A7")
```

### Discussion

About 8 percent of males and 0.5 percent of females have some form of color-vision deficiency, so there's a good chance that someone in your audience will be among them.

There are many different forms of color blindness. The palette here is designed to enable people with any of the most common forms of color-vision deficiency to distinguish the colors. (Monochromacy, or total colorblindness, is rare. Those who have it can only see differences in brightness.)

### See Also

The [source of this palette](http://jfly.iam.u-tokyo.ac.jp/color/).

The [Color Oracle program](http://colororacle.org) can simulate how things on your screen appear to someone with color vision deficiency, but keep in mind that the simulation isn't perfect. In my informal testing, I viewed an image with simulated red-green deficiency, and I could distinguish the colors just fine--but others with actual red-green deficiency viewed the same image and couldn't tell the colors apart!


Using a Manually Defined Palette for a Continuous Variable {#RECIPE-COLORS-PALETTE-CONTINUOUS}
----------------------------------------------------------

### Problem

You want to use different colors for a continuous variable.

### Solution

In the example here, we'll specify the colors for a continuous variable using various gradient scales (Figure \@ref(fig:FIG-COLORS-PALETTE-CONTINUOUS)). The colors can be named, or they can be specified with RGB values:

(ref:cap-FIG-COLORS-PALETTE-CONTINUOUS) Clockwise from top left: default colors, two-color gradient with `scale_colour_gradient()`, three-color gradient with midpoint with `scale_colour_gradient2()`, four-color gradient with `scale_colour_gradientn()`

```{r FIG-COLORS-PALETTE-CONTINUOUS, fig.show="hold", fig.cap="(ref:cap-FIG-COLORS-PALETTE-CONTINUOUS)", fig.width=4}
library(gcookbook) # For the data set

# Base plot
p <- ggplot(heightweight, aes(x = ageYear, y = heightIn, colour = weightLb)) +
     geom_point(size = 3)

p

# With a gradient between two colors
p + scale_colour_gradient(low = "black", high = "white")

# A gradient of n colors
p + scale_colour_gradientn(colours = c("darkred", "orange", "yellow", "white"))

# A gradient with a white midpoint
library(scales)
p + scale_colour_gradient2(low = muted("red"), mid = "white", high = muted("blue"),
    midpoint = 110)
```


For fill scales, use `scale_fill_xxx()` versions instead, where `xxx` is one of `gradient`, `gradient2`, or `gradientn`.

### Discussion

Mapping continuous values to a color scale requires a continuously changing palette of colors. Table \@ref(tab:TABLE-CONTINUOUS-COLOR-SCALES). lists the continuous color and fill scales.

Table: (\#tab:TABLE-CONTINUOUS-COLOR-SCALES) Continuous fill and color scales

+--------------------------+----------------------------+-----------------------+
| Fill scale               | Color scale                | Description           |
+==========================+============================+=======================+
| `scale_fill_gradient()`  | `scale_colour_gradient()`  | Two-color gradient    |
+--------------------------+----------------------------+-----------------------+
| `scale_fill_gradient2()` | `scale_colour_gradient2()` | Gradient with a       |
|                          |                            | middle color and two  |
|                          |                            | colors that diverge   |
|                          |                            | from it               |
+--------------------------+----------------------------+-----------------------+
| `scale_fill_gradientn()` | `scale_colour_gradientn()` | Gradient with *n*     |
|                          |                            | colors, equally       |
|                          |                            | spaced                |
+--------------------------+----------------------------+-----------------------+
 
Notice that we used the `muted()` function in the examples. This is a function from the scales package that returns an RGB value that is a less-saturated version of the color chosen.

### See Also

If you want use a discrete (categorical) scale instead of a continuous one, you can recode your data into categorical values. See Recipe \@ref(RECIPE-DATAPREP-RECODE-CONTINUOUS).


Coloring a Shaded Region Based on Value {#RECIPE-COLORS-AREA-VALUE}
---------------------------------------

### Problem

You want to set the color of a shaded region based on the *y* value.

### Solution

Add a column that categorizes the *y* values, then map that column to fill. In this example, well first categorize the values as positive or negative:

```{r}
library(gcookbook) # For the data set
cb <- subset(climate, Source=="Berkeley")
cb$valence[cb$Anomaly10y >= 0] <- "pos"
cb$valence[cb$Anomaly10y < 0]  <- "neg"
cb
```

Once we've categorized the values as positive or negative, we can make the plot, mapping valence to the fill color, as shown in Figure \@ref(fig:FIG-COLORS-AREA-VALUE):

```{r FIG-COLORS-AREA-VALUE, fig.cap="Mapping valence to fill color-notice the red area under the zero line around 1950", fig.width=10}
ggplot(cb, aes(x = Year, y = Anomaly10y)) +
    geom_area(aes(fill = valence)) +
    geom_line() +
    geom_hline(yintercept = 0)
```

### Discussion

If you look closely at the figure, you'll notice that there are some stray shaded areas near the zero line. This is because each of the two colored areas is a single polygon bounded by the data points, and the data points are not actually at zero. To solve this problem, we can interpolate the data to 1,000 points by using `approx()`:

```{r}
# approx() returns a list with x and y vectors
interp <- approx(cb$Year, cb$Anomaly10y, n = 1000)

# Put in a data frame and recalculate valence
cbi <- data.frame(Year = interp$x, Anomaly10y = interp$y)
cbi$valence[cbi$Anomaly10y >= 0] <- "pos"
cbi$valence[cbi$Anomaly10y < 0]  <- "neg"
```

It would be more precise (and more complicated) to interpolate exactly where the line crosses zero, but `approx()` works fine for the purposes here.

Now we can plot the interpolated data (Figure \@ref(fig:FIG-COLORS-AREA-VALUE-INTERPOLATED)). This time we'll make a few adjustments -- we'll make the shaded regions partially transparent, change the colors, remove the legend, and remove the padding on the left and right sides:

```{r FIG-COLORS-AREA-VALUE-INTERPOLATED, fig.cap="Shaded regions with interpolated data", fig.width=10}
ggplot(cbi, aes(x = Year, y = Anomaly10y)) +
    geom_area(aes(fill = valence), alpha = .4) +
    geom_line() +
    geom_hline(yintercept = 0) +
    scale_fill_manual(values = c("#CCEEFF", "#FFDDDD"), guide = FALSE) +
    scale_x_continuous(expand = c(0, 0))
```

<!--chapter:end:ch12.Rmd-->

---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
# This block needs cache=FALSE to set fig.width and fig.height, and have those
# persist across cached builds.

source("utils.R", local = TRUE)
knitr::opts_chunk$set(fig.width=3.5, fig.height=3.5)
```


Miscellaneous Graphs {#CHAPTER-MISCGRAPH}
====================

There are many, many ways of visualizing data, and sometimes things don't fit into nice, tidy categories. This chapter shows how to make some of these other visualizations.


Making a Correlation Matrix {#RECIPE-MISCGRAPH-CORRMATRIX}
---------------------------

### Problem

You want to make a graphical correlation matrix.

### Solution

We'll look at the `mtcars` data set:

```{r}
mtcars
```

First, generate the numerical correlation matrix using cor. This will generate correlation coefficients for each pair of columns:


```{r}
mcor <- cor(mtcars) # Print mcor and round to 2 digits
round(mcor, digits = 2)
```

If there are any columns that you don't want used for correlations (for example, a column of names), you should exclude them. If there are any `NA` cells in the original data, the resulting correlation matrix will have `NA` values. To deal with this, you will probably want to use the argument `use="complete.obs"` or `use="pairwise.complete.obs"`.

To plot the correlation matrix (Figure \@ref(fig:FIG-MISCGRAPH-CORRMATRIX-BASIC)), we'll use the corrplot package, which first must be installed with `install.packages("corrplot")`:

```{r FIG-MISCGRAPH-CORRMATRIX-BASIC, fig.cap="A correlation matrix", fig.width=7, fig.height=7}
library(corrplot)

corrplot(mcor)
```

### Discussion

The `corrplot()` function has many, many options. Here is an example of how to make a correlation matrix with colored squares and black labels, rotated 45 degrees along the top (Figure \@ref(fig:FIG-MISCGRAPH-CORRMATRIX-SHADE)):

```{r FIG-MISCGRAPH-CORRMATRIX-SHADE, fig.cap="Correlation matrix with colored squares and black, rotated labels", fig.width=7, fig.height=7}
corrplot(mcor, method = "shade", shade.col = NA, tl.col = "black", tl.srt = 45)
```

It may also be helpful to display labels representing the correlation coefficient on each square in the matrix. In this example we'll make a lighter palette so that the text is readable, and we'll remove the color legend, since it's redundant. We'll also order the items so that correlated items are closer together, using the `order="AOE"` (angular order of eigenvectors) option. The result is shown in Figure \@ref(fig:FIG-MISCGRAPH-CORRMATRIX-SHADE-NUM):

```{r FIG-MISCGRAPH-CORRMATRIX-SHADE-NUM, fig.cap="Correlation matrix with correlation coefficients and no legend", fig.width=7, fig.height=7}
# Generate a lighter palette
col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))

corrplot(mcor, method = "shade", shade.col = NA, tl.col = "black", tl.srt = 45,
         col = col(200), addCoef.col = "black", cl.pos = "n", order = "AOE")
```


Like many other standalone plotting functions, `corrplot()` has its own menagerie of options, which can't all be illustrated here. Table \@ref(tab:TABLE-OPTIONS-FOR-CORRPLOT) lists some useful options.

Table: (\#tab:TABLE-OPTIONS-FOR-CORRPLOT) Options for `corrplot()`

+-----------------------------------+-----------------------------------+
| Option                            | Description                       |
+===================================+===================================+
| `type={"lower" | "upper"}`        | Only use the lower or upper       |
|                                   | triangle                          |
+-----------------------------------+-----------------------------------+
| `diag=FALSE`                      | Don't show values on the          |
|                                   | diagonal                          |
+-----------------------------------+-----------------------------------+
| `addshade="all"`                  | Add lines indicating the          |
|                                   | direction of the correlation      |
+-----------------------------------+-----------------------------------+
| `shade.col=NA`                    | Hide correlation direction lines  |
+-----------------------------------+-----------------------------------+
| `method="shade"`                  | Use colored squares               |
+-----------------------------------+-----------------------------------+
| `method="ellipse"`                | Use ellipses                      |
+-----------------------------------+-----------------------------------+
| `addCoef.col="*color*"`           | Add correlation coefficients, in  |
|                                   | *color*                           |
+-----------------------------------+-----------------------------------+
| `tl.srt="*number*"`               | Specify the rotation angle for    |
|                                   | top labels                        |
+-----------------------------------+-----------------------------------+
| `tl.col="*color*"`                | Specify the label color           |
+-----------------------------------+-----------------------------------+
| `order={"AOE" | "FPC" | "hclust"}`| Sort labels using angular order   |
|                                   | of eigenvectors, first principal  |
|                                   | component, or hierarchical        |
|                                   | clustering                        |
+-----------------------------------+-----------------------------------+


### See Also

To create a scatter plot matrix, see Recipe \@ref(RECIPE-SCATTER-SPLOM).

For more on subsetting data, see Recipe \@ref(RECIPE-DATAPREP-SUBSET).


Plotting a Function {#RECIPE-MISCGRAPH-FUNCTION}
-------------------

### Problem

You want to plot a function.

### Solution

Use `stat_function()`. It's also necessary to give ggplot a dummy data frame so that it will get the proper *x* range. In this example we'll use `dnorm()`, which gives the density of the normal distribution (Figure \@ref(fig:FIG-MISCGRAPH-FUNCTION), left):

```{r FIG-MISCGRAPH-FUNCTION-1, eval=FALSE}
# The data frame is only used for setting the range
p <- ggplot(data.frame(x = c(-3,3)), aes(x = x))

p + stat_function(fun = dnorm)
```

### Discussion

Some functions take additional arguments. For example, `dt()`, the function for the density of the *t*-distribution, takes a parameter for degrees of freedom (Figure \@ref(fig:FIG-MISCGRAPH-FUNCTION), right). These additional arguments can be passed to the function by putting them in a list and giving the list to args:

```{r FIG-MISCGRAPH-FUNCTION-2, eval=FALSE}
p + stat_function(fun = dt, args = list(df = 2))
```

```{r FIG-MISCGRAPH-FUNCTION, ref.label=c("FIG-MISCGRAPH-FUNCTION-1", "FIG-MISCGRAPH-FUNCTION-2"), echo=FALSE, fig.show="hold", fig.cap="Left: the normal distribution; right: the *t*-distribution with `df=2`"}
````

It's also possible to define your own functions. It should take an *x* value for its first argument, and it should return a *y* value. In this example, we'll define a sigmoid function (Figure \@ref(fig:FIG-MISCGRAPH-FUNCTION-CUSTOM)):

```{r FIG-MISCGRAPH-FUNCTION-CUSTOM, fig.cap="A user-defined function"}
myfun <- function(xvar) {
    1/(1 + exp(-xvar + 10))
}

ggplot(data.frame(x = c(0, 20)), aes(x = x)) + stat_function(fun = myfun)
```

By default, the function is calculated at 101 points along the *x* range. If you have a rapidly fluctuating function, you may be able to see the individual segments. To smooth out the curve, pass a larger value of n to `stat_function()`, as in `stat_function(fun=myfun, n=200)`.

### See Also

For plotting predicted values from model objects (such as `lm` and `glm`), see Recipe \@ref(RECIPE-SCATTER-FITLINES-MODEL).



Shading a Subregion Under a Function Curve {#RECIPE-MISCGRAPH-FUNCTION-SHADE}
------------------------------------------

### Problem

You want to shade part of the area under a function curve.

### Solution

Define a new wrapper function around your curve function, and replace out-of-range values with `NA`, as shown in Figure \@ref(fig:FIG-MISCGRAPH-FUNCTION-SHADE):

```{r FIG-MISCGRAPH-FUNCTION-SHADE, fig.cap="Function curve with a shaded region"}
# Return dnorm(x) for 0 < x < 2, and NA for all other x
dnorm_limit <- function(x) {
    y <- dnorm(x)
    y[x < 0  |  x > 2] <- NA
    return(y)
}

# ggplot() with dummy data
p <- ggplot(data.frame(x = c(-3, 3)), aes(x = x))

p + stat_function(fun = dnorm_limit, geom = "area", fill = "blue", alpha = 0.2) +
    stat_function(fun = dnorm)
```

Remember that what gets passed to this function is a vector, not individual values. If this function operated on single elements at a time, it might make sense to use an `if`--`else` statement to decide what to return, conditional on the value of `x`. But that won't work here, since `x` is a vector with many values.

### Discussion

R has first-class functions, and we can write a function that returns a *closure*-that is, we can program a function to program another function.

This function will allow you to pass in a function, a minimum value, and a maximum value. Values outside the range will again be returned with `NA`:

```{r}
limitRange <- function(fun, min, max) {
    function(x) {
        y <- fun(x)
        y[x < min  |  x > max] <- NA
        return(y)
    }
}
```

Now we can call this function to create another function -- one that is effectively the same as the `dnorm_limit()` function used earlier:

```{r}
# This returns a function
dlimit <- limitRange(dnorm, 0, 2) 
# Now we'll try out the new function -- it only returns values for inputs
# between 0 and 2
dlimit(-2:4)
```

We can use `limitRange()` to create a function that is passed to `stat_function()`:

```{r}
p + stat_function(fun = dnorm) +
    stat_function(fun = limitRange(dnorm, 0, 2),
                  geom = "area", fill = "blue", alpha = 0.2)
```

The `limitRange()` function can be used with any function, not just `dnorm()`, to create a range-limited version of that function. The result of all this is that instead of having to write functions with different hard-coded values for each situation that arises, we can write one function and simply pass it different arguments depending on the situation.

If you look very, very closely at the graph in Figure \@ref(fig:FIG-MISCGRAPH-FUNCTION-SHADE), you may see that the shaded region does not align exactly with the range we specified. This is because ggplot2 does a numeric approximation by calculating values at fixed intervals, and these intervals may not fall exactly within the specified range. As in Recipe \@ref(RECIPE-MISCGRAPH-FUNCTION), we can improve the approximation by increasing the number of interpolated values with `stat_function(n=200)`.



Creating a Network Graph {#RECIPE-MISCGRAPH-GRAPH}
------------------------

### Problem

You want to create a network graph.

### Solution

Use the igraph package. To create a graph, pass a vector containing pairs of items to `graph()`, then plot the resulting object (Figure \@ref(fig:FIG-MISCGRAPH-GRAPH-BASIC)):

```{r FIG-MISCGRAPH-GRAPH-BASIC, fig.show="hold", fig.cap="Left: a directed graph; right: an undirected graph, with no vertex labels", fig.width=4.5, fig.height=4.5}
# May need to install first, with install.packages("igraph")
library(igraph)

# Specify edges for a directed graph
gd <- graph(c(1,2, 2,3, 2,4, 1,4, 5,5, 3,6))
plot(gd)

# For an undirected graph
gu <- graph(c(1,2, 2,3, 2,4, 1,4, 5,5, 3,6), directed = FALSE)
# No labels
plot(gu, vertex.label = NA)
```


This is the structure of each of the graph objects:

```{r}
gd
gu
```


### Discussion

In a network graph, the position of the nodes is unspecified by the data, and they're placed randomly. To make the output repeatable, you can set the random seed before making the plot. You can try different random numbers until you get a result that you like:

```{r eval=FALSE}
set.seed(229)
plot(gu)
```

It's also possible to create a graph from a data frame. The first two columns of the data frame are used, and each row specifies a connection between two nodes. In the next example (Figure \@ref(fig:FIG-MISCGRAPH-GRAPH-DIRECTED)), we'll use the `madmen2` data set, which has this structure. We'll also use the Fruchterman-Reingold layout algorithm. The idea is that all the nodes have a magnetic repulsion from one another, but the edges between nodes act as springs, pulling the nodes together:

```{r FIG-MISCGRAPH-GRAPH-DIRECTED, fig.cap="A directed graph from a data frame, with the Fruchterman-Reingold algorithm", fig.width=5, fig.height=5}
library(gcookbook) # For the data set
madmen2
# Create a graph object from the data set
g <- graph.data.frame(madmen2, directed=TRUE)
# Remove unnecessary margins
par(mar = c(0,0,0,0))
plot(g, layout = layout.fruchterman.reingold, vertex.size = 8,
    edge.arrow.size = 0.5, vertex.label = NA)
```

It's also possible to make a directed graph from a data frame. The `madmen` data set has only one row for each pairing, since direction doesn't matter for an undirected graph. This time we'll use a circle layout (Figure \@ref(fig:FIG-MISCGRAPH-GRAPH-CIRCLE)):

```{r FIG-MISCGRAPH-GRAPH-CIRCLE, fig.cap="A circular undirected graph from a data frame"}
g <- graph.data.frame(madmen, directed = FALSE)
par(mar = c(0,0,0,0))  # Remove unnecessary margins
plot(g, layout = layout.circle, vertex.size = 8, vertex.label = NA)
```


### See Also

For more information about the available output options, see `?plot.igraph`. Also see `?igraph::layout` for layout options.

An alternative to igraph is Rgraphviz, which a frontend for Graphviz, an open-source library for visualizing graphs. It works better with labels and makes it easier to create graphs with a controlled layout, but it can be a bit challenging to install. Rgraphviz is available through the Bioconductor repository system.


Using Text Labels in a Network Graph {#RECIPE-MISCGRAPH-GRAPH-LABEL}
------------------------------------

### Problem

You want to use text labels in a network graph.

### Solution

The vertices/nodes may have names, but these names are not used as labels by default. To set the labels, pass in a vector of names to `vertex.label` (Figure \@ref(fig:FIG-MISCGRAPH-GRAPH-LABEL)):

```{r FIG-MISCGRAPH-GRAPH-LABEL, fig.cap="A network graph with labels", fig.width=6, fig.height=6}
library(igraph)
library(gcookbook) # For the data set

# Copy madmen and drop every other row
m <- madmen[1:nrow(madmen) %% 2 == 1, ]

g <- graph.data.frame(m, directed=FALSE) # Print out the names of each vertex

V(g)$name

plot(g, layout=layout.fruchterman.reingold,
    vertex.size = 4,          # Smaller nodes
    vertex.label = V(g)$name, # Set the labels
    vertex.label.cex = 0.8,   # Slightly smaller font
    vertex.label.dist = 0.4,  # Offset the labels
    vertex.label.color = "black")
```

### Discussion

Another way to achieve the same effect is to modify the plot object, instead of passing in the values as arguments to `plot()`. To do this, use `V()$xxx<-` instead of passing a value to a `vertex.xxx` argument. For example, this will result in the same output as the previous code:

```{r, eval=FALSE}
# This is equivalent to the preceding code
V(g)$size        <- 4
V(g)$label       <- V(g)$name
V(g)$label.cex   <- 0.8
V(g)$label.dist  <- 0.4
V(g)$label.color <- "black"

# Set a property of the entire graph
g$layout <- layout.fruchterman.reingold

plot(g)
```

The properties of the edges can also be set, either with the `E()` function or by passing values to `edge.xxx` arguments (Figure \@ref(fig:FIG-MISCGRAPH-GRAPH-LABEL-EDGE)):

```{r echo=FALSE}
# This block duplicates the settings above; they get consumed when plot() is
# called, but we want them to apply to the next block.
V(g)$size        <- 4
V(g)$label       <- V(g)$name
V(g)$label.cex   <- 0.8
V(g)$label.dist  <- 0.4
V(g)$label.color <- "black"

# Set a property of the entire graph
g$layout <- layout.fruchterman.reingold
```

```{r FIG-MISCGRAPH-GRAPH-LABEL-EDGE, fig.cap="A network graph with labeled and colored edges", fig.width=6, fig.height=6}
# View the edges
E(g)

# Set some of the labels to "M"
E(g)[c(2,11,19)]$label <- "M"

# Set color of all to grey, and then color a few red
E(g)$color             <- "grey70"
E(g)[c(2,11,19)]$color <- "red"

plot(g)
```

### See Also

See `?igraph.plotting` for more information about graphical parameters in igraph.



Creating a Heat Map {#RECIPE-MISCGRAPH-HEATMAP}
-------------------

### Problem

You want to make a heat map.

### Solution

Use `geom_tile()` or `geom_raster()` and map a continuous variable to `fill`. We'll use the `presidents` data set, which is a time series object rather than a data frame:

```{r}
presidents
str(presidents)
```

We'll first convert it to a format that is usable by ggplot: a data frame with columns that are numeric:

```{r}
pres_rating <- data.frame(
    rating = as.numeric(presidents),
    year = as.numeric(floor(time(presidents))),
    quarter = as.numeric(cycle(presidents))
)
pres_rating
```

Now we can make the plot using `geom_tile()` or `geom_raster()` (Figure \@ref(fig:FIG-MISCGRAPH-HEATMAP)). Simply map one variable to `x`, one to `y`, and one to `fill`:

```{r eval=FALSE}
# Base plot
p <- ggplot(pres_rating, aes(x = year, y = quarter, fill = rating))

# Using geom_tile()
p + geom_tile()

# Using geom_raster() - looks the same, but a little more efficient
p + geom_raster()
```

```{r FIG-MISCGRAPH-HEATMAP, fig.cap="A heat map-the grey squares represent `NA`s in the data", fig.width=8, fig.height=1.5}
# The above code block is just for display because it would make two plots when
# we just need one.
p <- ggplot(pres_rating, aes(x = year, y = quarter, fill = rating))
p + geom_tile()
```

> **Note**
>
> The results with `geom_tile()` and `geom_raster()` *should* look the same, but in practice they might appear different. See Recipe \@ref(RECIPE-DISTRIBUTION-DENSITY2D) for more information about this issue.

### Discussion

To better convey useful information, you may want to customize the appearance of the heat map. With this example, we'll reverse the y-axis so that it progresses from top to bottom, and we'll add tick marks every four years along the x-axis, to correspond with each presidential term. For the x and y scales, we remove the padding by using `expand=c(0, 0)`.  We'll also change the color scale using `scale_fill_gradient2()`, which lets you specify a midpoint color and the two colors at the low and high ends (Figure \@ref(fig:FIG-MISCGRAPH-HEATMAP-CUSTOM)):

```{r FIG-MISCGRAPH-HEATMAP-CUSTOM, fig.cap="A heat map with customized appearance", fig.width=8, fig.height=1.5}
p + geom_tile() +
    scale_x_continuous(breaks = seq(1940, 1976, by = 4), expand = c(0, 0)) +
    scale_y_reverse(expand = c(0, 0)) +
    scale_fill_gradient2(midpoint = 50, mid = "grey70", limits = c(0,100))
```

### See Also

If you want to use a different color palette, see Recipe \@ref(RECIPE-COLORS-PALETTE-CONTINUOUS).



Creating a Three-Dimensional Scatter Plot {#RECIPE-MISCGRAPH-3D-SCATTER}
-----------------------------------------

### Problem

You want to create a three-dimensional scatter plot.

### Solution

We'll use the rgl package, which provides an interface to the OpenGL graphics library for 3D graphics. To create a 3D scatter plot, as in Figure \@ref(fig:FIG-MISCGRAPH-3D-SCATTER), use `plot3d()` and pass in a data frame where the first three columns represent *x*, *y*, and *z* coordinates, or pass in three vectors representing the *x*, *y*, and *z* coordinates.

```{r FIG-MISCGRAPH-3D-SCATTER, eval=FALSE, fig.cap="A 3D scatter plot"}
# You may need to install first, with install.packages("rgl")
library(rgl)
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg, type = "s", size = 0.75, lit = FALSE)
```

Viewers can rotate the image by clicking and dragging with the mouse, and zoom in and out with the scroll wheel.

> **Note**
>
> By default, `plot3d()` uses square points, which do not appear properly when saving to a PDF. For improved appearance, the example above uses `type="s"` for spherical points, made them smaller with `size=0.75`, and turned off the 3D lighting with `lit=FALSE` (otherwise they look like shiny spheres).

### Discussion

Three-dimensional scatter plots can be difficult to interpret, so it's often better to use a two-dimensional representation of the data. That said, there are things that can help make a 3D scatter plot easier to understand.

In Figure \@ref(fig:FIG-MISCGRAPH-3D-SCATTER2), we'll add vertical segments to help give a sense of the spatial positions of the points:

```{r FIG-MISCGRAPH-3D-SCATTER2, eval=FALSE, fig.cap="A 3D scatter plot with vertical lines for each point"}
# Function to interleave the elements of two vectors
interleave <- function(v1, v2)  as.vector(rbind(v1,v2))

# Plot the points
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg,
       xlab = "Weight", ylab = "Displacement", zlab = "MPG",
       size = .75, type = "s", lit = FALSE)

# Add the segments
segments3d(interleave(mtcars$wt,   mtcars$wt),
           interleave(mtcars$disp, mtcars$disp),
           interleave(mtcars$mpg,  min(mtcars$mpg)),
           alpha = 0.4, col = "blue")
```


It's possible to tweak the appearance of the background and the axes. In Figure \@ref(fig:FIG-MISCGRAPH-3D-SCATTER3), we change the number of tick marks and add tick marks and axis labels to the specified sides:

```{r FIG-MISCGRAPH-3D-SCATTER3, eval=FALSE, fig.show="hold", fig.cap="Left: 3D scatter plot with axis ticks and labels repositioned; right: from a different point of view"}
# Make plot without axis ticks or labels
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg,
       xlab = "", ylab = "", zlab = "",
       axes = FALSE,
       size = .75, type = "s", lit = FALSE)

segments3d(interleave(mtcars$wt,   mtcars$wt),
           interleave(mtcars$disp, mtcars$disp),
           interleave(mtcars$mpg,  min(mtcars$mpg)),
           alpha = 0.4, col = "blue")

# Draw the box.
rgl.bbox(color = "grey50",          # grey60 surface and black text
         emission = "grey50",       # emission color is grey50
         xlen = 0, ylen = 0, zlen = 0)  # Don't add tick marks

# Set default color of future objects to black
rgl.material(color = "black")

# Add axes to specific sides. Possible values are "x--", "x-+", "x+-", and "x++".
axes3d(edges = c("x--", "y+-", "z--"),
       ntick = 6,                       # Attempt 6 tick marks on each side
       cex = .75)                       # Smaller font

# Add axis labels. 'line' specifies how far to set the label from the axis.
mtext3d("Weight",       edge = "x--", line = 2)
mtext3d("Displacement", edge = "y+-", line = 3)
mtext3d("MPG",          edge = "z--", line = 3)
```


### See Also

See `?plot3d` for more options for controlling the output.



Adding a Prediction Surface to a Three-Dimensional Plot {#RECIPE-MISCGRAPH-3D-SCATTER-MODEL}
-------------------------------------------------------

### Problem

You want to add a surface of predicted value to a three-dimensional scatter plot.

### Solution

First we need to define some utility functions for generating the predicted values from a model object:

```{r eval=FALSE}
# Given a model, predict zvar from xvar and yvar
# Defaults to range of x and y variables, and a 16x16 grid
predictgrid <- function(model, xvar, yvar, zvar, res = 16, type = NULL) {
  # Find the range of the predictor variable. This works for lm and glm
  # and some others, but may require customization for others.
  xrange <- range(model$model[[xvar]])
  yrange <- range(model$model[[yvar]])

  newdata <- expand.grid(x = seq(xrange[1], xrange[2], length.out = res),
                         y = seq(yrange[1], yrange[2], length.out = res))
  names(newdata) <- c(xvar, yvar)
  newdata[[zvar]] <- predict(model, newdata = newdata, type = type)
  newdata
}


# Convert long-style data frame with x, y, and z vars into a list
# with x and y as row/column values, and z as a matrix.
df2mat <- function(p, xvar = NULL, yvar = NULL, zvar = NULL) {
  if (is.null(xvar)) xvar <- names(p)[1]
  if (is.null(yvar)) yvar <- names(p)[2]
  if (is.null(zvar)) zvar <- names(p)[3]

  x <- unique(p[[xvar]])
  y <- unique(p[[yvar]])
  z <- matrix(p[[zvar]], nrow = length(y), ncol = length(x))

  m <- list(x, y, z)
  names(m) <- c(xvar, yvar, zvar)
  m
}

# Function to interleave the elements of two vectors
interleave <- function(v1, v2)  as.vector(rbind(v1,v2))
```

With these utility functions defined, we can make a linear model from the data and plot it as a mesh along with the data, using the `surface3d()` function, as shown in Figure \@ref(fig:FIG-MISCGRAPH-3D-SCATTER-MODEL):

```{r FIG-MISCGRAPH-3D-SCATTER-MODEL, eval=FALSE, fig.cap="A 3D scatter plot with a prediction surface"}
library(rgl)

# Make a copy of the data set
m <- mtcars

# Generate a linear model
mod <- lm(mpg ~ wt + disp + wt:disp, data = m)

# Get predicted values of mpg from wt and disp
m$pred_mpg <- predict(mod)

# Get predicted mpg from a grid of wt and disp
mpgrid_df <- predictgrid(mod, "wt", "disp", "mpg")
mpgrid_list <- df2mat(mpgrid_df)

# Make the plot with the data points
plot3d(m$wt, m$disp, m$mpg, type = "s", size = 0.5, lit = FALSE)

# Add the corresponding predicted points (smaller)
spheres3d(m$wt, m$disp, m$pred_mpg, alpha = 0.4, type = "s", size = 0.5, lit = FALSE)

# Add line segments showing the error
segments3d(interleave(m$wt,   m$wt),
           interleave(m$disp, m$disp),
           interleave(m$mpg,  m$pred_mpg),
           alpha = 0.4, col = "red")

# Add the mesh of predicted values
surface3d(mpgrid_list$wt, mpgrid_list$disp, mpgrid_list$mpg,
          alpha = 0.4, front = "lines", back = "lines")
```


### Discussion

We can tweak the appearance of the graph, as shown in Figure \@ref(fig:FIG-MISCGRAPH-3D-SCATTER-MODEL2). We'll add each of the components of the graph separately:

```{r FIG-MISCGRAPH-3D-SCATTER-MODEL2, eval=FALSE, fig.cap="Three-dimensional scatter plot with customized appearance"}
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg,
       xlab = "", ylab = "", zlab = "",
       axes = FALSE,
       size = .5, type = "s", lit = FALSE)

# Add the corresponding predicted points (smaller)
spheres3d(m$wt, m$disp, m$pred_mpg, alpha = 0.4, type = "s", size = 0.5, lit = FALSE)

# Add line segments showing the error
segments3d(interleave(m$wt,   m$wt),
           interleave(m$disp, m$disp),
           interleave(m$mpg,  m$pred_mpg),
           alpha = 0.4, col = "red")

# Add the mesh of predicted values
surface3d(mpgrid_list$wt, mpgrid_list$disp, mpgrid_list$mpg,
          alpha = 0.4, front = "lines", back = "lines")

# Draw the box
rgl.bbox(color = "grey50",          # grey60 surface and black text
         emission = "grey50",       # emission color is grey50
         xlen = 0, ylen = 0, zlen = 0)  # Don't add tick marks

# Set default color of future objects to black
rgl.material(color = "black")

# Add axes to specific sides. Possible values are "x--", "x-+", "x+-", and "x++".
axes3d(edges = c("x--", "y+-", "z--"),
       ntick = 6,                       # Attempt 6 tick marks on each side
       cex = .75)                       # Smaller font

# Add axis labels. 'line' specifies how far to set the label from the axis.
mtext3d("Weight",       edge = "x--", line = 2)
mtext3d("Displacement", edge = "y+-", line = 3)
mtext3d("MPG",          edge = "z--", line = 3)
```


### See Also

For more on changing the appearance of the surface, see `?rgl.material`.



Saving a Three-Dimensional Plot {#RECIPE-MISCGRAPH-3D-SAVE}
-------------------------------

### Problem

You want to save a three-dimensional plot created with the rgl package.

### Solution

To save a bitmap image of a plot created with rgl, use `rgl.snapshot()`. This will capture the exact image that is on the screen:

```{r eval=FALSE}
library(rgl)
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg, type = "s", size = 0.75, lit = FALSE)

rgl.snapshot('3dplot.png', fmt = 'png')
```

You can also use `rgl.postscript()` to save a PostScript or PDF file:

```{r eval=FALSE}
rgl.postscript('figs/miscgraph/3dplot.pdf', fmt = 'pdf')

rgl.postscript('figs/miscgraph/3dplot.ps', fmt = 'ps')
```

PostScript and PDF output does not support many features of the OpenGL library on which rgl is based. For example, it does not support transparency, and the sizes of objects such as points and lines may not be the same as what appears on the screen.

### Discussion

To make the output more repeatable, you can save your current viewpoint and restore it later:

```{r eval=FALSE}
# Save the current viewpoint
view <- par3d("userMatrix")

# Restore the saved viewpoint
par3d(userMatrix = view)
```

To save view in a script, you can use `dput()`, then copy and paste the output into your script:

```{r eval=FALSE}
dput(view)
```

Once you have the text representation of the `userMatrix`, add the following to your script:

```{r eval=FALSE}
view <- structure(c(0.907931625843048, 0.267511069774628, -0.322642296552658,
0, -0.410978674888611, 0.417272746562958, -0.810543060302734,
0, -0.0821993798017502, 0.868516683578491, 0.488796472549438,
0, 0, 0, 0, 1), .Dim = c(4L, 4L))

par3d(userMatrix = view)
```



Animating a Three-Dimensional Plot {#RECIPE-MISCGRAPH-3D-ANIMATE}
----------------------------------

### Problem

You want to animate a three-dimensional plot by moving the viewpoint around the plot.

### Solution

Rotating a 3D plot can provide a more complete view of the data. To animate a 3D plot, use `play3d()` with `spin3d()`:

```{r eval=FALSE}
library(rgl)
plot3d(mtcars$wt, mtcars$disp, mtcars$mpg, type = "s", size = 0.75, lit = FALSE)

play3d(spin3d())
```

### Discussion

By default, the graph will be rotated on the *z* (vertical) axis, until you send a break command to R.

You can change the rotation axis, rotation speed, and duration:

```{r eval=FALSE}
# Spin on x-axis, at 4 rpm, for 20 seconds
play3d(spin3d(axis = c(1,0,0), rpm = 4), duration = 20)
```

To save the movie, use the `movie3d()` function in the same way as `play3d()`. It will generate a series of *.png* files, one for each frame, and then attempt to combine them into a single animated *.gif* file using the convert program from the ImageMagick image utility.

This will spin the plot once in 15 seconds, at 50 frames per second:

```{r eval=FALSE}
# Spin on z axis, at 4 rpm, for 15 seconds
movie3d(spin3d(axis = c(0,0,1), rpm = 4), duration = 15, fps = 50)
```

The output file will be saved in a temporary directory, and the name will be printed on the R console.

If you don't want to use ImageMagick to convert the output to a *.gif*, you can specify `convert=FALSE` and then convert the series of *.png* files to a movie using some other utility.



Creating a Dendrogram {#RECIPE-MISCGRAPH-DENDROGRAM}
---------------------

### Problem

You want to make a dendrogram to show how items are clustered.

### Solution

Use `hclust()` and plot the output from it. This can require a fair bit of data preprocessing. For this example, we'll first take a subset of the `countries` data set from the year 2009. For simplicity, we'll also drop all rows that contain an `NA`, and then select a random 25 of the remaining rows:

```{r}
library(gcookbook) # For the data set
# Get data from year 2009
c2 <- subset(countries, Year == 2009) # Drop rows that have any NA values
c2 <- c2[complete.cases(c2), ]        # Pick out a random 25 countries
# (Set random seed to make this repeatable)
set.seed(201)
c2 <- c2[sample(1:nrow(c2), 25), ]
c2
```

Notice that the row names (the first column) are essentially random numbers, since the rows were selected randomly. We need to do a few more things to the data before making a dendrogram from it. First, we need to set the *row names*-right now there's a column called `Name`, but the row names are those random numbers (we don't often use row names, but for the `hclust()` function they're essential). Next, we'll need to drop all the columns that aren't values used for clustering. These columns are `Name`, `Code`, and `Year`:

```{r}
rownames(c2) <- c2$Name
c2 <- c2[,4:7]
c2
```

The values for `GDP` are several orders of magnitude larger than the values for, say, `infmortality.` Because of this, the effect of `infmortality` on the clustering will be negligible compared to the effect of `GDP.` This probably isn't what we want. To address this issue, we'll scale the data:

```{r}
c3 <- scale(c2)
c3
```

By default the `scale()` function scales each column relative to its standard deviation, but other methods may be used.

Finally, we're ready to make the dendrogram, as shown in Figure \@ref(fig:FIG-MISCGRAPH-DENDROGRAM):

```{r FIG-MISCGRAPH-DENDROGRAM, fig.show="hold", fig.cap="Left: a dendrogram; right: with text aligned", fig.width=6, fig.height=5}
hc <- hclust(dist(c3))

# Make the dendrogram
plot(hc)

# With text aligned
plot(hc, hang = -1)
```


### Discussion

A cluster analysis is simply a way of assigning points to groups in an *n*-dimensional space (four dimensions, in this example). A hierarchical cluster analysis divides each group into two smaller groups, and can be represented with the dendrograms in this recipe. There are many different parameters you can control in the hierarchical cluster analysis process, and there may not be a single "right" way to do it for your data.

First, we normalized the data using `scale()` with its default settings. You can scale your data differently, or not at all. (With this data set, *not* scaling the data will lead to GDP overwhelming the other variables, as shown in Figure \@ref(fig:FIG-MISCGRAPH-DENDROGRAM-UNSCALED).)

```{r FIG-MISCGRAPH-DENDROGRAM-UNSCALED, fig.cap="Dendrogram with unscaled data-notice the much larger Height values, which are largely due to the unscaled GDP values", fig.width=6, fig.height=5}
hc <- hclust(dist(c2))
plot(hc)
```

For the distance calculation, we used the default method, "euclidean", which calculates the Euclidean distance between the points. The other possible methods are "maximum", "manhattan", "canberra", "binary", and "minkowski".

The `hclust()` function provides several methods for performing the cluster analysis. The default is "complete"; the other possible methods are "ward", "single", "average", "mcquitty", "median", and "centroid".

### See Also

See `?hclust` for more information about the different clustering methods.




Creating a Vector Field {#RECIPE-MISCGRAPH-VECTORFIELD}
-----------------------

### Problem

You want to make a vector field.

### Solution

Use `geom_segment()`. For this example, we'll use the `isabel` data set:

```{r}
library(gcookbook) # For the data set
isabel
```

`x` and `y` are the longitude and latitude, respectively, and `z` is the height in kilometers. The `vx`, `vy`, and `vz` values are the wind speed components in each of these directions, in meters per second, and speed is the wind speed.

The height (`z`) ranges from 0.035 km to 18.035 km. For this example, we'll just use the lowest slice of data.

To draw the vectors (Figure \@ref(fig:FIG-MISCGRAPH-VECTOR)), we'll use `geom_segment()`. Each segment has a starting point and an ending point. We'll use the `x` and `y` values as the starting points for each segment, then add a fraction of the `vx` and `vy` values to get the end points for each segment. If we didn't scale down these values, the lines would be much too long:

```{r FIG-MISCGRAPH-VECTOR, fig.cap="First attempt at a vector field-the resolution of the data is too high, but it does hint at some interesting patterns not visible in graphs with a lower data resolution", fig.width=5, fig.height=5}
islice <- subset(isabel, z == min(z))

ggplot(islice, aes(x = x, y = y)) +
       geom_segment(aes(xend = x + vx/50, yend = y + vy/50),
                    size = 0.25)   # Make the line segments 0.25 mm thick
```

This vector field has two problems: the data is at too high a resolution to read, and the segments do not have arrows indicating the direction of the flow. To reduce the resolution of the data, we'll define a function `every_n()` that keeps one out of every `n` values in the data and drops the rest:

```{r}
# Take a slice where z is equal to the minimum value of z
islice <- subset(isabel, z == min(z))

# Keep 1 out of every 'by' values in vector x
every_n <- function(x, by = 2) {
    x <- sort(x)
    x[seq(1, length(x), by = by)]
}

# Keep 1 of every 4 values in x and y
keepx <- every_n(unique(isabel$x), by = 4)
keepy <- every_n(unique(isabel$y), by = 4)

# Keep only those rows where x value is in keepx and y value is in keepy
islicesub <- subset(islice, x %in% keepx  &  y %in% keepy)
```

Now that we've taken a subset of the data, we can plot it, with arrowheads, as shown in Figure \@ref(fig:FIG-MISCGRAPH-VECTORFIELD-ARROW):

```{r FIG-MISCGRAPH-VECTORFIELD-ARROW, fig.cap="Vector field with arrowheads", fig.width=5, fig.height=5}
# Need to load grid for arrow() function
library(grid)

# Make the plot with the subset, and use an arrowhead 0.1 cm long
ggplot(islicesub, aes(x = x, y = y)) +
    geom_segment(aes(xend = x+vx/50, yend = y+vy/50),
                 arrow = arrow(length = unit(0.1, "cm")), size = 0.25)
```

### Discussion

One effect of arrowheads is that short vectors appear with more ink than is proportional to their length. This could somewhat distort the interpretation of the data. To mitigate this effect, it may also be useful to map the speed to other properties, like `size` (line thickness), `alpha`, or `colour`. Here, we'll map speed to alpha (Figure \@ref(fig:FIG-MISCGRAPH-VECTORFIELD-AES), left):

```{r FIG-MISCGRAPH-VECTORFIELD-AES-1, eval=FALSE}
# The existing 'speed' column includes the z component. We'll calculate
# speedxy, the horizontal speed.
islicesub$speedxy <- sqrt(islicesub$vx^2 + islicesub$vy^2)

# Map speed to alpha
ggplot(islicesub, aes(x = x, y = y)) +
    geom_segment(aes(xend = x+vx/50, yend = y+vy/50, alpha = speed),
                 arrow = arrow(length = unit(0.1,"cm")), size = 0.6)
```

Next, we'll map speed to colour. We'll also add a map of the United States and zoom in on the area of interest, as shown in the graph on the right in Figure \@ref(fig:FIG-MISCGRAPH-VECTORFIELD-AES),using coord_cartesian() (without this, the entire USA will be displayed):

```{r FIG-MISCGRAPH-VECTORFIELD-AES-2, eval=FALSE}
# Get USA map data
usa <- map_data("usa")

# Map speed to colour, and set go from "grey80" to "darkred"
ggplot(islicesub, aes(x = x, y = y)) +
    geom_segment(aes(xend = x+vx/50, yend = y+vy/50, colour = speed),
                 arrow = arrow(length = unit(0.1,"cm")), size = 0.6) +
    scale_colour_continuous(low = "grey80", high = "darkred") +
    geom_path(aes(x = long, y = lat, group = group), data = usa) +
    coord_cartesian(xlim = range(islicesub$x), ylim = range(islicesub$y))
```


```{r FIG-MISCGRAPH-VECTORFIELD-AES, ref.label=c("FIG-MISCGRAPH-VECTORFIELD-AES-1", "FIG-MISCGRAPH-VECTORFIELD-AES-2"), echo=FALSE, fig.show="hold", fig.cap="Left: vector field with speed mapped to alpha; right: with speed mapped to colour", fig.width=6, fig.height=5}

```

The `isabel` data set has three-dimensional data, so we can also make a faceted graph of the data, as shown in Figure \@ref(fig:FIG-MISCGRAPH-VECTORFIELD-FACET). Because each facet is small, we will use a sparser subset than before:

```{r FIG-MISCGRAPH-VECTORFIELD-FACET, fig.cap="Vector field of wind speeds, faceted on `z`", fig.width=9, fig.height=6}
# Keep 1 out of every 5 values in x and y, and 1 in 2 values in z
keepx <- every_n(unique(isabel$x), by = 5)
keepy <- every_n(unique(isabel$y), by = 5)
keepz <- every_n(unique(isabel$z), by = 2)

isub <- subset(isabel, x %in% keepx  &  y %in% keepy  &  z %in% keepz)

ggplot(isub, aes(x = x, y = y)) +
    geom_segment(aes(xend = x+vx/50, yend = y+vy/50, colour = speed),
                 arrow = arrow(length = unit(0.1,"cm")), size = 0.5) +
    scale_colour_continuous(low = "grey80", high = "darkred") +
    facet_wrap( ~ z)
```


### See Also

If you want to use a different color palette, see Recipe \@ref(RECIPE-COLORS-PALETTE-CONTINUOUS).

See Recipe \@ref(RECIPE-AXES-RANGE) for more information about zooming in on part of a graph.


Creating a QQ Plot {#RECIPE-MISCGRAPH-QQ}
------------------

### Problem

You want to make a quantile-quantile (QQ) plot to compare an empirical distribution to a theoretical distribution.

### Solution

Use `qqnorm()` to compare to a normal distribution. Give `qqnorm()` a vector of numerical values, and add a theoretical distribution line with `qqline()` (Figure \@ref(fig:FIG-MISCGRAPH-QQ)):

```{r FIG-MISCGRAPH-QQ, fig.show="hold", fig.cap="Left: QQ plot of height, which is close to normally distributed; right: QQ plot of age, which is not normally distributed"}
library(gcookbook) # For the data set

# QQ plot of height
qqnorm(heightweight$heightIn)
qqline(heightweight$heightIn)

# QQ plot of age
qqnorm(heightweight$ageYear)
qqline(heightweight$ageYear)
```


### Discussion

The points for `heightIn` are close to the line, which means that the distribution is close to normal. In contrast, the points for `ageYear` veer far away from the line, especially on the left, indicating that the distribution is skewed. A histogram may also be useful for exploring how the data is distributed.

### See Also

See `?qqplot` for information on comparing data to theoretical distributions other than the normal distribution.

ggplot has a `stat_qq()` function, but it doesn't provide an easy way to draw the QQ line.



Creating a Graph of an Empirical Cumulative Distribution Function {#RECIPE-MISCGRAPH-ECDF}
-----------------------------------------------------------------

### Problem

You want to graph the empirical cumulative distribution function (ECDF) of a data set.

### Solution

Use `stat_ecdf()` (Figure \@ref(fig:FIG-MISCGRAPH-ECDF)):

```{r FIG-MISCGRAPH-ECDF, fig.show="hold", fig.cap="Left: ECDF of height; right: ECDF of age"}
library(gcookbook) # For the data set

# ecdf of heightIn
ggplot(heightweight, aes(x = heightIn)) + stat_ecdf()

# ecdf of ageYear
ggplot(heightweight, aes(x = ageYear)) + stat_ecdf()
```

### Discussion

The ECDF shows what proportion of observations are at or below the given *x* value. Because it is *empirical*, the line takes a step up at each *x* value where there are one or more observations.



Creating a Mosaic Plot {#RECIPE-MISCGRAPH-MOSAIC}
----------------------

```{r echo=FALSE}
knit_print.table <- function(x, ...) {
    txt <- capture.output(base::print.table(x, ...))
    if (length(txt) > 14) {
        cat(txt[1:14], sep = "\n")
        cat("# ... with", length(txt)-1, "more lines of text\n")
    }
    invisible()
}
```

### Problem

You want to make a mosaic plot to visualize a contingency table.

### Solution

Use the `mosaic()` function from the vcd package. For this example we'll use the `USBAdmissions` data set, which is a contingency table with three dimensions. We'll first take a look at the data in a few different ways:

```{r}
UCBAdmissions

# Print a "flat" contingency table
ftable(UCBAdmissions)

dimnames(UCBAdmissions)
```

The three dimensions are `Admit`, `Gender`, and `Dept`. To visualize the relationships between the variables (Figure \@ref(fig:FIG-MISCGRAPH-MOSAIC)), use `mosaic()` and pass it a formula with the variables that will be used to split up the data:

```{r FIG-MISCGRAPH-MOSAIC, fig.cap="Mosaic plot of UC-Berkeley admissions data-the area of each rectangle is proportional to the number of cases in that cell", fig.width=5, fig.height=9}
# You may need to install first, with install.packages("vcd")
library(vcd)
# Split by Admit, then Gender, then Dept
mosaic( ~ Admit + Gender + Dept, data = UCBAdmissions)
```

Notice that `mosaic()` splits the data in the order in which the variables are provided: first on admission status, then gender, then department. The resulting plot order makes it very clear that more applicants were rejected than admitted. It is also clear that within the admitted group there were many more men than women, while in the rejected group there were approximately the same number of men and women. It is difficult to make comparisons within each department, though. A different variable splitting order may reveal some other interesting information.

Another way of looking at the data is to split first by department, then gender, then admission status, as in Figure \@ref(fig:FIG-MISCGRAPH-MOSAIC2). This makes the admission status the last variable that is partitioned, so that *after* partitioning by department and gender, the admitted and rejected cells for each group are right next to each other:

```{r FIG-MISCGRAPH-MOSAIC2, fig.cap="Mosaic plot with a different variable splitting order: first department, then gender, then admission status", fig.width=14, fig.height=4}
mosaic( ~ Dept + Gender + Admit, data = UCBAdmissions,
    highlighting = "Admit", highlighting_fill = c("lightblue", "pink"),
    direction = c("v","h","v"))
```

We also specified a variable to highlight (`Admit`), and which colors to use in the highlighting.

### Discussion

In the preceding example we also specified the *direction* in which each variable will be split. The first variable, `Dept`, is split vertically; the second variable, `Gender`, is split horizontally; and the third variable, `Admit`, is split vertically. The reason that we chose these directions is because, in this particular example, it makes it easy to compare the male and female groups within each department.

We can also use different splitting directions, as shown in Figure \@ref(fig:FIG-MISCGRAPH-MOSAIC3) and Figure \@ref(fig:FIG-MISCGRAPH-MOSAIC4):

```{r FIG-MISCGRAPH-MOSAIC3, fig.cap="Splitting Dept vertically, Gender vertically, and Admit horizontally", fig.width=12, fig.height=3}
# Another possible set of splitting directions
mosaic( ~ Dept + Gender + Admit, data = UCBAdmissions,
    highlighting = "Admit", highlighting_fill = c("lightblue", "pink"),
    direction = c("v", "v", "h"))
```

```{r FIG-MISCGRAPH-MOSAIC4, fig.cap="Splitting Dept vertically, Gender horizontally, and Admit horizontally", fig.width=12, fig.height=5}
# This order makes it difficult to compare male and female
mosaic( ~ Dept + Gender + Admit, data = UCBAdmissions,
    highlighting = "Admit", highlighting_fill = c("lightblue", "pink"),
    direction = c("v", "h", "h"))
```

The example here illustrates a classic case of Simpson's paradox, in which a relationship between variables within subgroups can change (or reverse!) when the groups are combined. The `UCBerkeley` table contains admissions data from the University of California-Berkeley in 1973. Overall, men were admitted at a higher rate than women, and because of this, the university was sued for gender bias. But when each department was examined separately, it was found that they each had approximately equal admission rates for men and women. The difference in overall admission rates was because women were more likely to apply to competitive departments with lower admission rates.

In Figure \@ref(fig:FIG-MISCGRAPH-MOSAIC2) and Figure \@ref(fig:FIG-MISCGRAPH-MOSAIC3), you can see that within each department, admission rates were approximately equal between men and women. You can also see that departments with higher admission rates (A and B) were very imbalanced in the gender ratio of applicants: far more men applied to these departments than did women. As you can see, partitioning the data in different orders and directions can bring out different aspects of the data. In Figure \@ref(fig:FIG-MISCGRAPH-MOSAIC3), as in Figure \@ref(fig:FIG-MISCGRAPH-MOSAIC2), its easy to compare male and female admission rates within each department and across departments. Splitting `Dept` vertically, `Gender` horizontally, and `Admit` horizontally, as in Figure \@ref(fig:FIG-MISCGRAPH-MOSAIC4), makes it difficult to compare male and female admission rates within each department, but it is easy to compare male and female application rates across departments.

### See Also

See `?mosaicplot` for another function that can create mosaic plots.

P.J. Bickel, E.A. Hammel, and J.W. O'Connell, "Sex Bias in Graduate Admissions: Data from Berkeley," *Science* 187 (1975): 398404.


make a pie chart.

### Solution

Use the `pie()` function. In this example (Figure \@ref(fig:FIG-MISCGRAPH-PIE)), we'll use the survey data set from the MASS library:

```{r FIG-MISCGRAPH-PIE, fig.cap="A pie chart"}
library(MASS) # For the data set 
# Get a table of how many cases are in each level of fold
fold <- table(survey$Fold)
fold

# Reduce margins so there's less blank space around the plot
par(mar = c(1, 1, 1, 1))
# Make the pie chart
pie(fold)
```

We passed `pie()` an object of class table. We could have instead given it a named vector, or a vector of values and a vector of labels like this, with the same result:

```{r eval=FALSE}
pie(c(99, 18, 120), labels = c("L on R", "Neither", "R on L"))
```

### Discussion

The lowly pie chart is the subject of frequent abuse from data visualization experts. If you're thinking of using a pie chart, consider whether a bar graph (or stacked bar graph) would convey the information more effectively. Despite their faults, pie charts do have one important virtue: everyone knows how to read them.




Creating a Map {#RECIPE-MISCGRAPH-MAP}
--------------

### Problem

You want to create a geographical map.

### Solution

Retrieve map data from the maps package and draw it with `geom_polygon()` (which can have a color fill) or `geom_path()` (which can't have a fill). By default, the latitude and longitude will be drawn on a Cartesian coordinate plane, but you can use `coord_map()` and specify a projection. The default projection is "mercator", which, unlike the Cartesian plane, has a progressively changing spacing for latitude lines (Figure \@ref(fig:FIG-MISCGRAPH-MAP)):

```{r FIG-MISCGRAPH-MAP, fig.show="hold", fig.cap="Top: a basic map with fill; bottom: with no fill, and Mercator projection", fig.width=5}
library(maps) # For map data
# Get map data for USA
states_map <- map_data("state") # ggplot2 must be loaded to use map_data()

ggplot(states_map, aes(x = long, y = lat, group = group)) +
    geom_polygon(fill = "white", colour = "black")

# geom_path (no fill) and Mercator projection
ggplot(states_map, aes(x = long, y = lat, group = group)) +
    geom_path() + coord_map("mercator")
```

### Discussion

The `map_data()` function returns a data frame with the following columns:

* **long**: Longitude.
* **lat**: Latitude.
* **group**: This is a grouping variable for each polygon. A region or subregion might have multiple polygons, for example, if it includes islands.
* **order**: The order to connect each point within a group.
* **region**: Roughly, the names of countries, although some other objects are present (such as some lakes).
* **subregion**: The names of subregions within a region, which can contain multiple groups. For example, the Alaska subregion includes many islands, each with its own group.

There are a number of different maps available, including world, nz, france, italy, usa (outline of the United States), state (each state in the USA), and county (each county in the USA). For example, to get map data for the world:

```{r}
# Get map data for world
world_map <- map_data("world")
world_map
```

If you want to draw a map of a region in the world map for which there isn't a separate map, you can first look for the region name, like so:

```{r}
sort(unique(world_map$region))
```


It's possible to get data for specific regions from a particular map (Figure \@ref(fig:FIG-MISCGRAPH-MAP-REGIONS)):

```{r FIG-MISCGRAPH-MAP-REGIONS, fig.cap="Specific regions from the world map", fig.width=8, fig.height=5}
east_asia <- map_data("world", region = c("Japan", "China", "North Korea",
                                        "South Korea"))
# Map region to fill color
ggplot(east_asia, aes(x = long, y = lat, group = group, fill = region)) +
    geom_polygon(colour = "black") +
    scale_fill_brewer(palette = "Set2")
```

If there is a separate map available for a region, such as `nz` (New Zealand), that map data will be at a higher resolution than if you were to extract it from the world map, as shown in Figure \@ref(fig:FIG-MISCGRAPH-MAP-RESOLUTION):

```{r FIG-MISCGRAPH-MAP-RESOLUTION, fig.show="hold", fig.cap="Left: New Zealand data taken from `world` map; right: data from `nz` map"}
# Get New Zealand data from world map
nz1 <- map_data("world", region = "New Zealand")
nz1 <- subset(nz1, long > 0 & lat > -48)        # Trim off islands
ggplot(nz1, aes(x = long, y = lat, group = group)) + geom_path()

# Get New Zealand data from the nz map
nz2 <- map_data("nz")
ggplot(nz2, aes(x = long, y = lat, group = group)) + geom_path()
```

### See Also

See the mapdata package for more map data sets. It includes maps of China and Japan, as well as a high-resolution world map, `worldHires`.

See the `map()` function, for quickly generating maps.

See `?mapproject` for a list of available map projections.




Creating a Choropleth Map {#RECIPE-MISCGRAPH-CHOROPLETH}
-------------------------

### Problem

You want to create a map with regions that are colored according to variable values.

### Solution

Merge the value data with the map data, then map a variable to `fill`:

```{r}
# Transform the USArrests data set to the correct format
crimes <- data.frame(state = tolower(rownames(USArrests)), USArrests)
crimes

library(maps) # For map data
states_map <- map_data("state")
# Merge the data sets together
crime_map <- merge(states_map, crimes, by.x = "region", by.y = "state")
# After merging, the order has changed, which would lead to polygons drawn in
# the incorrect order. So, we'll sort the data.
head(crime_map)

library(dplyr) # For arrange() function
# Sort by group, then order
crime_map <- arrange(crime_map, group, order)
head(crime_map)
```
Once the data is in the correct format, it can be plotted (Figure \@ref(fig:FIG-MISCGRAPH-CHOROPLETH)), mapping one of the columns with data values to fill:

```{r FIG-MISCGRAPH-CHOROPLETH, fig.cap="A map with a variable mapped to fill", fig.width=7, fig.height=5}
ggplot(crime_map, aes(x = long, y = lat, group = group, fill = Assault)) +
    geom_polygon(colour = "black") +
    coord_map("polyconic")
```


### Discussion

The preceding example used the default color scale, which goes from dark to light blue. If you want to show how the values diverge from some middle value, you can use `scale_fill_gradient2()`, as shown in Figure \@ref(fig:FIG-MISCGRAPH-CHOROPLETH-MIDPOINT):

```{r FIG-MISCGRAPH-CHOROPLETH-MIDPOINT, fig.cap="With a diverging color scale", fig.width=7, fig.height=5}
ggplot(crimes, aes(map_id = state, fill = Assault)) +
    geom_map(map = states_map, colour = "black") +
    scale_fill_gradient2(low = "#559999", mid = "grey90", high = "#BB650B",
                         midpoint = median(crimes$Assault)) +
    expand_limits(x = states_map$long, y = states_map$lat) +
    coord_map("polyconic")
```

The previous example mapped continuous values to fill, but we could just as well use discrete values. It's sometimes easier to interpret the data if the values are discretized. For example, we can categorize the values into quantiles and show those quantiles, as in Figure \@ref(fig:FIG-MISCGRAPH-CHOROPLETH-DISCRETE):


```{r FIG-MISCGRAPH-CHOROPLETH-DISCRETE, fig.cap="Choropleth map with discretized data", fig.width=7, fig.height=5}
# Find the quantile bounds
qa <- quantile(crimes$Assault, c(0, 0.2, 0.4, 0.6, 0.8, 1.0))
qa

# Add a column of the quantile category
crimes$Assault_q <- cut(crimes$Assault, qa,
    labels = c("0-20%", "20-40%", "40-60%", "60-80%", "80-100%"),
    include.lowest = TRUE)
crimes
# Generate a discrete color palette with 5 values
pal <- colorRampPalette(c("#559999", "grey80", "#BB650B"))(5)
pal

ggplot(crimes, aes(map_id = state, fill = Assault_q)) +
    geom_map(map = states_map, colour = "black") +
    scale_fill_manual(values = pal) +
    expand_limits(x = states_map$long, y = states_map$lat) +
    coord_map("polyconic") +
    labs(fill = "Assault Rate\\nPercentile")
```

Another way to make a choropleth, but without needing to merge the map data with the value data, is to use `geom_map()`. As of this writing, this will render maps faster than the method just described.

For this method, the map data frame must have columns named `lat`, `long`, and `region.` In the value data frame, there must be a column that is matched to the region column in the map data frame, and this column is specified by mapping it to the `map_id` aesthetic. For example, this code will have the same output as the first example (Figure \@ref(fig:FIG-MISCGRAPH-CHOROPLETH)):

```{r eval=FALSE}
# The 'state' column in the crimes data is to be matched to the 'region' column
# in the states_map data
ggplot(crimes, aes(map_id = state, fill = Assault)) +
    geom_map(map = states_map) +
    expand_limits(x = states_map$long, y = states_map$lat) +
    coord_map("polyconic")
```

Notice that we also needed to use `expand_limits()`. This is because unlike most geoms, `geom_map()` doesn't automatically set the x and y limits; the use of `expand_limits()` makes it include those x and y values. (Another way to accomplish the same result is to use `ylim()` and `xlim()`.)

### See Also

For an example of data overlaid on a map, see Recipe \@ref(RECIPE-MISCGRAPH-VECTORFIELD).

For more on using continuous colors, see Recipe \@ref(RECIPE-COLORS-PALETTE-CONTINUOUS).



Making a Map with a Clean Background {#RECIPE-MISCGRAPH-MAP-BACKGROUND}
------------------------------------

### Problem

You want to remove background elements from a map.

### Solution

Use `theme_void()` (Figure \@ref(fig:FIG-MISCGRAPH-MAP-BACKGROUND)). In this example, we'll add it to one of the choropleths we created in Recipe \@ref(RECIPE-MISCGRAPH-CHOROPLETH):

```{r FIG-MISCGRAPH-MAP-BACKGROUND, fig.cap="A map with a clean background", fig.width=7, fig.height=5}
ggplot(crimes, aes(map_id = state, fill = Assault_q)) +
    geom_map(map = states_map, colour = "black") +
    scale_fill_manual(values = pal) +
    expand_limits(x = states_map$long, y = states_map$lat) +
    coord_map("polyconic") +
    labs(fill = "Assault Rate\nPercentile") +
    theme_void()
```

### Discussion

In some maps, it's important to include contextual information such as the latitude and longitude. In others, this information is unimportant and distracts from the information that's being conveyed. In Figure \@ref(fig:FIG-MISCGRAPH-MAP-BACKGROUND), it's unlikely that viewers will care about the latitude and longitude of the states. They can probably identify the states by shape and relative position, and even if they can't, having the latitude and longitude isn't really helpful.





Creating a Map from a Shapefile {#RECIPE-MISCGRAPH-MAP-SHAPEFILE}
-------------------------------

### Problem

You want to create a geographical map from an Esri shapefile.

### Solution

Load the shapefile using `st_read()` from the sf package, then plot it with `geom_sf()` (Figure \@ref(fig:FIG-MISCGRAPH-MAP-SHAPEFILE)):

```{r FIG-MISCGRAPH-MAP-SHAPEFILE, fig.cap="A map created from a shapefile", fig.width=8, fig.height=6}
library(sf)

# Load the shapefile
taiwan_shp <- st_read("fig/TWN_adm/TWN_adm2.shp")

ggplot(taiwan_shp) + geom_sf()
```


### Discussion

Esri shapefiles are a common format for map data. The `st_read()` function reads a shape file and returns a `sf` object, which will also have other useful columns. Here's a look at the contents of the object.

```{r}
taiwan_shp
```

The sf object is a special kind of data frame, with 22 rows and 12 columns. Each row corresponds to one feature, and each column has some data about each feature. One of the columns is the geometry for each feature. This is a list-column -- a special type of column where each of the 22 elements contains one or more matrices of numbers representing the shape of the feature.

Columns in the data can be mapped to aesthetics like fill. For example, we can mapp the `ENGTYPE_2` column to fill, as shown in Figure \@ref(fig:FIG-MISCGRAPH-MAP-SHAPEFILE-2): 

```{r FIG-MISCGRAPH-MAP-SHAPEFILE-2, fig.cap="With a column mapped to `fill`", fig.width=8, fig.height=6}
ggplot(taiwan_shp) + geom_sf(aes(fill=ENGTYPE_2))
```

### See Also

The shapefile used in this example is not included in the gcookbook package. It and many other shapefiles are available for download at [http://www.gadm.org](http://www.gadm.org).

<!--chapter:end:ch13.Rmd-->

---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
# This block needs cache=FALSE to set fig.width and fig.height, and have those
# persist across cached builds.

source("utils.R", local = TRUE)
knitr::opts_chunk$set(fig.width=3.5, fig.height=3.5)
```


Output for Presentation {#CHAPTER-OUTPUT}
=======================

Broadly speaking, visualizations of data serve two purposes: discovery and communication. In the discovery phase, you'll create exploratory graphics, and when you do this, it's important to be able try out different things quickly. In the communication phase, you'll present your graphics to others. When you do that, you'll need to tweak the appearance of the graphics (which I've written about in previous chapters), and you'll usually need to put them somewhere other than on your computer screen. This chapter is about that last part: *saving* your graphics so that they can be presented in documents.

Outputting to PDF Vector Files {#RECIPE-OUTPUT-VECTOR}
------------------------------

### Problem

You want to create a PDF of your plot.

### Solution

There are two ways to output to PDF files. One method is to open the PDF graphics device with `pdf()`, make the plots, then close the device with `dev.off()`. This method works for most graphics in R, including base graphics and grid-based graphics like those created by ggplot2 and lattice:

```{r eval=FALSE}
# width and height are in inches
pdf("myplot.pdf", width = 4, height = 4)

# Make plots
plot(mtcars$wt, mtcars$mpg)
print(ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point())

dev.off()
```

If you make more than one plot, each one will go on a separate page in the PDF output. Notice that we called `print()` on the ggplot object to make sure that it will generate graphical output even when this code is in a script.

The `width` and `height` are in inches, so to specify the dimensions in centimeters, you must do the conversion manually:

```{r eval=FALSE}
# 8x8 cm
pdf("myplot.pdf", width = 8/2.54, height = 8/2.54)
```

If you are creating plots from a script and it throws an error while creating one, R might not reach the call to `dev.off()`, and could be left in a state where the PDF device is still open. When this happens, the PDF file won't open properly until you manually call `dev.off()`.

If you are creating a plot with ggplot2, using `ggsave()` can be a little simpler. You can store the ggplot object in a variable, and then call `ggsave()` on it:

```{r eval=FALSE}
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()

# Default is inches, but you can specify unit
ggsave("myplot.pdf", p, width = 8, height = 8, units = "cm")
```

Another way of using it is to skip the variable, and just call `ggsave()` after calling `ggplot()`. It will save the last ggplot object:

```{r eval=FALSE}
ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
ggsave("myplot.pdf", width = 8, height = 8, units = "cm")
```

With `ggsave()`, you don't need to `print()` the ggplot object, and if there is an error while creating or saving the plot, there's no need to manually close the graphic device. `ggsave()` can't be used to make multipage plots, though.

### Discussion

PDF files are usually the best option when your goal is to output to printed documents. They work easily with LaTeX and can be used in presentations with Apple's Keynote, but Microsoft programs may have trouble importing them. (See Recipe \@ref(RECIPE-OUTPUT-VECTOR-WMF) for details on creating vector images that can be imported into Microsoft programs.)

PDF files are also generally smaller than bitmap files such as portable network graphics (PNG) files, because they contain a set of drawing instructions, such as "Draw a line from here to there," instead of information about the color of each pixel. However, there are cases where bitmap files are smaller. For example, if you have a scatter plot that is heavily overplotted, a PDF file can end up much larger than a PNG -- even though most of the points are obscured, the PDF file will still contain instructions for drawing each and every point, whereas a bitmap file will not contain the redundant information. See Recipe \@ref(RECIPE-SCATTER-OVERPLOT) for an example.

### See Also

If you want to manually edit the PDF or SVG file, see Recipe \@ref(RECIPE-OUTPUT-EDIT-VECTOR).


Outputting to SVG Vector Files {#RECIPE-OUTPUT-VECTOR-SVG}
------------------------------

### Problem

You want to create a scalable vector graphics (SVG) image of your plot.

### Solution

Use `svglite()` from the svglite package:

```{r eval=FALSE}
library(svglite)
svglite("myplot.svg", width = 4, height = 4)
plot(...)
dev.off()

# With ggsave()
ggsave("myplot.svg", width = 8, height = 8, units = "cm")
```

### Discussion

Although R has a built-in `svg()` function that can generate SVG output, the svglite package provides more standards-compliant output.

When it comes to importing images, some programs may handle SVG files better than PDFs, and vice versa. For example, web browsers tend to have better SVG support, while document-creation programs like LaTeX tend to have better PDF support.


Outputting to WMF Vector Files {#RECIPE-OUTPUT-VECTOR-WMF}
------------------------------

### Problem

You want to create a Windows metafile (WMF) image of your plot.

### Solution

WMF files can be created and used in much the same way as PDF files -- but they can only be created on Windows:

```{r eval=FALSE}
win.metafile("myplot.wmf", width = 4, height = 4)
plot(...)
dev.off()

# With ggsave()
ggsave("myplot.wmf", width = 8, height = 8, units = "cm")
```

### Discussion

Windows programs such as Microsoft Word and PowerPoint have poor support for importing PDF files, but they natively support WMF. One drawback is that WMF files do not support transparency (alpha).


Editing a Vector Output File {#RECIPE-OUTPUT-EDIT-VECTOR}
----------------------------

### Problem

You want to open a vector output file for final editing.

### Solution

Sometimes you need to make final tweaks to the appearance of a graph for presentation. You can open PDF and SVG files with the excellent free program Inkscape, or with the commercial program Adobe Illustrator.

### Discussion

Font support can be a problem when you open a PDF file with Inkscape. Normally, point objects drawn with the PDF device will be written as symbols from the Zapf Dingbats font. This can be problematic if you want to open the file in an editor like Illustrator or Inkscape; for example, points may appear as the letter *q*, as in Figure \@ref(fig:FIG-OUTPUT-EDIT-VECTOR-DINGBATS), because that is the corresponding letter for a solid bullet in Zapf Dingbats.

```{r FIG-OUTPUT-EDIT-VECTOR-DINGBATS, echo=FALSE, fig.cap="Bad conversion of point symbols after opening in Inkscape-also notice that the spacing of the fonts is slightly off"}
knitr::include_graphics("fig/output-q.png")
```

To avoid this problem, set `useDingbats=FALSE`. This will make the circles be drawn as circles instead of as font characters:

```{r eval=FALSE}
pdf("myplot.pdf", width = 4, height = 4, useDingbats = FALSE)

# or
ggsave("myplot.pdf", width = 4, height = 4, useDingbats = FALSE)
```

> **Note**
>
> Inkscape might have some issues with fonts as well. You may have noticed that the fonts in Figure \@ref(fig:FIG-OUTPUT-EDIT-VECTOR-DINGBATS) don't look quite right. This is because Inkscape (version 0.48) couldn't find Helvetica, and substituted the font Bitstream Vera Sans instead. A workaround is to copy the Helvetica font file to your personal font library. For example, on Mac OS X, run `cp System/Library/Fonts/Helvetica.dfont ~/Library/Fonts/` from a Terminal window to do this, then, when it says there is a font conflict, click "Ignore Conflict." After this, Inkscape should properly display the Helvetica font.


Outputting to Bitmap (PNG/TIFF) Files {#RECIPE-OUTPUT-BITMAP}
-------------------------------------

### Problem

You want to create a bitmap of your plot, writing to a PNG file.

### Solution

There are two ways to output to PNG bitmap files. One method is to open the PNG graphics device with `png()`, make the plots, then close the device with `dev.off()`. This method works for most graphics in R, including base graphics and grid-based graphics like those created by ggplot2 and lattice:

```{r eval=FALSE}
# width and height are in pixels
png("myplot.png", width = 400, height = 400)

# Make plot
plot(mtcars$wt, mtcars$mpg)

dev.off()
```

For outputting multiple plots, put `%d` in the filename. This will be replaced with 1, 2, 3, and so on, for each subsequent plot:

```{r eval=FALSE}
# width and height are in pixels
png("myplot-%d.png", width = 400, height = 400)

plot(mtcars$wt, mtcars$mpg)
print(ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point())

dev.off()
```

Notice that we called `print()` on the ggplot object to make sure that it will be output even when this code is in a script.

The width and height are in pixels, and the default is to output at 72 pixels per inch (ppi). This resolution is suitable for displaying on a screen, but will look pixelated and jagged in print.

For high-quality print output, use at least 300 ppi. Figure \@ref(fig:FIG-OUTPUT-BITMAP-RES) shows portions of the same plot at different resolutions. In this example, we'll use 300 ppi and create a 44-inch PNG file:

```{r eval=FALSE}
ppi <- 300
# Calculate the height and width (in pixels) for a 4x4-inch image at 300 ppi
png("myplot.png", width = 4*ppi, height = 4*ppi, res = ppi)
plot(mtcars$wt, mtcars$mpg)
dev.off()
```

```{r FIG-OUTPUT-BITMAP-RES, echo=FALSE, fig.cap="From left to right: PNG output at 72, 150, and 300 ppi (actual size)", fig.width=3.6}
knitr::include_graphics("fig/output-ppi.png")
```

If you are creating plots from a script and it throws an error while creating one, R might not reach the call to `dev.off()`, and could be left in a state where the PNG device is still open. When this happens, the PNG file won't open properly in a viewing program until you manually call `dev.off()`.

If you are creating a plot with ggplot, using `ggsave()` can be a little simpler. It simply saves the last plot created with `ggplot()`. You specify the width and height in inches, not pixels, and tell it how many pixels per inch to use:

```{r eval=FALSE}
ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()

# Default dimensions are in inches, but you can specify the unit
ggsave("myplot.png", width = 8, height = 8, unit = "cm", dpi = 300)
```

With `ggsave()`, you don't need to print the ggplot object, and if there is an error while creating or saving the plot there's no need to manually close the graphic device.

> **Note**
>
> Although the argument name is dpi, it really controls the *pixels* per inch (ppi), not the *dots* per inch. When a grey pixel is rendered in print, it is output with many smaller dots of black ink-and so print output has more dots per inch than pixels per inch.

### Discussion

R supports other bitmap formats, like BMP, TIFF, and JPEG, but there's really not much reason to use them instead of PNG.

The exact appearance of the resulting bitmaps varies from platform to platform. Unlike R's PDF output device, which renders consistently across platforms, the bitmap output devices may render the same plot differently on Windows, Linux, and Mac OS X. There can even be variation within each of these operating systems.

Different platforms will render fonts differently, some platforms will antialias (smooth) lines while others will not, and some platforms support alpha (transparency) while others do not. If your platform lacks support for features like antialiasing and alpha, you can use `CairoPNG()`, from the Cairo package:

```{r eval=FALSE}
install.packages("Cairo")  # One-time installation
CairoPNG("myplot.png")
plot(...)
dev.off()
```

While `CairoPNG()` does not guarantee identical rendering across platforms (fonts may not be exactly the same), it does support features like antialiasing and alpha.

Changing the resolution affects the size (in pixels) of graphical objects like text, lines, and points. For example, a 6-by-6-inch image at 75 ppi has the same pixel dimensions as a 3-by-3-inch image at 150 ppi, but the appearance will be different, as shown in Figure \@ref(fig:FIG-OUTPUT-BITMAP-SIZE). Both of these images are 450450 pixels. When displayed on a computer screen, they may display at approximately the same size, as they do here.


```{r FIG-OUTPUT-BITMAP-SIZE, echo=FALSE, fig.cap="Left: 66 inch image at 75 ppi; right: 33 inch image at 150 ppi", fig.width=6}
knitr::include_graphics("fig/output-ppi-size.png")
```


Using Fonts in PDF Files {#RECIPE-OUTPUT-FONTS-PDF}
------------------------

### Problem

You want to use fonts other than the basic ones provided by R in a PDF file.

### Solution

The extrafont package can be used to create PDF files with different fonts.

There are a number of steps involved, beginning with some one-time setup. Download and install Ghostscript [http://www.ghostscript.com/download](http://www.ghostscript.com/download), then run the following in R:

```{r eval=FALSE}
install.packages("extrafont")
library(extrafont)

# Find and save information about fonts installed on your system
font_import()

# List the fonts
fonts()
```

After the one-time setup is done, there are tasks you need to do in each R session:

```{r eval=FALSE}
library(extrafont)
# Register the fonts with R
loadfonts()

# On Windows, you may need to tell it where Ghostscript is installed
# (adjust the path to match your installation of Ghostscript)
Sys.setenv(R_GSCMD = "C:/Program Files/gs/gs9.05/bin/gswin32c.exe")
```

Finally, you can create a PDF file and embed fonts into it, as in
Figure \@ref(fig:FIG-OUTPUT-FONTS-PDF):

```{r eval=FALSE}
library(ggplot2)
ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point() +
    ggtitle("Title text goes here") +
    theme(text = element_text(size = 16, family = "Impact"))

ggsave("myplot.pdf", width = 4, height = 4)

embed_fonts("myplot.pdf")
```

```{r FIG-OUTPUT-FONTS-PDF, echo=FALSE, fig.cap="PDF output with embedded font Impact", fig.width=4}
knitr::include_graphics("fig/output-fonts-pdf.png")
```

### Discussion

Fonts can be difficult to work with in R. Some output devices, such as the on-screen quartz device on Mac OS X, can display any font installed on the computer. Other output devices, such as the default png device on Windows, aren't able to display system fonts.

On top of this, PDF files have their own quirks when it comes to fonts. The PDF specification has 14 "core" fonts. These are fonts that every PDF renderer has, and they include standards such as Times, Helvetica, and Courier. If you create a PDF with these fonts, any PDF renderer should display it properly.

If you want to use a font that is *not* one of these core fonts, though, there's no guarantee that the PDF renderer on a given device will have that font, so you can't be sure that the font will display properly on another computer or printer. To solve this problem, non-core fonts can be *embedded* into the PDF; in other words, the PDF file can itself contain a copy of the font you want to use.

If you are putting multiple PDF figures in a PDF document, you may want to embed the fonts in the finished document instead of in each figure. This will make the final document smaller, since it will only have the font embedded once, instead of once for each figure.

Embedding fonts with R can be a tricky process, but the extrafont package handles many of the ugly details for you.

> **Note**
>
> As of this writing, extrafont will only import TrueType (*.ttf*) fonts, but it may support other common formats, such as OpenType (*.otf*), in the future.

### See Also

For more on controlling text appearance, see Recipe \@ref(RECIPE-APPEARANCE-TEXT-APPEARANCE).


Using Fonts in Windows Bitmap or Screen Output {#RECIPE-OUTPUT-FONTS-WIN}
----------------------------------------------

### Problem

You are using Windows and want to use fonts other than the basic ones provided by R for bitmap or screen output.

### Solution

The extrafont package can be used to create bitmap or screen output. The procedure is similar to using extrafont with PDF files (Recipe \@ref(RECIPE-OUTPUT-FONTS-PDF)). The one-time setup is almost the same, except that Ghostscript is not required:

```{r eval=FALSE}
install.packages("extrafont")
library(extrafont)

# Find and save information about fonts installed on your system
font_import()

# List the fonts
fonts()
```

After the one-time setup is done, there are tasks you need to do in each R session:

```{r eval=FALSE}
library(extrafont)
# Register the fonts for Windows
loadfonts("win")
```

Finally, you can create each output file or display graphs on screen, as in Figure \@ref(fig:FIG-OUTPUT-FONTS-WIN):

```{r eval=FALSE}
library(ggplot2)
ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point() +
    ggtitle("Title text goes here") +
    theme(text = element_text(size = 16, family = "Georgia", face = "italic"))

ggsave("myplot.png", width = 4, height = 4, dpi = 300)
```

```{r FIG-OUTPUT-FONTS-PNG, echo=FALSE, fig.cap="PNG output with font Georgia Italic", fig.width=4}
knitr::include_graphics("fig/output-fonts-png.png")
```

### Discussion

Fonts are handled in a completely different way for bitmaps than they are for PDF files.

On Windows, for bitmap output it is necessary to register each font manually with R (extrafont makes this much easier). On Mac OS X and Linux, the fonts should already be available for bitmap output; it isn't necessary to register them manually.

<!--chapter:end:ch14.Rmd-->

---
output:
  bookdown::html_document2:
    fig_caption: yes
editor_options:
  chunk_output_type: console
---

```{r echo = FALSE, cache = FALSE}
# This block needs cache=FALSE to set fig.width and fig.height, and have those
# persist across cached builds.

source("utils.R", local = TRUE)
knitr::opts_chunk$set(fig.width=3.5, fig.height=3.5)


# Need to load MASS before dplyr because of conflict with select()
suppressPackageStartupMessages({
    library(MASS)
    library(dplyr)
})
```

Getting Your Data into Shape {#CHAPTER-DATAPREP}
============================

When it comes to making data graphics, half the battle occurs before you call any plotting commands. Before you pass your data to the plotting functions, it must first be read in and given the correct structure. The data sets provided with R are ready to use, but when dealing with real-world data, this usually isn't the case: you'll have to clean up and restructure the data before you can visualize it.

Data sets in R are most often stored in data frames. They're typically used as two-dimensional data structures, with each row representing one case and each column representing one variable. Data frames are essentially lists of vectors and factors, all of the same length, where each vector or factor represents one column.

Here's the `heightweight` data set:

```{r}
library(gcookbook) # For the data set
heightweight
```

It consists of five columns, with each row representing one case: a set of information about a single person. We can get a clearer idea of how it's structured by using the `str()` function:

```{r}
str(heightweight)
```

The first column, `sex`, is a factor with two levels, `"f"` and `"m"`, and the other four columns are vectors of numbers (one of them, `ageMonth`, is specifically a vector of integers, but for the purposes here, it behaves the same as any other numeric vector).

Factors and character vectors behave similarly in ggplot -- the main difference is that with character vectors, items will be displayed in lexicographical order, but with factors, items will be displayed in the same order as the factor levels, which you can control.


Creating a Data Frame {#RECIPE-DATAPREP-CREATE-DATAFRAME}
---------------------

### Problem

You want to create a data frame from vectors.

### Solution

You can put vectors together in a data frame with `data.frame()`:

```{r}
# Two starting vectors
g <- c("A", "B", "C")
x <- 1:3
dat <- data.frame(g, x)
dat
```

### Discussion

A data frame is essentially a list of vectors and factors. Each vector or factor can be thought of as a column in the data frame.

If your vectors are in a list, you can convert the list to a data frame with the `as.data.frame()` function:

```{r}
lst <- list(group = g, value = x)    # A list of vectors

dat <- as.data.frame(lst)
```


The tidyverse way of creating a data frame is to use `data_frame()` or `as_data_frame()` (note the underscores instead of periods). This returns a special kind of data frame -- a *tibble* -- which behaves like a regular data frame in most contexts, but it prints out a little more nicely.


```{r eval=FALSE}
data_frame(g, x)
```

```{r eval=FALSE}
as_data_frame(lst)
```


Getting Information About a Data Structure {#RECIPE-DATAPREP-INFO-DATA}
------------------------------------------

### Problem

You want to find out information about an object or data structure.

### Solution

Use the `str()` function:

```{r}
str(ToothGrowth)
```

This tells us that `ToothGrowth` is a data frame with three columns, `len`, `supp`, and `dose`. `len` and `dose` contain numeric values, while `supp` is a factor with two levels.

### Discussion

The `str()` function is very useful for finding out more about data structures. One common source of problems is a data frame where one of the columns is a character vector instead of a factor, or vice versa. This can cause puzzling issues with analyses or graphs.

When you print out a data frame the normal way, by just typing the name at the prompt and pressing Enter, factor and character columns appear exactly the same. The difference will be revealed only when you run `str()` on the data frame, or print out the column by itself:

```{r}
tg <- ToothGrowth
tg$supp <- as.character(tg$supp)
str(tg)
```

```{r}
# Print out the columns by themselves
# From old data frame (factor)
ToothGrowth$supp
# From new data frame (character)
tg$supp
```



Adding a Column to a Data Frame {#RECIPE-DATAPREP-ADD-COL}
-------------------------------

### Problem

You want to add a column to a data frame.

### Solution

Just assign some value to the new column.

If you assign a single value to the new column, the entire column will be filled with that value. This adds a column named newcol, filled with NA:

```{r eval=FALSE}
data$newcol <- NA
```

You can also assign a vector to the new column:

```{r eval=FALSE}
data$newcol <- vec
```

If the length of the vector is less than the number of rows in the data frame, then the vector is repeated to fill all the rows.

### Discussion

Each column of a data frame is a vector. R handles them slightly differently from standalone vectors because all the columns in a data frame have the same length.


Deleting a Column from a Data Frame {#RECIPE-DATAPREP-DELETE-COL}
-----------------------------------

### Problem

You want to delete a column from a data frame.

### Solution

Assign `NULL` to that column:

```{r eval=FALSE}
data$badcol <- NULL
```

### Discussion

You can also use the `subset()` function and put a `-` (minus sign) in front of the column(s) to drop:

```{r eval=FALSE}
# Return data without badcol
data <- subset(data, select = -badcol)

# Exclude badcol and othercol
data <- subset(data, select = c(-badcol, -othercol))
```

The Tidyverse way of dropping columns is to use `select()` instead of `subset()`.

```{r eval=FALSE}
data <- select(data, -badcol, -othercol)
```


### See Also

Recipe \@ref(RECIPE-DATAPREP-SUBSET) for more on getting a subset of a data frame.

See `?select` for more ways to drop and keep columns.


Renaming Columns in a Data Frame {#RECIPE-DATAPREP-RENAME-COL}
--------------------------------

### Problem

You want to rename the columns in a data frame.

### Solution

Use the `names(dat) <-`:

```{r eval=FALSE}
names(dat) <- c("name1", "name2", "name3")
```


### Discussion

If you want to rename the columns by name:

```{r}
library(gcookbook) # For the data set
ah <- anthoming    # Copy the data because we'll modify it
names(ah)   # Print the names of the columns

names(ah)[names(ah) == "angle"] <- "Angle"
names(ah)
```

They can also be renamed by numeric position:

```{r}
names(ah)[2] <- "Experimental"
names(ah)
```

The tidyverse way: use the `rename()` function. This returns a new data frame, so it needs to be saved over the original.

```{r}
library(dplyr)
ah <- rename(ah, Control = ctrl)
names(ah)
```



Reordering Columns in a Data Frame {#RECIPE-DATAPREP-REORDER-COL}
----------------------------------

### Problem

You want to change the order of columns in a data frame.

### Solution

To reorder columns by their numeric position:

```{r eval=FALSE}
dat <- dat[c(1, 3, 2)]
```

To reorder by column name:

```{r eval=FALSE}
dat <- dat[c("col1", "col3", "col2")]
```

### Discussion

The previous examples use list-style indexing. A data frame is essentially a list of vectors, and indexing into it as a list will return another data frame. You can get the same effect with matrix-style indexing:

```{r echo=FALSE}
# Get the original data
data(anthoming)
```

```{r}
library(gcookbook) # For the data set
anthoming

anthoming[c(1,3,2)] # List-style indexing

# Putting nothing before the comma means to select all rows
anthoming[, c(1,3,2)] # Matrix-style indexing
```

In this case, both methods return the same result, a data frame. However, when retrieving a single column, list-style indexing will return a data frame, while matrix-style indexing will return a vector:

```{r}
anthoming[3] # List-style indexing
anthoming[, 3] # Matrix-style indexing
```

You can use `drop=FALSE` to ensure that it returns a data frame:

```{r}
anthoming[, 3, drop=FALSE] # Matrix-style indexing with drop=FALSE
```


The tidyverse way: use the `select()` function.

```{r}
select(anthoming, angle, ctrl, expt)
select(anthoming, 1, 3, 2)
```

The `?select_helpers` documentation also shows other ways to select columns. You can, for example, select columns by matching parts of the name.


Getting a Subset of a Data Frame {#RECIPE-DATAPREP-SUBSET}
--------------------------------

### Problem

You want to get a subset of a data frame.

### Solution

Use the `subset()` function. It can be used to pull out rows that satisfy a set of conditions and to select particular columns.

We'll use the `climate` data set for the examples here:

```{r}
library(gcookbook) # For the data set
climate
```

The following will pull out only rows where `Source` is `"Berkeley"` and only the columns named `Year` and `Anomaly10y`:

```{r}
subset(climate, Source == "Berkeley", select = c(Year, Anomaly10y))
```

### Discussion

It is possible to use multiple selection criteria, by using the `|` (OR) and `&` (AND) operators. For example, this will pull out only those rows where source is `"Berkeley"`, between the years 1900 and 2000:

```{r}
subset(climate, Source == "Berkeley" & Year >= 1900 & Year <= 2000,
       select = c(Year, Anomaly10y))
```

You can also get a subset of data by indexing into the data frame with square brackets, although this approach is somewhat less elegant. The following code has the same effect as the code we just saw. The part before the comma picks out the rows, and the part after the comma picks out the columns:

```{r eval=FALSE}
climate[climate$Source=="Berkeley" & climate$Year >= 1900 & climate$Year <= 2000,
        c("Year", "Anomaly10y")]
```

If you grab just a single column this way, it will be returned as a vector instead of a data frame. To prevent this, use drop=FALSE, as in:

```{r eval=FALSE}
climate[climate$Source=="Berkeley" & climate$Year >= 1900 & climate$Year <= 2000,
        c("Year", "Anomaly10y"), drop=FALSE]
```

Finally, it's also possible to pick out rows and columns by their numeric position. This gets the second and fifth columns of the first 100 rows:

```{r eval=FALSE}
climate[1:100, c(2, 5)]
```

I generally recommend indexing using names rather than numbers when possible. It makes the code easier to understand when you're collaborating with others or when you come back to it months or years after writing it, and it makes the code less likely to break when there are changes to the data, such as when columns are added or removed.


The tidyverse way: Use `select()` to get out the columns you want, and `filter()` to get the rows. These operations can be chained together using the `%>%` operator.

```{r eval=FALSE}
climate %>%
    filter(Source == "Berkeley" & Year >= 1900 & Year <= 2000) %>%
    select(Year, Anomaly10y)

# The code above is equivalent to:
climate <- filter(climate, Source == "Berkeley" & Year >= 1900 & Year <= 2000)
climate <- select(climate, Year, Anomaly10y)
```

The `filter()` function picks out rows based on a condition. If you want to pick out rows based on their numeric position, use the `slice()` function:

```{r eval=FALSE}
slice(climate, 1:100)
```


Changing the Order of Factor Levels {#RECIPE-DATAPREP-FACTOR-REORDER}
-----------------------------------

### Problem

You want to change the order of levels in a factor.

### Solution

The level order can be specified explicitly by passing the factor to `factor()` and specifying levels. In this example, we'll create a factor that initially has the wrong ordering:

```{r}
# By default, levels are ordered alphabetically
sizes <- factor(c("small", "large", "large", "small", "medium"))
sizes

# Change the order of levels
sizes <- factor(sizes, levels = c("small", "medium", "large"))
sizes
```

The order can also be specified with `levels` when the factor is first created.

### Discussion

There are two kinds of factors in R: ordered factors and regular factors. (In practice, ordered levels are not commonly used.) In both types, the levels are arranged in *some* order; the difference is that the order is meaningful for an ordered factor, but it is arbitrary for a regular factor -- it simply reflects how the data is stored. For plotting data, the distinction between ordered and regular factors is generally unimportant, and they can be treated the same.

The order of factor levels affects graphical output. When a factor variable is mapped to an aesthetic property in ggplot, the aesthetic adopts the ordering of the factor levels. If a factor is mapped to the x-axis, the ticks on the axis will be in the order of the factor levels, and if a factor is mapped to color, the items in the legend will be in the order of the factor levels.

To reverse the level order, you can use `rev(levels())`:

```{r eval=FALSE}
factor(sizes, levels = rev(levels(sizes)))
```

The tidyverse way: Use `fct_relevel()` from the **forcats** package.

```{r}
library(forcats)
fct_relevel(sizes, "small", "medium", "large")
```


### See Also

To reorder a factor based on the value of another variable, see Recipe \@ref(RECIPE-DATAPREP-FACTOR-REORDER-VALUE).

Reordering factor levels is useful for controlling the order of axes and legends. See Recipes Recipe \@ref(RECIPE-AXIS-ORDER) and Recipe \@ref(RECIPE-LEGEND-ORDER) for more information.



Changing the Order of Factor Levels Based on Data Values {#RECIPE-DATAPREP-FACTOR-REORDER-VALUE}
--------------------------------------------------------

### Problem

You want to change the order of levels in a factor based on values in the data.

### Solution

Use `reorder()` with the factor that has levels to reorder, the values to base the reordering on, and a function that aggregates the values:

```{r}
# Make a copy since we'll modify it
iss <- InsectSprays
iss$spray
iss$spray <- reorder(iss$spray, iss$count, FUN = mean)
iss$spray
```

Notice that the original levels were `ABCDEF`, while the reordered levels are `CEDABF`. The new order is determined by splitting `iss$count` into pieces according to the values in `iss$spray`, and then taking the mean of each group.

### Discussion

The usefulness of `reorder()` might not be obvious from just looking at the raw output. Figure \@ref(fig:FIG-DATAPREP-FACTOR-REORDER-VALUE) shows three graphs made with `reorder()`. In these graphs, the order in which the items appear is determined by their values.

```{r FIG-DATAPREP-FACTOR-REORDER-VALUE, echo=FALSE, fig.show="hold", fig.cap="Left: original data; middle: reordered by the mean of each group; right: reordered by the median of each group", fig.height=2.5, fig.width=3}
library(ggplot2)
ggplot(InsectSprays, aes(spray, count)) +
    geom_boxplot()

ggplot(InsectSprays, aes(reorder(spray, count), count)) +
    geom_boxplot()

ggplot(InsectSprays, aes(reorder(spray, count, FUN=median), count)) +
    geom_boxplot()
```

In the middle graph in Figure \@ref(fig:FIG-DATAPREP-FACTOR-REORDER-VALUE), the boxes are sorted by the mean. The horizontal line that runs across each box represents the *median* of the data. Notice that these values do not increase strictly from left to right. That's because with this particular data set, sorting by the mean gives a different order than sorting by the median. To make the median lines increase from left to right, as in the graph on the right in Figure \@ref(fig:FIG-DATAPREP-FACTOR-REORDER-VALUE), we used the `median()` function in `reorder()`.

The tidyverse way: Use `fct_reorder()` from the forcats package.

```{r echo=FALSE}
# Restore iss to original value
iss <- InsectSprays
```

```{r}
library(forcats)
fct_reorder(iss$spray, iss$count, .fun = mean)
```

### See Also

Reordering factor levels is also useful for controlling the order of axes and legends. See Recipes \@ref(RECIPE-AXIS-ORDER) and \@ref(RECIPE-LEGEND-ORDER) for more information.



Changing the Names of Factor Levels {#RECIPE-DATAPREP-FACTOR-RENAME}
-----------------------------------

### Problem

You want to change the names of levels in a factor.

### Solution

Use `fct_recode()` from the forcats package:

```{r}
sizes <- factor(c( "small", "large", "large", "small", "medium"))
sizes

# With revalue(), pass it a named vector with the mappings
fct_recode(sizes, S = "small", M = "medium", L = "large")
```

### Discussion

If you want to use two vectors, one with the original levels and one with the new ones, use `do.call()` with `fct_recode()`.

```{r}
old <- c("small", "medium", "large")
new <- c("S", "M", "L")
# Create a named vector that has the mappings between old and new
mappings <- setNames(old, new)
mappings

# Create a list of the arguments to pass to fct_recode
args <- c(list(sizes), mappings)
# Look at the structure of the list
str(args)
# Use do.call to call fct_recode with the arguments
do.call(fct_recode, args)
```

Or, more concisely, we can do all of that in one go:

```{r}
do.call(
    fct_recode,
    c(list(sizes), setNames(c("small", "medium", "large"), c("S", "M", "L")))
)
```


For a more traditional (and clunky) R method for renaming factor levels, use the `levels()<-` function:

```{r}
sizes <- factor(c( "small", "large", "large", "small", "medium"))
# Index into the levels and rename each one
levels(sizes)[levels(sizes) == "large"]  <- "L"
levels(sizes)[levels(sizes) == "medium"] <- "M"
levels(sizes)[levels(sizes) == "small"]  <- "S"
sizes
```

If you are renaming *all* your factor levels, there is a simpler method. You can pass a list to `levels()<-`:

```{r}
sizes <- factor(c("small", "large", "large", "small", "medium"))
levels(sizes) <- list(S = "small", M = "medium", L = "large")
sizes
```

With this method, all factor levels must be specified in the list; if any are missing, they will be replaced with `NA`.

It's also possible to rename factor levels by position, but this is somewhat inelegant:

```{r}
sizes <- factor(c("small", "large", "large", "small", "medium"))
levels(sizes)[1] <- "L"
sizes
# Rename all levels at once
levels(sizes) <- c("L", "M", "S")
sizes
```

It's safer to rename factor levels by name rather than by position, since you will be less likely to make a mistake (and mistakes here may be hard to detect). Also, if your input data set changes to have more or fewer levels, the numeric positions of the existing levels could change, which could cause serious but nonobvious problems for your analysis.

### See Also

If, instead of a factor, you have a character vector with items to rename, see Recipe \@ref(RECIPE-DATAPREP-CHARACTER-RENAME).



Removing Unused Levels from a Factor {#RECIPE-DATAPREP-FACTOR-DROPLEVELS}
------------------------------------

### Problem

You want to remove unused levels from a factor.

### Solution

Sometimes, after processing your data you will have a factor that contains levels that are no longer used. Here's an example:


```{r}
sizes <- factor(c("small", "large", "large", "small", "medium"))
sizes <- sizes[1:3]
sizes
```

To remove them, use `droplevels()`:

```{r}
droplevels(sizes)
```


### Discussion

The `droplevels()` function preserves the order of factor levels. You can use the `except` parameter to keep particular levels.

The tidyverse way: Use `fct_drop()` from the forcats package:

```{r}
fct_drop(sizes)
```



Changing the Names of Items in a Character Vector {#RECIPE-DATAPREP-CHARACTER-RENAME}
-------------------------------------------------

### Problem

You want to change the names of items in a character vector.

### Solution

Use `recode()` from the dplyr package:

```{r}
library(dplyr)

sizes <- c("small", "large", "large", "small", "medium")
sizes

# With recode(), pass it a named vector with the mappings
recode(sizes, small = "S", medium = "M", large = "L")

# Can also use quotes -- useful if there are spaces or other strange characters
recode(sizes, "small" = "S", "medium" = "M", "large" = "L")
```

### Discussion

If you want to use two vectors, one with the original levels and one with the new ones, use `do.call()` with `fct_recode()`.

```{r}
old <- c("small", "medium", "large")
new <- c("S", "M", "L")
# Create a named vector that has the mappings between old and new
mappings <- setNames(new, old)
mappings

# Create a list of the arguments to pass to fct_recode
args <- c(list(sizes), mappings)
# Look at the structure of the list
str(args)
# Use do.call to call fct_recode with the arguments
do.call(recode, args)
```

Or, more concisely, we can do all of that in one go:

```{r}
do.call(
    recode,
    c(list(sizes), setNames(c("S", "M", "L"), c("small", "medium", "large")))
)
```


Note that for `recode()`, the name and value of the arguments is reversed, compared to the `fct_recode()` function from the forcats package. With `recode()`, you would use `small="S"`, whereas for `fct_recode()`, you would use `S="small"`.


A more traditional R method is to use square-bracket indexing to select the items and rename them:

```{r}
sizes <- c("small", "large", "large", "small", "medium")
sizes[sizes=="small"]  <- "S"
sizes[sizes=="medium"] <- "M"
sizes[sizes=="large"]  <- "L"
sizes
```

### See Also

If, instead of a character vector, you have a factor with levels to rename, see Recipe \@ref(RECIPE-DATAPREP-FACTOR-RENAME).



Recoding a Categorical Variable to Another Categorical Variable {#RECIPE-DATAPREP-RECODE-CATEGORICAL}
---------------------------------------------------------------

### Problem

You want to recode a categorical variable to another variable.

### Solution

For the examples here, we'll use a subset of the `PlantGrowth` data set:

```{r}
# Work on a subset of the PlantGrowth data set
pg <- PlantGrowth[c(1,2,11,21,22), ]
pg
```

In this example, we'll recode the categorical variable group into another categorical variable, treatment. If the old value was `"ctrl"`, the new value will be `"No"`, and if the old value was `"trt1"` or `"trt2"`, the new value will be `"Yes"`.

This can be done with the `recode()` function from the dplyr package:

```{r}
library(dplyr)

recode(pg$group, ctrl = "No", trt1 = "Yes", trt2 = "Yes")
```

You can assign it as a new column in the data frame:

```{r eval=FALSE}
pg$treatment <- recode(pg$group, ctrl = "No", trt1 = "Yes", trt2 = "Yes")
```

Note that since the input was a factor, it returns a factor. If you want to get a character vector instead, use `as.character()`:

```{r}
recode(as.character(pg$group), ctrl = "No", trt1 = "Yes", trt2 = "Yes")
```


### Discussion

You can also use the `fct_recode()` function from the forcats package. It works the same, except the names and values are swapped, which may be a little more intuitive:

```{r}
library(forcats)
fct_recode(pg$group, No = "ctrl", Yes = "trt1", Yes = "trt2")
```

Another difference is that `fct_recode()` will always return a factor, whereas `recode()` will return a character vector if it is given a character vector, and will return a factor if it is given a factor.


Using base R, recoding can be done with the `match()` function:

```{r}
oldvals <- c("ctrl", "trt1", "trt2")
newvals <- factor(c("No", "Yes", "Yes"))

newvals[ match(pg$group, oldvals) ]
```

It can also be done by indexing in the vectors:

```{r echo=FALSE}
# Reset the data
pg <- PlantGrowth[c(1,2,11,21,22), ]
```

```{r}
pg$treatment[pg$group == "ctrl"] <- "No"
pg$treatment[pg$group == "trt1"] <- "Yes"
pg$treatment[pg$group == "trt2"] <- "Yes"

# Convert to a factor
pg$treatment <- factor(pg$treatment)
pg
```

Here, we combined two of the factor levels and put the result into a new column. If you simply want to rename the levels of a factor, see Recipe \@ref(RECIPE-DATAPREP-FACTOR-RENAME).

The coding criteria can also be based on values in multiple columns, by using the `&` and `|` operators:

```{r echo=FALSE}
# Reset the data
pg <- PlantGrowth[c(1,2,11,21,22), ]
```

```{r}
pg$newcol[pg$group == "ctrl" & pg$weight < 5]  <- "no_small"
pg$newcol[pg$group == "ctrl" & pg$weight >= 5] <- "no_large"
pg$newcol[pg$group == "trt1"] <- "yes"
pg$newcol[pg$group == "trt2"] <- "yes"
pg$newcol <- factor(pg$newcol)
pg
```

It's also possible to combine two columns into one using the interaction() function, which appends the values with a `.` in between. This combines the `weight` and `group` columns into a new column, `weightgroup`:

```{r echo=FALSE}
# Reset the data
pg <- PlantGrowth[c(1,2,11,21,22), ]
```

```{r}
pg$weightgroup <- interaction(pg$weight, pg$group)
pg
```

### See Also

For more on renaming factor levels, see Recipe \@ref(RECIPE-DATAPREP-FACTOR-RENAME).

See Recipe \@ref(RECIPE-DATAPREP-RECODE-CONTINUOUS) for recoding continuous values to categorical values.


Recoding a Continuous Variable to a Categorical Variable {#RECIPE-DATAPREP-RECODE-CONTINUOUS}
--------------------------------------------------------

### Problem

You want to recode a continuous variable to another variable.

### Solution

For the examples here, we'll use a subset of the `PlantGrowth` data set.

```{r}
# Work on a subset of the PlantGrowth data set
pg <- PlantGrowth[c(1,2,11,21,22), ]
pg
```

In this example, we'll recode the continuous variable weight into a categorical variable, `wtclass`, using the `cut()` function:

```{r}
pg$wtclass <- cut(pg$weight, breaks = c(0, 5, 6, Inf))
pg
```

### Discussion

For three categories we specify four bounds, which can include `Inf` and `-Inf`. If a data value falls outside of the specified bounds, it's categorized as `NA`. The result of `cut()` is a factor, and you can see from the example that the factor levels are named after the bounds.

To change the names of the levels, set the labels:

```{r}
pg$wtclass <- cut(pg$weight, breaks = c(0, 5, 6, Inf),
                  labels = c("small", "medium", "large"))
pg
```

As indicated by the factor levels, the bounds are by default *open* on the left and *closed* on the right. In other words, they don't include the lowest value, but they do include the highest value. For the smallest category, you can have it include both the lower and upper values by setting `include.lowest=TRUE`. In this example, this would result in 0 values going into the small category; otherwise, 0 would be coded as `NA`.

If you want the categories to be closed on the left and open on the right, set right = FALSE:

```{r}
cut(pg$weight, breaks = c(0, 5, 6, Inf), right = FALSE)
```

### See Also

To recode a categorical variable to another categorical variable, see Recipe \@ref(RECIPE-DATAPREP-RECODE-CATEGORICAL).




Calculating New Columns {#RECIPE-DATAPREP-CALCULATE}
-----------------------

### Problem

You want to calculate a new column of values in a data frame.

### Solution

Reference the new column with the `$` operator, and assign some values to it. For this example, we'll use a copy of the `heightweight` data set:

```{r}
library(gcookbook) # For the data set
hw <- heightweight # Make a copy of the data to work on
hw
```

This will convert `heightIn` to centimeters and store it in a new column, `heightCm`:

```{r}
hw$heightCm <- hw$heightIn * 2.54
hw
```

### Discussion

The tidyverse way: use `mutate()` from the dplyr package. You only need to specify the data frame once, as the first argument to the function, meaning these provide a cleaner syntax, especially if you are transforming multiple column:

```{r}
library(dplyr)
hw <- mutate(hw,
    heightCm = heightIn * 2.54,
    weightKg = weightLb / 2.204
)
hw
```

It is also possible to calculate a new column based on multiple columns:

```{r eval=FALSE}
# These both have the same effect
hw <- mutate(hw, bmi = weightKg / (heightCm / 100)^2)

hw$bmi <- hw$weightKg / (hw$heightCm / 100)^2
```

With `mutate()`, the columns are added sequentially. That means that we can reference a newly-created column when calculating a new column:

```{r}
hw <- heightweight
hw <- mutate(hw,
    heightCm = heightIn * 2.54,
    weightKg = weightLb / 2.204,
    bmi = weightKg / (heightCm / 100)^2
)
hw
```

### See Also

See Recipe \@ref(RECIPE-DATAPREP-CALCULATE-GROUP) for how to perform group-wise transformations on data.



Calculating New Columns by Group {#RECIPE-DATAPREP-CALCULATE-GROUP}
-------------------------------

### Problem

You want to calculate columns by performing operations on groups of data, as specified by a grouping column.

### Solution

Use `group_by()` from the dplyr package to specify the grouping variable, and then specify the operations in `mutate()`:

```{r}
library(MASS) # For the data set
library(dplyr)
cabbages %>%
    group_by(Cult) %>%
    mutate(DevWt = HeadWt - mean(HeadWt))
```

### Discussion

Let's take a closer look at the `cabbages` data set. It has two grouping variables (factors): `Cult`, which has levels c39 and c52, and `Date`, which has levels d16, d20, and d21. It also has two measured numeric variables, `HeadWt` and `VitC`:

```{r}
cabbages
```

Suppose we want to find, for each case, the deviation of `HeadWt` from the overall mean. All we have to do is take the overall mean and subtract it from the observed value for each case:

```{r}
mutate(cabbages, DevWt = HeadWt - mean(HeadWt))
```

You'll often want to do separate operations like this for each group, where the groups are specified by one or more grouping variables. Suppose, for example, we want to normalize the data within each group by finding the deviation of each case from the mean *within the group*, where the groups are specified by `Cult`. In these cases, we can use `group_by()` and `mutate()` together:

```{r}
library(dplyr)
cb <- cabbages %>%
    group_by(Cult) %>%
    mutate(DevWt = HeadWt - mean(HeadWt))
```

First it groups cabbages based on the value of `Cult`. There are two levels of `Cult`, `c39` and `c52`. It then applies the `mutate()` function to each data frame.

The before and after results are shown in
Figure \@ref(fig:FIG-DATAPREP-CALCULATE-GROUP):

```{r FIG-DATAPREP-CALCULATE-GROUP, fig.show="hold", fig.cap="Left: before normalizing; right: after normalizing"}
# The data before normalizing
ggplot(cb, aes(x=Cult, y=HeadWt)) + geom_boxplot()

# After normalizing
ggplot(cb, aes(x=Cult, y=DevWt)) + geom_boxplot()
```

You can also group the data frame on multiple variables and perform operations on multiple variables. This will group by `Cult` and `Date`, forming a group for each distinct combination of the two variables, and then it will calculate the deviation from the mean of `HeadWt` and `VitC` within each group:

```{r}
cabbages %>%
    group_by(Cult, Date) %>%
    mutate(
        DevWt = HeadWt - mean(HeadWt),
        DevVitC = VitC - mean(VitC)
    )
```

### See Also

To summarize data by groups, see Recipe \@ref(RECIPE-DATAPREP-SUMMARIZE).



Summarizing Data by Groups {#RECIPE-DATAPREP-SUMMARIZE}
--------------------------

### Problem

You want to summarize your data, based on one or more grouping variables.

### Solution

Use `group_by()` and `summarise()` from the dplyr package, and specify the operations to do:

```{r}
library(MASS) # For the data set
library(dplyr)
cabbages %>%
    group_by(Cult, Date) %>%
    summarise(
        Weight = mean(HeadWt),
        VitC = mean(VitC)
    )
```

### Discussion

There are few things going on here that may be unfamiliar if you're new to dplyr and the tidyverse in general.

First, let's take a closer look at the `cabbages` data set. It has two factors that can be used as grouping variables: `Cult`, which has levels `c39` and `c52`, and `Date`, which has levels `d16`, `d20`, and `d21`. It also has two numeric variables, `HeadWt` and `VitC`:

```{r}
cabbages
```

Finding the overall mean of `HeadWt` is simple. We could just use the `mean()` function on that column, but for reasons that will soon become clear, we'll use the `summarise()` function instead:

```{r}
library(dplyr)
summarise(cabbages, Weight = mean(HeadWt))
```

The result is a data frame with one row and one column, named `Weight`.

Often we want to find information about each subset of the data, as specified by a grouping variable. For example, suppose we want to find the mean of each `Cult` group. To do this, we can use `summarise()` with `group_by()`.

```{r}
tmp <- group_by(cabbages, Cult)
summarise(tmp, Weight = mean(HeadWt))
```

The command first groups the data frame `cabbages` based on the value of `Cult`. There are two levels of `Cult`, `c39` and `c52`, so there are two groups. It then applies the `summarise()` function to each of these data frames; it calculates `Weight` by taking the `mean()` of the `HeadWt` column in each of the sub-data frames. The resulting summaries for each group are assembled into a data frame, which is returned.

You can imagine that the `cabbages` data is split up into two separate data frames, then `summarise()` is called on each data frame (returning a one-row data frame for each), and then those results are combined together into a final data frame. This is actually how things worked in dplyr's predecessor, plyr, with the `ddply()` function.

The syntax of the previous code used a temporary variable to store results. That's a little verbose, so instead, we can use `%>%`, also known as the pipe operator, to chain the function calls together. The pipe operator simply takes what's on its left and substitutes it as the first argument of the function call on the right. The following two lines of code are equivalent:

```{r eval=FALSE}
group_by(cabbages, Cult)
# The pipe operator moves `cabbages` to the first argument position of group_by()
cabbages %>% group_by(Cult)
```

The reason it's called a pipe operator is that it lets you connect function calls together in sequence to form a pipeline of operations. Another common term for this is a different metaphor: *chaining*.

So the first argument of the function call is in a different place. So what? The advantages become apparent when chaining is involved. Here's what it would look like if you wanted to call `group_by()` and then `summarise()` without making use of a temporary variable. Instead of proceeding left to right, the computation occurs from the inside out:

```{r eval=FALSE}
summarise(group_by(cabbages, Cult), Weight = mean(HeadWt))
```

Using a temporary variable, as we did earlier, makes it more readable, but a more elegant solution is to use the pipe operator:

```{r eval=FALSE}
cabbages %>%
    group_by(Cult) %>%
    summarise(Weight = mean(HeadWt))
```

Back to summarizing data. Summarizing the data frame by grouping using more variables (or columns) is simple: just give it the names of the additional variables. It's also possible to get more than one summary value by specifying more calculated columns. Here we'll summarize each `Cult` and `Date` group, getting the average of `HeadWt` and `VitC`:

```{r}
cabbages %>%
    group_by(Cult, Date) %>%
    summarise(
        Weight = mean(HeadWt),
        Vitc = mean(VitC)
    )
```

> **Note**
>
> You might have noticed that it says that the result is grouped by `Cult`, but not `Date`. This is because the `summarise()` function removes one level of grouping. This is typically what you want when the input has one grouping variable. When there are multiple grouping variables, this may or may not be the what you want. To remove all grouping, use `ungroup()`, and to add back the original grouping, use `group_by()` again.

It's possible to do more than take the mean. You may, for example, want to compute the standard deviation and count of each group. To get the standard deviation, use `sd()`, and to get a count of rows in each group, use `n()`:

```{r}
cabbages %>%
    group_by(Cult, Date) %>%
    summarise(
        Weight = mean(HeadWt),
        sd = sd(HeadWt),
        n = n()
    )
```

Other useful functions for generating summary statistics include `min()`, `max()`, and `median()`. The `n()` function is a special function that works only inside of the dplyr functions `summarise()`, `mutate()` and `filter()`. See `?summarise` for more useful functions.

The `n()` function gets a count of rows, but if you want to have it *not* count `NA` values from a column, you need to use a different technique. For example, if you want it to ignore any `NA`s in the `HeadWt` column, use `sum(!is.na(Headwt))`.


If you want to get a count of rows


#### Dealing with NAs {#_dealing_with_literal_na_literal_s}

One potential pitfall is that `NA`s in the data will lead to `NA`s in the output. Let's see what happens if we sprinkle a few `NA`s into `HeadWt`:

```{r}
c1 <- cabbages # Make a copy
c1$HeadWt[c(1, 20, 45)] <- NA # Set some values to NA
c1 %>%
    group_by(Cult) %>%
    summarise(
        Weight = mean(HeadWt),
        sd = sd(HeadWt),
        n = n()
    )
```

The problem is that `mean()` and `sd()` simply return `NA` if any of the input values are `NA.` Fortunately, these functions have an option to deal with this very issue: setting `na.rm=TRUE` will tell them to ignore the `NA`s.


```{r}
c1 %>%
    group_by(Cult) %>%
    summarise(
        Weight = mean(HeadWt, na.rm = TRUE),
        sd = sd(HeadWt, na.rm = TRUE),
        n = n()
    )
```


#### Missing combinations {#_missing_combinations}

If there are any empty combinations of the grouping variables, they will not appear in the summarized data frame. These missing combinations can cause problems when making graphs. To illustrate, we'll remove all entries that have levels `c52` and `d21`. The graph on the left in Figure \@ref(fig:FIG-DATAPREP-SUMMARIZE-MISSING-COMBO) shows what happens when there's a missing combination in a bar graph:

```{r FIG-DATAPREP-SUMMARIZE-MISSING-COMBO-1, eval=FALSE}
# Copy cabbages and remove all rows with both c52 and d21
c2 <- filter(cabbages, !( Cult == "c52" & Date == "d21" ))
c2a <- c2 %>%
    group_by(Cult, Date) %>%
    summarise(Weight = mean(HeadWt))

ggplot(c2a, aes(x = Date, fill = Cult, y = Weight)) +
    geom_bar(position = "dodge", stat = "identity")
```


To fill in the missing combination (Figure \@ref(fig:FIG-DATAPREP-SUMMARIZE-MISSING-COMBO), right), use the `complete()` function from the tidyr package -- which, unsurprisingly, is also part of the tidyverse. Also, the grouping for `c2a` must be removed, with `ungroup()`; otherwise it will return too many rows.

```{r FIG-DATAPREP-SUMMARIZE-MISSING-COMBO-2, eval=FALSE}
library(tidyr)
c2b <- c2a %>% ungroup() %>% complete(Cult, Date)
ggplot(c2b, aes(x = Date, fill = Cult, y = Weight)) +
    geom_bar(position = "dodge", stat = "identity")
```

```{r, FIG-DATAPREP-SUMMARIZE-MISSING-COMBO, ref.label=c("FIG-DATAPREP-SUMMARIZE-MISSING-COMBO-1", "FIG-DATAPREP-SUMMARIZE-MISSING-COMBO-2"), fig.show="hold", fig.cap="Left: bar graph with a missing combination; right: with missing combination filled", fig.width=4, fig.height=3}
```

When we used `complete()`, it filled in the missing combinations with `NA`. It's possible to fill with a different value, with the `fill` parameter. See `?complete` for more information.

### See Also

If you want to calculate standard errors and confidence intervals, see Recipe \@ref(RECIPE-DATAPREP-SUMMARIZE-SE).

See Recipe \@ref(RECIPE-DISTRIBUTION-BOXPLOT-MEAN) for an example of using stat_summary() to calculate means and overlay them on a graph.

To perform transformations on data by groups, see Recipe \@ref(RECIPE-DATAPREP-CALCULATE-GROUP).



Summarizing Data with Standard Errors and Confidence Intervals {#RECIPE-DATAPREP-SUMMARIZE-SE}
--------------------------------------------------------------

### Problem

You want to summarize your data with the standard error of the mean and/or confidence intervals.

### Solution

Getting the standard error of the mean involves two steps: first get the standard deviation and count for each group, then use those values to calculate the standard error. The standard error for each group is just the standard deviation divided by the square root of the sample size:


```{r}
library(MASS) # For the data set
library(dplyr)
ca <- cabbages %>%
    group_by(Cult, Date) %>%
    summarise(
        Weight = mean(HeadWt),
        sd = sd(HeadWt),
        n = n(),
        se = sd / sqrt(n)
    )

ca
```


### Discussion

The `summarise()` function computes the columns in order, so you can refer to previous newly-created columns. That's why `se` can use the `sd` and `n` columns.

The `n()` function gets a count of rows, but if you want to have it *not* count `NA` values from a column, you need to use a different technique. For example, if you want it to ignore any `NA`s in the `HeadWt` column, use `sum(!is.na(Headwt))`.


#### Confidence Intervals {#_confidence_intervals}

Confidence intervals are calculated using the standard error of the mean and the degrees of freedom. To calculate a confidence interval, use the `qt()` function to get the quantile, then multiply that by the standard error. The `qt()` function will give quantiles of the *t*-distribution when given a probability level and degrees of freedom. For a 95% confidence interval, use a probability level of .975; for the bell-shaped *t*-distribution, this will in essence cut off 2.5% of the area under the curve at either end. The degrees of freedom equal the sample size minus one.

This will calculate the multiplier for each group. There are six groups and each has the same number of observations (10), so they will all have the same multiplier:

```{r}
ciMult <- qt(.975, ca$n - 1)
ciMult
```

Now we can multiply that vector by the standard error to get the 95% confidence interval:

```{r}
ca$ci95 <- ca$se * ciMult
ca
```

This could be done in one line, like this:

```{r eval=FALSE}
ca$ci95 <- ca$se * qt(.975, ca$n - 1)
```

For a 99% confidence interval, use .995.

Error bars that represent the standard error of the mean and confidence intervals serve the same general purpose: to give the viewer an idea of how good the estimate of the population mean is. The standard error is the standard deviation of the sampling distribution. Confidence intervals are a little easier to interpret. Very roughly, a 95% confidence interval means that there's a 95% chance that the true population mean is within the interval (actually, it doesn't mean this at all, but this seemingly simple topic is way too complicated to cover here; if you want to know more, read up on Bayesian statistics).

This function will perform all the steps of calculating the standard deviation, count, standard error, and confidence intervals. It can also handle `NA`s and missing combinations, with the `na.rm` and `.drop` options. By default, it provides a 95% confidence interval, but this can be set with the `conf.interval` argument:

```{r}
summarySE <- function(data = NULL, measurevar, groupvars = NULL, na.rm = FALSE,
                      conf.interval = .95, .drop = TRUE) {

    # New version of length which can handle NA's: if na.rm==T, don't count them
    length2 <- function (x, na.rm = FALSE) {
        if (na.rm) sum(!is.na(x))
        else       length(x)
    }

    groupvars  <- rlang::syms(groupvars)
    measurevar <- rlang::sym(measurevar)

    datac <- data %>%
        dplyr::group_by(!!!groupvars) %>%
        dplyr::summarise(
            N             = length2(!!measurevar, na.rm = na.rm),
            sd            = sd     (!!measurevar, na.rm = na.rm),
            !!measurevar := mean   (!!measurevar, na.rm = na.rm),
            se            = sd / sqrt(N),
            # Confidence interval multiplier for standard error
            # Calculate t-statistic for confidence interval:
            # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
            ci            = se * qt(conf.interval/2 + .5, N - 1)
        ) %>%
        dplyr::ungroup() %>%
        # Rearrange the columns so that sd, se, ci are last
        dplyr::select(seq_len(ncol(.) - 4), ncol(.) - 2, sd, se, ci)

    datac
}
```

The following usage example has a 99% confidence interval and handles `NA`s and missing combinations:

```{r}
# Remove all rows with both c52 and d21
c2 <- filter(cabbages, !(Cult == "c52" & Date == "d21" ))
# Set some values to NA
c2$HeadWt[c(1, 20, 45)] <- NA
summarySE(c2, "HeadWt", c("Cult", "Date"),
          conf.interval = .99, na.rm = TRUE, .drop = FALSE)
```


### See Also

See Recipe \@ref(RECIPE-ANNOTATE-ERROR-BAR) to use the values calculated here to add error bars to a graph.



Converting Data from Wide to Long {#RECIPE-DATAPREP-WIDE-TO-LONG}
---------------------------------

### Problem

You want to convert a data frame from "wide" format to "long" format.

### Solution

Use `gather()` from the tidyr package. In the `anthoming` data set, for each `angle`, there are two measurements: one column contains measurements in the experimental condition and the other contains measurements in the control condition:


```{r}
library(gcookbook) # For the data set
anthoming
```

We can reshape the data so that all the measurements are in one column. This will put the values from `expt` and `ctrl` into one column, and put the names into a different column:

```{r}
library(tidyr)
gather(anthoming, condition, count, expt, ctrl)
```

This data frame represents the same information as the original one, but it is structured in a way that is more conducive to some analyses.

### Discussion

In the source data, there are *ID* variables and *value* variables. The ID variables are those that specify which values go together. In the source data, the first row holds measurements for when `angle` is 20. In the output data frame, the two measurements, for `expt` and `ctrl`, are no longer in the same row, but we can still tell that they belong together because they have the same value of `angle`.

The value variables are by default all the non-ID variables. The names of these variables are put into a new *key* column, which we called `condition`, and the values are put into a new *value* column which we called `count`.

You can designate the *value* columns from the source data by naming them individually, as we did above with `expt` and `ctrl`. `gather()` automatically inferred that the ID variable was the remaining column, `angle`. Another way to tell it which columns are values is to do the reverse: if you exclude the `angle` column, then `gather()` will infer that the value columns are the remaining ones, `expt` and `ctrl`.

```{r eval=FALSE}
gather(anthoming, condition, count, expt, ctrl)
# Prepending the column name with a '-' means it is not a value column
gather(anthoming, condition, count, -angle)
```

There are other convenient shortcuts to specify which columns are values. For example `expt:ctrl` means to select all columns between `expt` and `ctrl` (in this particular case, there are no other columns in between, but for a larger data set you can imagine how this would save typing).

By default, `gather()` will use all of the columns from the source data as either ID columns or value columnbs. That means that if you want to ignore some columns, you'll need to filter them out first using the `select()` function.

For example, in the `drunk` data set, suppose we want to convert it to long format, keeping `sex` in one column and putting the numeric values in another column. This time, we want the values for only the `0-29` and `30-39` columns, and we want to discard the values for the other age ranges:

```{r}
# Our source data
drunk

# Try gather() with just 0-29 and 30-39
drunk %>%
    gather(age, count, "0-29", "30-39")
```

That doesn't look right! We told `gather()` that `0-29` and `30-39` were the value columns we wanted, and it automatically inferred that we wanted to use all of the other columns as ID columns, when we wanted to just keep `sex` and discard the others. The solution is to use `select()` to remove the unwanted columns first, and then `gather()`.

```{r}
library(dplyr)  # For the select() function
drunk %>%
    select(sex, "0-29", "30-39") %>%
    gather(age, count, "0-29", "30-39")
```


There are times where you may want to use use more than one column as the ID variables:

```{r}
plum_wide
# Use length and time as the ID variables (by not naming them as value variables)
gather(plum_wide, "survival", "count", dead, alive)
```

Some data sets don't come with a column with an ID variable. For example, in the `corneas` data set, each row represents one pair of measurements, but there is no ID variable. Without an ID variable, you won't be able to tell how the values are meant to be paired together. In these cases, you can add an ID variable before using melt():

```{r}
# Make a copy of the data
co <- corneas
# Add an ID column
co$id <- 1:nrow(co)

gather(co, "eye", "thickness", affected, notaffected)
```

Having numeric values for the ID variable may be problematic for subsequent analyses, so you may want to convert id to a character vector with `as.character()`, or a factor with `factor()`.

### See Also

See Recipe \@ref(RECIPE-DATAPREP-LONG-TO-WIDE) to do conversions in the other direction, from long to wide.

See the `stack()` function for another way of converting from wide to long.



Converting Data from Long to Wide {#RECIPE-DATAPREP-LONG-TO-WIDE}
---------------------------------

### Problem

You want to convert a data frame from "long" format to "wide" format.

### Solution

Use the `spread()` function from the tidyr package. In this example, we'll use the `plum` data set, which is in a long format:

```{r}
library(gcookbook) # For the data set
plum
```

The conversion to wide format takes each unique value in one column and uses those values as headers for new columns, then uses another column for source values. For example, we can "move" values in the `survival` column to the top and fill them with values from `count`:

```{r}
library(tidyr)
spread(plum, survival, count)
```

### Discussion

The `spread()` function requires you to specify a *key* column which is used for header names, and a *value* column which is used to fill the values in the output data frame. It's assumed that you want to use all the other columns as ID variables.

In the preceding example, there are two ID columns, `length` and `time`, one key column, `survival`, and one value column, `count`. What if we want to use two of the columns as keys? Suppose, for example, that we want to use `length` and `survival` as keys. This would leave us with `time` as the ID column.

The way to do this is to combine the `length` and `survival` columns together and put it in a new column, then use that new column as a key.

```{r}
# Create a new column, length_survival, from length and survival.
plum %>%
    unite(length_survival, length, survival)

# Now pass it to spread() and use length_survival as a key
plum %>%
    unite(length_survival, length, survival) %>%
    spread(length_survival, count)
```

### See Also

See Recipe \@ref(RECIPE-DATAPREP-WIDE-TO-LONG) to do conversions in the other direction, from wide to long.

See the `unstack()` function for another way of converting from long to wide.



Converting a Time Series Object to Times and Values {#RECIPE-DATAPREP-TIMESERIES}
---------------------------------------------------

### Problem

You have a time series object that you wish to convert to numeric vectors representing the time and values at each time.

### Solution

Use the `time()` function to get the time for each observation, then convert the times and values to numeric vectors with `as.numeric()`:


```{r}
# Look at nhtemp Time Series object
nhtemp

# Get times for each observation
as.numeric(time(nhtemp))

# Get value of each observation
as.numeric(nhtemp)
# Put them in a data frame
nht <- data.frame(year=as.numeric(time(nhtemp)), temp=as.numeric(nhtemp))
nht
```

### Discussion

Time series objects efficiently store information when there are observations at regular time intervals, but for use with ggplot, they need to be converted to a format that separately represents times and values for each observation.

Some time series objects are cyclical. The `presidents` data set, for example, contains four observations per year, one for each quarter:

```{r}
presidents
```

To convert it to a two-column data frame with one column representing the year with fractional values, we can do the same as before:

```{r}
pres_rating <- data.frame(
    year = as.numeric(time(presidents)),
    rating = as.numeric(presidents)
)
pres_rating
```

It is also possible to store the year and quarter in separate columns, which may be useful in some visualizations:

```{r}
pres_rating2 <- data.frame(
    year = as.numeric(floor(time(presidents))),
    quarter = as.numeric(cycle(presidents)),
    rating = as.numeric(presidents)
)
pres_rating2
```

### See Also

The zoo package is also useful for working with time series objects.

<!--chapter:end:ch15.Rmd-->

